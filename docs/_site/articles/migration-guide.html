<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Migration Guide: From Exceptions to FlowRight Result Pattern | FlowRight - Result Pattern Library for .NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Migration Guide: From Exceptions to FlowRight Result Pattern | FlowRight - Result Pattern Library for .NET ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="FlowRight">
            FlowRight
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="migration-guide-from-exceptions-to-flowright-result-pattern">Migration Guide: From Exceptions to FlowRight Result Pattern</h1>

<p>This guide helps teams migrate from exception-based error handling to the FlowRight Result pattern, providing practical strategies, code examples, and migration approaches for real-world scenarios.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#why-migrate-from-exceptions">Why Migrate from Exceptions?</a></li>
<li><a href="#core-concepts">Core Concepts</a></li>
<li><a href="#migration-strategies">Migration Strategies</a></li>
<li><a href="#common-patterns">Common Patterns</a></li>
<li><a href="#http-integration">HTTP Integration</a></li>
<li><a href="#validation-migration">Validation Migration</a></li>
<li><a href="#performance-benefits">Performance Benefits</a></li>
<li><a href="#team-adoption">Team Adoption</a></li>
<li><a href="#migration-checklist">Migration Checklist</a></li>
</ul>
<h2 id="why-migrate-from-exceptions">Why Migrate from Exceptions?</h2>
<h3 id="problems-with-exception-based-error-handling">Problems with Exception-Based Error Handling</h3>
<pre><code class="lang-csharp">// ❌ Traditional exception-based approach
public User GetUser(int userId)
{
    if (userId &lt;= 0)
        throw new ArgumentException(&quot;Invalid user ID&quot;);
    
    User user = _repository.GetById(userId);
    if (user == null)
        throw new UserNotFoundException($&quot;User {userId} not found&quot;);
    
    if (!user.IsActive)
        throw new InvalidOperationException(&quot;User is inactive&quot;);
    
    return user;
}

// Problems:
// 1. Hidden control flow - exceptions don't appear in method signatures
// 2. Performance overhead from stack unwinding
// 3. Difficult to compose operations
// 4. Hard to distinguish between different failure types
// 5. Easy to forget to handle specific exceptions
</code></pre>
<h3 id="benefits-of-the-result-pattern">Benefits of the Result Pattern</h3>
<pre><code class="lang-csharp">// ✅ FlowRight Result pattern approach
public Result&lt;User&gt; GetUser(int userId)
{
    if (userId &lt;= 0)
        return Result.Failure&lt;User&gt;(&quot;Invalid user ID&quot;);
    
    User user = _repository.GetById(userId);
    if (user == null)
        return Result.NotFound&lt;User&gt;($&quot;User {userId}&quot;);
    
    if (!user.IsActive)
        return Result.Failure&lt;User&gt;(&quot;User is inactive&quot;, 
            resultFailureType: ResultFailureType.Error);
    
    return Result.Success(user);
}

// Benefits:
// 1. Explicit error handling in method signatures
// 2. Zero-allocation success paths
// 3. Easy composition with other Result operations
// 4. Clear categorization of failure types
// 5. Compile-time safety for error handling
</code></pre>
<h2 id="core-concepts">Core Concepts</h2>
<h3 id="result-types">Result Types</h3>
<p>FlowRight provides several result types for different scenarios:</p>
<pre><code class="lang-csharp">// Non-generic Result for operations that don't return values
Result operationResult = Result.Success();
Result errorResult = Result.Failure(&quot;Operation failed&quot;);

// Generic Result&lt;T&gt; for operations that return values
Result&lt;User&gt; userResult = Result.Success(user);
Result&lt;User&gt; notFoundResult = Result.NotFound&lt;User&gt;(&quot;User with ID 123&quot;);

// Specialized failure types
Result validationResult = Result.ValidationFailure(errors);
Result securityResult = Result.Failure(securityException);
Result serverErrorResult = Result.ServerError(&quot;Database unavailable&quot;);
</code></pre>
<h3 id="pattern-matching">Pattern Matching</h3>
<p>Replace try-catch blocks with pattern matching:</p>
<pre><code class="lang-csharp">// ❌ Exception-based
try
{
    User user = GetUser(userId);
    ProcessUser(user);
}
catch (UserNotFoundException)
{
    ShowError(&quot;User not found&quot;);
}
catch (InvalidOperationException ex)
{
    ShowError($&quot;Operation error: {ex.Message}&quot;);
}

// ✅ Result pattern
Result&lt;User&gt; userResult = GetUser(userId);
userResult.Match(
    onSuccess: user =&gt; ProcessUser(user),
    onFailure: error =&gt; ShowError(error)
);

// ✅ Granular failure handling
userResult.Match(
    onSuccess: user =&gt; ProcessUser(user),
    onError: error =&gt; ShowError($&quot;Operation error: {error}&quot;),
    onSecurityException: error =&gt; ShowSecurityError(error),
    onValidationException: errors =&gt; ShowValidationErrors(errors),
    onOperationCanceledException: error =&gt; ShowCancellationMessage(error)
);
</code></pre>
<h2 id="migration-strategies">Migration Strategies</h2>
<h3 id="strategy-1-greenfield-development">Strategy 1: Greenfield Development</h3>
<p>Start all new code with Result pattern:</p>
<pre><code class="lang-csharp">// New service methods
public class UserService
{
    public Result&lt;User&gt; CreateUser(CreateUserRequest request)
    {
        return new ValidationBuilder&lt;User&gt;()
            .RuleFor(x =&gt; x.Email, request.Email)
                .NotEmpty()
                .EmailAddress()
            .RuleFor(x =&gt; x.Age, request.Age)
                .GreaterThan(0)
                .LessThan(120)
            .Build(() =&gt; new User(request.Email, request.Age));
    }
    
    public async Task&lt;Result&lt;User&gt;&gt; GetUserAsync(int userId)
    {
        try
        {
            User user = await _repository.GetByIdAsync(userId);
            return user != null 
                ? Result.Success(user)
                : Result.NotFound&lt;User&gt;($&quot;User {userId}&quot;);
        }
        catch (SqlException ex) when (ex.Number == -2) // Timeout
        {
            return Result.ServerError&lt;User&gt;(&quot;Database timeout&quot;);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error retrieving user {UserId}&quot;, userId);
            return Result.ServerError&lt;User&gt;(&quot;An error occurred retrieving the user&quot;);
        }
    }
}
</code></pre>
<h3 id="strategy-2-gradual-migration">Strategy 2: Gradual Migration</h3>
<p>Migrate existing code incrementally using adapter patterns:</p>
<pre><code class="lang-csharp">// Step 1: Create Result-returning wrapper methods
public class UserServiceAdapter
{
    private readonly LegacyUserService _legacyService;
    
    public Result&lt;User&gt; GetUserSafe(int userId)
    {
        try
        {
            User user = _legacyService.GetUser(userId); // Still throws exceptions
            return Result.Success(user);
        }
        catch (ArgumentException ex)
        {
            return Result.Failure&lt;User&gt;(ex.Message);
        }
        catch (UserNotFoundException)
        {
            return Result.NotFound&lt;User&gt;($&quot;User {userId}&quot;);
        }
        catch (SecurityException ex)
        {
            return Result.Failure&lt;User&gt;(ex);
        }
        catch (OperationCanceledException ex)
        {
            return Result.Failure&lt;User&gt;(ex);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Unexpected error getting user {UserId}&quot;, userId);
            return Result.ServerError&lt;User&gt;(&quot;An unexpected error occurred&quot;);
        }
    }
}

// Step 2: Gradually replace calls to use the safe wrapper
// Old code:
try { var user = _userService.GetUser(id); }
catch (Exception ex) { /* handle */ }

// New code:
_userServiceAdapter.GetUserSafe(id).Match(
    onSuccess: user =&gt; /* handle success */,
    onFailure: error =&gt; /* handle failure */
);

// Step 3: Eventually refactor the original service
public Result&lt;User&gt; GetUser(int userId)
{
    // Direct Result implementation without exceptions
}
</code></pre>
<h3 id="strategy-3-boundary-based-migration">Strategy 3: Boundary-Based Migration</h3>
<p>Keep existing internal code but convert at system boundaries:</p>
<pre><code class="lang-csharp">// Internal code still uses exceptions
internal class UserRepository
{
    public User GetById(int id) // Still throws
    {
        // Existing implementation
    }
}

// But convert to Results at service boundaries
public class UserApiController : ControllerBase
{
    [HttpGet(&quot;{id}&quot;)]
    public async Task&lt;ActionResult&lt;User&gt;&gt; GetUser(int id)
    {
        Result&lt;User&gt; result = await GetUserResult(id);
        
        return result.Match(
            onSuccess: user =&gt; Ok(user),
            onError: error =&gt; BadRequest(error),
            onSecurityException: error =&gt; Forbid(),
            onValidationException: errors =&gt; BadRequest(errors),
            onOperationCanceledException: error =&gt; StatusCode(408)
        );
    }
    
    private async Task&lt;Result&lt;User&gt;&gt; GetUserResult(int id)
    {
        try
        {
            User user = await _userRepository.GetByIdAsync(id);
            return Result.Success(user);
        }
        catch (UserNotFoundException)
        {
            return Result.NotFound&lt;User&gt;($&quot;User {id}&quot;);
        }
        // ... other exception handling
    }
}
</code></pre>
<h2 id="common-patterns">Common Patterns</h2>
<h3 id="1-input-validation">1. Input Validation</h3>
<p><strong>Before (Exceptions):</strong></p>
<pre><code class="lang-csharp">public void UpdateUser(int userId, string email, int age)
{
    if (userId &lt;= 0)
        throw new ArgumentException(&quot;Invalid user ID&quot;);
    
    if (string.IsNullOrEmpty(email))
        throw new ArgumentException(&quot;Email is required&quot;);
    
    if (!IsValidEmail(email))
        throw new ArgumentException(&quot;Invalid email format&quot;);
    
    if (age &lt; 0 || age &gt; 120)
        throw new ArgumentException(&quot;Age must be between 0 and 120&quot;);
    
    // Continue with update
}
</code></pre>
<p><strong>After (Result Pattern):</strong></p>
<pre><code class="lang-csharp">public Result UpdateUser(int userId, string email, int age)
{
    ValidationBuilder&lt;object&gt; validator = new();
    
    return validator
        .RuleFor(x =&gt; userId, userId, &quot;UserId&quot;)
            .GreaterThan(0)
        .RuleFor(x =&gt; email, email, &quot;Email&quot;)
            .NotEmpty()
            .EmailAddress()
        .RuleFor(x =&gt; age, age, &quot;Age&quot;)
            .InclusiveBetween(0, 120)
        .Build(() =&gt; PerformUpdate(userId, email, age));
}

private object PerformUpdate(int userId, string email, int age)
{
    // Update logic here
    return new object(); // ValidationBuilder requires a return value
}
</code></pre>
<h3 id="2-repository-pattern">2. Repository Pattern</h3>
<p><strong>Before (Exceptions):</strong></p>
<pre><code class="lang-csharp">public class UserRepository
{
    public User GetById(int id)
    {
        User user = _context.Users.FirstOrDefault(u =&gt; u.Id == id);
        if (user == null)
            throw new EntityNotFoundException($&quot;User with ID {id} not found&quot;);
        return user;
    }
    
    public void Save(User user)
    {
        try
        {
            _context.Users.Update(user);
            _context.SaveChanges();
        }
        catch (DbUpdateException ex)
        {
            throw new DataAccessException(&quot;Failed to save user&quot;, ex);
        }
    }
}
</code></pre>
<p><strong>After (Result Pattern):</strong></p>
<pre><code class="lang-csharp">public class UserRepository
{
    public Result&lt;User&gt; GetById(int id)
    {
        try
        {
            User user = _context.Users.FirstOrDefault(u =&gt; u.Id == id);
            return user != null 
                ? Result.Success(user)
                : Result.NotFound&lt;User&gt;($&quot;User with ID {id}&quot;);
        }
        catch (SqlException ex) when (ex.Number == -2) // Timeout
        {
            return Result.ServerError&lt;User&gt;(&quot;Database timeout occurred&quot;);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error retrieving user {UserId}&quot;, id);
            return Result.ServerError&lt;User&gt;(&quot;Database error occurred&quot;);
        }
    }
    
    public Result Save(User user)
    {
        try
        {
            _context.Users.Update(user);
            _context.SaveChanges();
            return Result.Success();
        }
        catch (DbUpdateConcurrencyException)
        {
            return Result.Failure(&quot;The user was modified by another user. Please refresh and try again.&quot;);
        }
        catch (DbUpdateException ex)
        {
            _logger.LogError(ex, &quot;Failed to save user {UserId}&quot;, user.Id);
            return Result.ServerError(&quot;Failed to save user&quot;);
        }
    }
}
</code></pre>
<h3 id="3-business-logic">3. Business Logic</h3>
<p><strong>Before (Exceptions):</strong></p>
<pre><code class="lang-csharp">public class OrderService
{
    public Order ProcessOrder(OrderRequest request)
    {
        User user = _userService.GetUser(request.UserId); // Throws
        Product product = _productService.GetProduct(request.ProductId); // Throws
        
        if (product.Stock &lt; request.Quantity)
            throw new InsufficientStockException($&quot;Only {product.Stock} items available&quot;);
        
        if (user.Balance &lt; product.Price * request.Quantity)
            throw new InsufficientFundsException(&quot;Insufficient funds&quot;);
        
        Order order = new Order(user, product, request.Quantity);
        _orderRepository.Save(order); // Throws
        
        return order;
    }
}
</code></pre>
<p><strong>After (Result Pattern):</strong></p>
<pre><code class="lang-csharp">public class OrderService
{
    public Result&lt;Order&gt; ProcessOrder(OrderRequest request)
    {
        Result&lt;User&gt; userResult = _userService.GetUser(request.UserId);
        if (userResult.IsFailure)
            return Result.Failure&lt;Order&gt;($&quot;User validation failed: {userResult.Error}&quot;);
        
        Result&lt;Product&gt; productResult = _productService.GetProduct(request.ProductId);
        if (productResult.IsFailure)
            return Result.Failure&lt;Order&gt;($&quot;Product validation failed: {productResult.Error}&quot;);
        
        User user = userResult.Value;
        Product product = productResult.Value;
        
        if (product.Stock &lt; request.Quantity)
            return Result.Failure&lt;Order&gt;($&quot;Insufficient stock. Only {product.Stock} items available&quot;);
        
        decimal totalCost = product.Price * request.Quantity;
        if (user.Balance &lt; totalCost)
            return Result.Failure&lt;Order&gt;(&quot;Insufficient funds for this order&quot;);
        
        Order order = new Order(user, product, request.Quantity);
        Result saveResult = _orderRepository.Save(order);
        
        return saveResult.IsSuccess 
            ? Result.Success(order)
            : Result.Failure&lt;Order&gt;($&quot;Failed to save order: {saveResult.Error}&quot;);
    }
}

// Alternative: Using Result.Combine for cleaner composition
public Result&lt;Order&gt; ProcessOrderAlternative(OrderRequest request)
{
    Result&lt;User&gt; userResult = _userService.GetUser(request.UserId);
    Result&lt;Product&gt; productResult = _productService.GetProduct(request.ProductId);
    
    // Combine the results - if either fails, we get all failure information
    Result combinedValidation = Result.Combine(userResult, productResult);
    if (combinedValidation.IsFailure)
        return Result.Failure&lt;Order&gt;(combinedValidation.Error);
    
    // Continue with business logic validation and order creation
    return ValidateAndCreateOrder(userResult.Value, productResult.Value, request);
}
</code></pre>
<h3 id="4-chaining-operations">4. Chaining Operations</h3>
<p><strong>Before (Exceptions):</strong></p>
<pre><code class="lang-csharp">public string ProcessUserData(int userId)
{
    User user = GetUser(userId); // Throws
    string processedData = ProcessData(user.Data); // Throws
    string finalResult = FormatResult(processedData); // Throws
    SaveResult(finalResult); // Throws
    return finalResult;
}
</code></pre>
<p><strong>After (Result Pattern):</strong></p>
<pre><code class="lang-csharp">// Using explicit chaining
public Result&lt;string&gt; ProcessUserData(int userId)
{
    Result&lt;User&gt; userResult = GetUser(userId);
    if (userResult.IsFailure)
        return Result.Failure&lt;string&gt;(userResult.Error);
    
    Result&lt;string&gt; processedResult = ProcessData(userResult.Value.Data);
    if (processedResult.IsFailure)
        return Result.Failure&lt;string&gt;(processedResult.Error);
    
    Result&lt;string&gt; formattedResult = FormatResult(processedResult.Value);
    if (formattedResult.IsFailure)
        return Result.Failure&lt;string&gt;(formattedResult.Error);
    
    Result saveResult = SaveResult(formattedResult.Value);
    return saveResult.IsSuccess 
        ? formattedResult
        : Result.Failure&lt;string&gt;(saveResult.Error);
}

// Using functional composition with extension methods
public Result&lt;string&gt; ProcessUserDataFunctional(int userId)
{
    return GetUser(userId)
        .Bind(user =&gt; ProcessData(user.Data))
        .Bind(processed =&gt; FormatResult(processed))
        .Bind(formatted =&gt; SaveResult(formatted)
            .Match(
                onSuccess: () =&gt; Result.Success(formatted),
                onFailure: error =&gt; Result.Failure&lt;string&gt;(error)
            ));
}

// Extension method for functional chaining (you can add this to your codebase)
public static Result&lt;TResult&gt; Bind&lt;T, TResult&gt;(this Result&lt;T&gt; result, Func&lt;T, Result&lt;TResult&gt;&gt; func)
{
    return result.Match(
        onSuccess: value =&gt; func(value),
        onFailure: error =&gt; Result.Failure&lt;TResult&gt;(error)
    );
}
</code></pre>
<h2 id="http-integration">HTTP Integration</h2>
<p>FlowRight provides seamless HTTP integration for API scenarios.</p>
<h3 id="client-side-http-calls">Client-Side HTTP Calls</h3>
<p><strong>Before (Exceptions):</strong></p>
<pre><code class="lang-csharp">public class ApiClient
{
    public async Task&lt;User&gt; GetUserAsync(int userId)
    {
        HttpResponseMessage response = await _httpClient.GetAsync($&quot;/api/users/{userId}&quot;);
        
        if (!response.IsSuccessStatusCode)
        {
            if (response.StatusCode == HttpStatusCode.NotFound)
                throw new UserNotFoundException($&quot;User {userId} not found&quot;);
            
            if (response.StatusCode == HttpStatusCode.Unauthorized)
                throw new UnauthorizedAccessException(&quot;Not authorized&quot;);
            
            throw new HttpRequestException($&quot;HTTP {response.StatusCode}: {response.ReasonPhrase}&quot;);
        }
        
        string json = await response.Content.ReadAsStringAsync();
        User user = JsonSerializer.Deserialize&lt;User&gt;(json) 
            ?? throw new InvalidDataException(&quot;Failed to deserialize user&quot;);
        
        return user;
    }
}
</code></pre>
<p><strong>After (Result Pattern):</strong></p>
<pre><code class="lang-csharp">public class ApiClient
{
    public async Task&lt;Result&lt;User&gt;&gt; GetUserAsync(int userId)
    {
        try
        {
            HttpResponseMessage response = await _httpClient.GetAsync($&quot;/api/users/{userId}&quot;);
            return await response.ToResultFromJsonAsync&lt;User&gt;();
        }
        catch (HttpRequestException ex)
        {
            return Result.ServerError&lt;User&gt;($&quot;HTTP request failed: {ex.Message}&quot;);
        }
        catch (TaskCanceledException ex)
        {
            return Result.Failure&lt;User&gt;(new OperationCanceledException(&quot;Request timed out&quot;, ex));
        }
    }
    
    // Usage
    public async Task HandleUserRequest(int userId)
    {
        Result&lt;User&gt; userResult = await GetUserAsync(userId);
        
        userResult.Match(
            onSuccess: user =&gt; DisplayUser(user),
            onError: error =&gt; ShowError($&quot;Error: {error}&quot;),
            onSecurityException: _ =&gt; RedirectToLogin(),
            onValidationException: errors =&gt; ShowValidationErrors(errors),
            onOperationCanceledException: _ =&gt; ShowTimeoutMessage()
        );
    }
}
</code></pre>
<h3 id="server-side-api-controllers">Server-Side API Controllers</h3>
<p><strong>Before (Exceptions):</strong></p>
<pre><code class="lang-csharp">[ApiController]
[Route(&quot;api/[controller]&quot;)]
public class UsersController : ControllerBase
{
    [HttpGet(&quot;{id}&quot;)]
    public ActionResult&lt;User&gt; GetUser(int id)
    {
        try
        {
            User user = _userService.GetUser(id);
            return Ok(user);
        }
        catch (UserNotFoundException)
        {
            return NotFound();
        }
        catch (UnauthorizedAccessException)
        {
            return Forbid();
        }
        catch (ArgumentException ex)
        {
            return BadRequest(ex.Message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error retrieving user {UserId}&quot;, id);
            return StatusCode(500, &quot;An error occurred&quot;);
        }
    }
    
    [HttpPost]
    public ActionResult&lt;User&gt; CreateUser(CreateUserRequest request)
    {
        try
        {
            User user = _userService.CreateUser(request);
            return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
        }
        catch (ValidationException ex)
        {
            return BadRequest(ex.ValidationErrors);
        }
        catch (DuplicateEmailException)
        {
            return Conflict(&quot;Email already exists&quot;);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, &quot;Error creating user&quot;);
            return StatusCode(500, &quot;An error occurred&quot;);
        }
    }
}
</code></pre>
<p><strong>After (Result Pattern):</strong></p>
<pre><code class="lang-csharp">[ApiController]
[Route(&quot;api/[controller]&quot;)]
public class UsersController : ControllerBase
{
    [HttpGet(&quot;{id}&quot;)]
    public async Task&lt;ActionResult&lt;User&gt;&gt; GetUser(int id)
    {
        Result&lt;User&gt; result = await _userService.GetUserAsync(id);
        
        return result.Match(
            onSuccess: user =&gt; Ok(user),
            onError: error =&gt; BadRequest(error),
            onSecurityException: _ =&gt; Forbid(),
            onValidationException: errors =&gt; BadRequest(errors),
            onOperationCanceledException: _ =&gt; StatusCode(408, &quot;Request timeout&quot;)
        );
    }
    
    [HttpPost]
    public async Task&lt;ActionResult&lt;User&gt;&gt; CreateUser(CreateUserRequest request)
    {
        Result&lt;User&gt; result = await _userService.CreateUserAsync(request);
        
        return result.Match(
            onSuccess: user =&gt; CreatedAtAction(nameof(GetUser), new { id = user.Id }, user),
            onError: error =&gt; BadRequest(error),
            onSecurityException: _ =&gt; Forbid(),
            onValidationException: errors =&gt; BadRequest(errors),
            onOperationCanceledException: _ =&gt; StatusCode(408, &quot;Request timeout&quot;)
        );
    }
    
    // Alternative: Extension method for cleaner controller actions
    [HttpGet(&quot;{id}/alternative&quot;)]
    public async Task&lt;ActionResult&lt;User&gt;&gt; GetUserAlternative(int id)
    {
        Result&lt;User&gt; result = await _userService.GetUserAsync(id);
        return result.ToActionResult();
    }
}

// Extension method to convert Results to ActionResults
public static class ResultExtensions
{
    public static ActionResult&lt;T&gt; ToActionResult&lt;T&gt;(this Result&lt;T&gt; result)
    {
        return result.Match(
            onSuccess: value =&gt; new OkObjectResult(value),
            onError: error =&gt; new BadRequestObjectResult(error),
            onSecurityException: _ =&gt; new ForbidResult(),
            onValidationException: errors =&gt; new BadRequestObjectResult(errors),
            onOperationCanceledException: _ =&gt; new StatusCodeResult(408)
        );
    }
    
    public static ActionResult ToActionResult(this Result result)
    {
        return result.Match(
            onSuccess: () =&gt; new OkResult(),
            onError: error =&gt; new BadRequestObjectResult(error),
            onSecurityException: _ =&gt; new ForbidResult(),
            onValidationException: errors =&gt; new BadRequestObjectResult(errors),
            onOperationCanceledException: _ =&gt; new StatusCodeResult(408)
        );
    }
}
</code></pre>
<h2 id="validation-migration">Validation Migration</h2>
<h3 id="from-data-annotations">From Data Annotations</h3>
<p><strong>Before (Data Annotations + Exceptions):</strong></p>
<pre><code class="lang-csharp">public class CreateUserRequest
{
    [Required(ErrorMessage = &quot;Name is required&quot;)]
    [StringLength(50, ErrorMessage = &quot;Name cannot exceed 50 characters&quot;)]
    public string Name { get; set; }
    
    [Required(ErrorMessage = &quot;Email is required&quot;)]
    [EmailAddress(ErrorMessage = &quot;Invalid email format&quot;)]
    public string Email { get; set; }
    
    [Range(18, 120, ErrorMessage = &quot;Age must be between 18 and 120&quot;)]
    public int Age { get; set; }
}

public User CreateUser(CreateUserRequest request)
{
    ValidationContext context = new(request);
    List&lt;ValidationResult&gt; results = [];
    
    if (!Validator.TryValidateObject(request, context, results, true))
    {
        Dictionary&lt;string, List&lt;string&gt;&gt; errors = results
            .GroupBy(r =&gt; r.MemberNames.First())
            .ToDictionary(g =&gt; g.Key, g =&gt; g.Select(r =&gt; r.ErrorMessage).ToList());
        
        throw new ValidationException(errors);
    }
    
    return new User(request.Name, request.Email, request.Age);
}
</code></pre>
<p><strong>After (FlowRight Validation):</strong></p>
<pre><code class="lang-csharp">public class CreateUserRequest
{
    public string Name { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public int Age { get; set; }
}

public Result&lt;User&gt; CreateUser(CreateUserRequest request)
{
    return new ValidationBuilder&lt;User&gt;()
        .RuleFor(x =&gt; x.Name, request.Name)
            .NotEmpty()
            .MaxLength(50)
        .RuleFor(x =&gt; x.Email, request.Email)
            .NotEmpty()
            .EmailAddress()
        .RuleFor(x =&gt; x.Age, request.Age)
            .InclusiveBetween(18, 120)
        .Build(() =&gt; new User(request.Name, request.Email, request.Age));
}
</code></pre>
<h3 id="from-fluentvalidation">From FluentValidation</h3>
<p><strong>Before (FluentValidation + Exceptions):</strong></p>
<pre><code class="lang-csharp">public class CreateUserRequestValidator : AbstractValidator&lt;CreateUserRequest&gt;
{
    public CreateUserRequestValidator()
    {
        RuleFor(x =&gt; x.Name)
            .NotEmpty()
            .MaximumLength(50);
            
        RuleFor(x =&gt; x.Email)
            .NotEmpty()
            .EmailAddress();
            
        RuleFor(x =&gt; x.Age)
            .InclusiveBetween(18, 120);
    }
}

public User CreateUser(CreateUserRequest request)
{
    CreateUserRequestValidator validator = new();
    ValidationResult result = validator.Validate(request);
    
    if (!result.IsValid)
    {
        throw new ValidationException(result.Errors);
    }
    
    return new User(request.Name, request.Email, request.Age);
}
</code></pre>
<p><strong>After (FlowRight Validation):</strong></p>
<pre><code class="lang-csharp">// No separate validator class needed
public Result&lt;User&gt; CreateUser(CreateUserRequest request)
{
    return new ValidationBuilder&lt;User&gt;()
        .RuleFor(x =&gt; x.Name, request.Name)
            .NotEmpty()
            .MaxLength(50)
        .RuleFor(x =&gt; x.Email, request.Email)
            .NotEmpty()
            .EmailAddress()
        .RuleFor(x =&gt; x.Age, request.Age)
            .InclusiveBetween(18, 120)
        .Build(() =&gt; new User(request.Name, request.Email, request.Age));
}

// Or if you prefer a separate validator pattern:
public class UserValidator
{
    public static Result&lt;User&gt; ValidateAndCreate(CreateUserRequest request)
    {
        return new ValidationBuilder&lt;User&gt;()
            .RuleFor(x =&gt; x.Name, request.Name)
                .NotEmpty()
                .MaxLength(50)
            .RuleFor(x =&gt; x.Email, request.Email)
                .NotEmpty()
                .EmailAddress()
                .Must(email =&gt; IsUniqueEmail(email), &quot;Email already exists&quot;)
            .RuleFor(x =&gt; x.Age, request.Age)
                .InclusiveBetween(18, 120)
            .Build(() =&gt; new User(request.Name, request.Email, request.Age));
    }
    
    private static bool IsUniqueEmail(string email)
    {
        // Check database for uniqueness
        return true;
    }
}
</code></pre>
<h2 id="performance-benefits">Performance Benefits</h2>
<h3 id="exception-performance-costs">Exception Performance Costs</h3>
<pre><code class="lang-csharp">// ❌ Expensive exception throwing
[Benchmark]
public string ProcessWithExceptions()
{
    try
    {
        return ProcessData(&quot;invalid-data&quot;); // Throws frequently
    }
    catch (ArgumentException)
    {
        return &quot;Invalid data&quot;;
    }
}

// Results:
// Method               | Mean    | Error   | StdDev  | Allocated
// -------------------- |--------:|--------:|--------:|----------:
// ProcessWithExceptions| 2.543 μs| 0.051 μs| 0.048 μs|     552 B
</code></pre>
<h3 id="result-pattern-performance">Result Pattern Performance</h3>
<pre><code class="lang-csharp">// ✅ Fast Result pattern
[Benchmark]
public string ProcessWithResults()
{
    Result&lt;string&gt; result = ProcessDataSafe(&quot;invalid-data&quot;);
    return result.Match(
        onSuccess: data =&gt; data,
        onFailure: _ =&gt; &quot;Invalid data&quot;
    );
}

// Results:
// Method              | Mean    | Error   | StdDev  | Allocated
// ------------------- |--------:|--------:|--------:|----------:
// ProcessWithResults  | 0.012 μs| 0.001 μs| 0.001 μs|       0 B
</code></pre>
<h3 id="memory-allocation-comparison">Memory Allocation Comparison</h3>
<pre><code class="lang-csharp">// Exception stack trace allocation
public class ExceptionPerformanceTest
{
    [Benchmark]
    public bool ValidateWithExceptions(string input)
    {
        try
        {
            ValidateInput(input);
            return true;
        }
        catch (ArgumentException)
        {
            return false;
        }
    }
    
    [Benchmark]
    public bool ValidateWithResults(string input)
    {
        Result result = ValidateInputSafe(input);
        return result.IsSuccess;
    }
    
    private void ValidateInput(string input)
    {
        if (string.IsNullOrEmpty(input))
            throw new ArgumentException(&quot;Input cannot be null or empty&quot;);
    }
    
    private Result ValidateInputSafe(string input)
    {
        return string.IsNullOrEmpty(input) 
            ? Result.Failure(&quot;Input cannot be null or empty&quot;)
            : Result.Success();
    }
}

// Benchmark Results:
// |                Method |      Mean |    Error |   StdDev |  Gen 0 | Allocated |
// |---------------------- |----------:|---------:|---------:|-------:|----------:|
// | ValidateWithExceptions| 1,234.5 ns| 24.67 ns| 23.08 ns| 0.0763 |     320 B |
// | ValidateWithResults   |     1.2 ns|  0.03 ns|  0.02 ns|      - |       0 B |
</code></pre>
<h2 id="team-adoption">Team Adoption</h2>
<h3 id="phase-1-education-and-setup-weeks-1-2">Phase 1: Education and Setup (Weeks 1-2)</h3>
<ol>
<li><p><strong>Team Training</strong></p>
<ul>
<li>Present this migration guide</li>
<li>Code examples and hands-on practice</li>
<li>Establish coding standards</li>
</ul>
</li>
<li><p><strong>Development Environment</strong></p>
<pre><code class="lang-bash"># Install FlowRight packages
dotnet add package FlowRight.Core
dotnet add package FlowRight.Validation
dotnet add package FlowRight.Http
</code></pre>
</li>
<li><p><strong>Code Guidelines</strong></p>
<pre><code class="lang-csharp">// ✅ Good: Result methods are explicit about failure possibilities
public Result&lt;User&gt; GetUser(int id);

// ❌ Avoid: Mixed patterns in the same service
public User GetUserUnsafe(int id); // throws
public Result&lt;User&gt; GetUserSafe(int id);
</code></pre>
</li>
</ol>
<h3 id="phase-2-new-feature-development-weeks-3-6">Phase 2: New Feature Development (Weeks 3-6)</h3>
<ol>
<li><p><strong>New Code Standards</strong></p>
<ul>
<li>All new services use Result pattern</li>
<li>All new API endpoints return Results</li>
<li>All new validation uses ValidationBuilder</li>
</ul>
</li>
<li><p><strong>Code Review Checklist</strong></p>
<ul>
<li>[ ] No new exception-throwing methods</li>
<li>[ ] Results handled with Match/Switch</li>
<li>[ ] Validation uses ValidationBuilder</li>
<li>[ ] HTTP calls use ToResultAsync extensions</li>
</ul>
</li>
<li><p><strong>Example Standards Document</strong></p>
<pre><code class="lang-csharp">// Service layer standard
public interface IUserService
{
    Task&lt;Result&lt;User&gt;&gt; GetUserAsync(int id);
    Task&lt;Result&lt;User&gt;&gt; CreateUserAsync(CreateUserRequest request);
    Task&lt;Result&gt; UpdateUserAsync(int id, UpdateUserRequest request);
    Task&lt;Result&gt; DeleteUserAsync(int id);
}

// Controller standard
[ApiController]
public abstract class BaseController : ControllerBase
{
    protected ActionResult&lt;T&gt; ToActionResult&lt;T&gt;(Result&lt;T&gt; result)
    {
        return result.Match(
            onSuccess: value =&gt; Ok(value),
            onError: error =&gt; BadRequest(error),
            onSecurityException: _ =&gt; Forbid(),
            onValidationException: errors =&gt; BadRequest(errors),
            onOperationCanceledException: _ =&gt; StatusCode(408)
        );
    }
}
</code></pre>
</li>
</ol>
<h3 id="phase-3-legacy-code-migration-weeks-7-12">Phase 3: Legacy Code Migration (Weeks 7-12)</h3>
<ol>
<li><p><strong>Identify High-Impact Areas</strong></p>
<ul>
<li>Frequently called methods</li>
<li>Methods with complex exception handling</li>
<li>API boundaries</li>
</ul>
</li>
<li><p><strong>Migration Priority</strong></p>
<pre><code class="lang-csharp">// Priority 1: Public API surfaces
[ApiController]
public class UsersController : ControllerBase
{
    // Migrate these first
}

// Priority 2: Service layer interfaces
public interface IUserService
{
    // Migrate method signatures
}

// Priority 3: Internal implementations
// Can be migrated gradually
</code></pre>
</li>
<li><p><strong>Backward Compatibility</strong></p>
<pre><code class="lang-csharp">// Maintain both interfaces during transition
public class UserService : IUserService, ILegacyUserService
{
    // New Result-based methods
    public Result&lt;User&gt; GetUser(int id) =&gt; GetUserLegacy(id).ToResult();

    // Legacy methods (mark as obsolete)
    [Obsolete(&quot;Use GetUser(int) instead&quot;)]
    public User GetUserLegacy(int id)
    {
        Result&lt;User&gt; result = GetUser(id);
        return result.Match(
            onSuccess: user =&gt; user,
            onFailure: error =&gt; throw new InvalidOperationException(error)
        );
    }
}
</code></pre>
</li>
</ol>
<h3 id="phase-4-complete-migration-weeks-13">Phase 4: Complete Migration (Weeks 13+)</h3>
<ol>
<li><p><strong>Remove Legacy Code</strong></p>
<ul>
<li>Remove obsolete methods</li>
<li>Update all call sites</li>
<li>Remove exception-based error handling</li>
</ul>
</li>
<li><p><strong>Performance Optimization</strong></p>
<ul>
<li>Measure before/after performance</li>
<li>Optimize hot paths</li>
<li>Monitor memory allocation</li>
</ul>
</li>
<li><p><strong>Documentation and Training</strong></p>
<ul>
<li>Update team documentation</li>
<li>Create architecture decision records</li>
<li>Train new team members</li>
</ul>
</li>
</ol>
<h2 id="migration-checklist">Migration Checklist</h2>
<h3 id="pre-migration-assessment">Pre-Migration Assessment</h3>
<ul>
<li><p>[ ] <strong>Codebase Analysis</strong></p>
<ul>
<li>[ ] Identify all exception-throwing methods</li>
<li>[ ] Map exception types to Result failure types</li>
<li>[ ] Identify validation logic locations</li>
<li>[ ] Document API surface areas</li>
</ul>
</li>
<li><p>[ ] <strong>Team Readiness</strong></p>
<ul>
<li>[ ] Team trained on Result pattern</li>
<li>[ ] Coding standards established</li>
<li>[ ] Development environment setup</li>
<li>[ ] CI/CD pipeline updated</li>
</ul>
</li>
</ul>
<h3 id="migration-execution">Migration Execution</h3>
<ul>
<li><p>[ ] <strong>Phase 1: New Development</strong></p>
<ul>
<li>[ ] All new services use Result pattern</li>
<li>[ ] New API endpoints return Results</li>
<li>[ ] New validation uses ValidationBuilder</li>
<li>[ ] Code review process updated</li>
</ul>
</li>
<li><p>[ ] <strong>Phase 2: API Boundaries</strong></p>
<ul>
<li>[ ] HTTP client calls converted</li>
<li>[ ] API controller actions converted</li>
<li>[ ] Service interfaces updated</li>
<li>[ ] Database operations converted</li>
</ul>
</li>
<li><p>[ ] <strong>Phase 3: Internal Logic</strong></p>
<ul>
<li>[ ] Business logic methods converted</li>
<li>[ ] Repository methods converted</li>
<li>[ ] Utility methods converted</li>
<li>[ ] Legacy adapters removed</li>
</ul>
</li>
</ul>
<h3 id="post-migration-validation">Post-Migration Validation</h3>
<ul>
<li><p>[ ] <strong>Testing</strong></p>
<ul>
<li>[ ] All unit tests updated</li>
<li>[ ] Integration tests passing</li>
<li>[ ] Performance benchmarks improved</li>
<li>[ ] Error handling coverage complete</li>
</ul>
</li>
<li><p>[ ] <strong>Quality Assurance</strong></p>
<ul>
<li>[ ] No exceptions used for control flow</li>
<li>[ ] All Results properly handled</li>
<li>[ ] Error messages user-friendly</li>
<li>[ ] Logging appropriately implemented</li>
</ul>
</li>
<li><p>[ ] <strong>Performance</strong></p>
<ul>
<li>[ ] Benchmark comparisons documented</li>
<li>[ ] Memory allocation reduced</li>
<li>[ ] Response times improved</li>
<li>[ ] Error path performance optimized</li>
</ul>
</li>
</ul>
<h3 id="success-metrics">Success Metrics</h3>
<p>Track these metrics to measure migration success:</p>
<pre><code class="lang-csharp">// Example metrics tracking
public class MigrationMetrics
{
    public int ExceptionThrowingMethods { get; set; }
    public int ResultReturningMethods { get; set; }
    public int UnhandledExceptions { get; set; }
    public int MigratedApiEndpoints { get; set; }
    public double AverageResponseTime { get; set; }
    public long MemoryAllocation { get; set; }
}

// Target metrics:
// - 0 exception-throwing methods for control flow
// - 100% Result pattern adoption for new code
// - 50%+ reduction in unhandled exceptions
// - 20%+ improvement in response times
// - 30%+ reduction in memory allocation
</code></pre>
<hr>
<h2 id="conclusion">Conclusion</h2>
<p>Migrating from exceptions to the FlowRight Result pattern provides:</p>
<ol>
<li><strong>Explicit Error Handling</strong> - All failure scenarios are visible in method signatures</li>
<li><strong>Better Performance</strong> - Zero-allocation success paths and no stack unwinding overhead</li>
<li><strong>Improved Composability</strong> - Easy to chain operations and handle complex scenarios</li>
<li><strong>Enhanced Maintainability</strong> - Clear separation of success and failure flows</li>
<li><strong>Type Safety</strong> - Compile-time guarantees about error handling</li>
</ol>
<p>The migration can be done gradually, starting with new development and progressively converting existing code. Focus on high-impact areas first, maintain backward compatibility during transition, and measure success with concrete metrics.</p>
<p>Remember: The Result pattern isn't about eliminating all exceptions, but about using exceptions only for truly exceptional circumstances while handling expected failure scenarios explicitly and efficiently.</p>

</article>

        <div class="contribution d-print-none">
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          FlowRight - Explicit error handling without exceptions
        </div>
      </div>
    </footer>
  </body>
</html>
