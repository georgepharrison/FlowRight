{
  "README.html": {
    "href": "README.html",
    "title": "FlowRight API Documentation | FlowRight - Result Pattern Library for .NET",
    "summary": "FlowRight API Documentation This directory contains the DocFX configuration and build system for generating comprehensive API documentation for the FlowRight Result pattern library. \uD83C\uDFAF Overview The documentation system generates: Complete API Reference - All public APIs across Core, Validation, and Http libraries Interactive Documentation - Searchable, cross-referenced HTML documentation Getting Started Guide - Comprehensive tutorial and examples Migration Guide - Transitioning from exception-based error handling Best Practices - Production-ready patterns and recommendations \uD83D\uDCCB Prerequisites .NET 9.0 SDK or later DocFX (installed automatically by build scripts) \uD83D\uDE80 Quick Start Windows (PowerShell) # Build and generate documentation .\\build-docs.ps1 # Build and serve locally .\\build-docs.ps1 -Serve Linux/macOS (Bash) # Build and generate documentation ./build-docs.sh # Serve locally after generation docfx serve docs/_site Manual Build # 1. Install DocFX (if not already installed) dotnet tool install -g docfx # 2. Build the solution to generate XML documentation cd .. && dotnet build FlowRight.sln --configuration Release # 3. Generate documentation cd docs && docfx # 4. Serve locally (optional) docfx serve _site \uD83D\uDCC1 Structure docs/ ├── docfx.json # DocFX configuration ├── filterConfig.yml # API filtering rules ├── toc.yml # Top-level navigation ├── index.md # Documentation home page ├── api/ │ └── index.md # API reference landing page ├── articles/ │ ├── index.md # Articles overview │ ├── getting-started.md # Getting started guide │ ├── migration-guide.md # Migration guide │ └── best-practices.md # Best practices guide └── _site/ # Generated documentation (after build) ├── index.html # Home page ├── api/ # API reference HTML └── articles/ # Article HTML ⚙️ Configuration DocFX Configuration (docfx.json) Metadata Generation: Extracts API metadata from all FlowRight projects Content Processing: Processes Markdown articles and API documentation Template: Uses modern DocFX template with search functionality Filtering: Includes only FlowRight namespaces, excludes system types API Filtering (filterConfig.yml) Includes: FlowRight.* namespaces and types Excludes: System.*, Microsoft.*, and build artifacts Navigation (toc.yml) Home page Articles section with guides API reference with comprehensive coverage \uD83D\uDD27 Customization Adding New Articles Create a new .md file in articles/ Add entry to articles/toc.yml Rebuild documentation Modifying Templates The configuration uses the default DocFX modern template. To customize: Extract template: docfx template export default Modify template files Update docfx.json template reference Updating Branding Modify the globalMetadata section in docfx.json: \"globalMetadata\": { \"_appName\": \"FlowRight\", \"_appTitle\": \"FlowRight - Result Pattern Library for .NET\", \"_appFooter\": \"Your custom footer text\" } \uD83C\uDF10 Hosting The generated _site directory contains static HTML files that can be hosted anywhere: GitHub Pages # .github/workflows/docs.yml - name: Build Documentation run: ./docs/build-docs.sh - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs/_site Azure Static Web Apps build: commands: - ./docs/build-docs.sh output: docs/_site Docker FROM nginx:alpine COPY docs/_site /usr/share/nginx/html EXPOSE 80 \uD83D\uDC1B Troubleshooting Common Issues DocFX not found dotnet tool install -g docfx # Ensure ~/.dotnet/tools is in PATH Missing XML documentation warnings Ensure projects build successfully with GenerateDocumentationFile enabled Check Directory.Build.props has <GenerateDocumentationFile>true</GenerateDocumentationFile> API not appearing in documentation Verify namespace is included in filterConfig.yml Check that types are public or internal with appropriate attributes Build failures # Clean and rebuild dotnet clean && dotnet build --configuration Release cd docs && docfx --force Performance Optimization Use --cleanupCacheHistory in DocFX for clean builds Enable incremental builds in CI/CD pipelines Consider parallel builds for large documentation sets \uD83D\uDCC8 Metrics The build system tracks documentation coverage: API Coverage: All public types documented XML Documentation: Comprehensive summaries, parameters, and examples Cross-references: Automated linking between related types Search Index: Full-text search across all content \uD83E\uDD1D Contributing When adding new public APIs: Add comprehensive XML documentation Include usage examples in <example> tags Rebuild documentation to verify coverage Update related articles if needed Generated with DocFX v2.78.3 | FlowRight v1.0.0-preview.1"
  },
  "api/FlowRight.Core.Extensions.ResultAsyncExtensions.html": {
    "href": "api/FlowRight.Core.Extensions.ResultAsyncExtensions.html",
    "title": "Class ResultAsyncExtensions | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ResultAsyncExtensions Namespace FlowRight.Core.Extensions Assembly FlowRight.Core.dll Provides async-friendly extension methods for the Result and Result<T> types, enabling seamless composition of asynchronous operations with the Result pattern. public static class ResultAsyncExtensions Inheritance object ResultAsyncExtensions Examples // Async pattern matching Result result = await GetDataAsync(); string response = await result.MatchAsync( onSuccess: async () => await ProcessSuccessAsync(), onFailure: async error => await HandleErrorAsync(error) ); // Async operation chaining Result<User> userResult = await GetUserAsync() .ThenAsync(async user => await ValidateUserAsync(user)) .ThenAsync(async validUser => await SaveUserAsync(validUser)); // Async value transformation Result<string> processedResult = await userResult .MapAsync(async user => await FormatUserDisplayNameAsync(user)); Remarks These extension methods bridge the gap between synchronous Result pattern operations and asynchronous workflows, allowing for clean and efficient async/await usage while maintaining the same error handling semantics as the synchronous counterparts. The async extensions preserve all error categorization, validation information, and Result type classifications from the original Result pattern implementation. Methods CombineAsync(params Task<Result>[]) Combines multiple async Result operations, waiting for all to complete and aggregating failure information. public static Task<Result> CombineAsync(params Task<Result>[] tasks) Parameters tasks Task<Result>[] The array of async Result operations to combine. Returns Task<Result> A System.Threading.Tasks.Task<TResult> that is successful if all input operations are successful, or a failure result containing aggregated error information from all failed operations. Examples Task<Result>[] operations = [ ValidateUserAsync(user), ValidatePermissionsAsync(user), ValidateDataAsync(data) ]; Result combinedResult = await Result.CombineAsync(operations); if (combinedResult.IsFailure) { // Handle all collected errors at once LogErrors(combinedResult.Failures); } Remarks This method provides async aggregation of multiple Result operations, enabling parallel execution while collecting all errors rather than failing on the first error encountered. All tasks are awaited concurrently for optimal performance. The combining logic preserves error categorization just like the synchronous Combine(params Result[]) method. Exceptions ArgumentNullException Thrown when tasks is null. CombineAsync<T>(params Task<Result<T>>[]) Combines multiple async Result<T> operations, waiting for all to complete and aggregating failure information. public static Task<Result<T>> CombineAsync<T>(params Task<Result<T>>[] tasks) Parameters tasks Task<Result<T>>[] The array of async Result<T> operations to combine. Returns Task<Result<T>> A System.Threading.Tasks.Task<TResult> that is successful with the value from the first successful result if all input operations are successful, or a failure result containing aggregated error information from all failed operations. Type Parameters T The type of the success values in the results. Examples Task<Result<User>>[] operations = [ ValidateUserAsync(user), EnrichUserDataAsync(user), CheckUserPermissionsAsync(user) ]; Result<User> combinedResult = await Result.CombineAsync(operations); if (combinedResult.IsFailure) { // Handle all collected errors at once LogErrors(combinedResult.Failures); } Exceptions ArgumentNullException Thrown when tasks is null. MapAsync<T, TResult>(Result<T>, Func<T, Task<TResult>>) Transforms the success value of this result using an async function. public static Task<Result<TResult>> MapAsync<T, TResult>(this Result<T> result, Func<T, Task<TResult>> mapAsync) Parameters result Result<T> The result to transform. mapAsync Func<T, Task<TResult>> The async function to transform the success value. Returns Task<Result<TResult>> A System.Threading.Tasks.Task<TResult> containing the transformed value if this result is successful, or the failure information from this result if it failed. Type Parameters T The type of the success value in the current result. TResult The type of the transformed result. Examples Result<User> userResult = await GetUserAsync(); Result<string> displayNameResult = await userResult.MapAsync(async user => await FormatUserDisplayNameAsync(user) ); Remarks This method allows for async transformation of successful result values while preserving the Result pattern semantics. If the current result is a failure, the transformation is not executed and the failure is preserved. Unlike ThenAsync<T, TNext>(Result<T>, Func<T, Task<Result<TNext>>>), this method wraps the transformation result in a success Result, making it suitable for pure value transformations rather than operations that can themselves fail. Exceptions ArgumentNullException Thrown when result or mapAsync is null. MatchAsync<TResult>(Result, Func<Task<TResult>>, Func<string, Task<TResult>>) Transforms this result into a value of type TResult using async pattern matching. public static Task<TResult> MatchAsync<TResult>(this Result result, Func<Task<TResult>> onSuccess, Func<string, Task<TResult>> onFailure) Parameters result Result The result to perform pattern matching on. onSuccess Func<Task<TResult>> Async function to execute if the result is successful. onFailure Func<string, Task<TResult>> Async function to execute if the result is a failure. Receives the error message. Returns Task<TResult> A System.Threading.Tasks.Task<TResult> containing the value returned by either onSuccess or onFailure. Type Parameters TResult The type of the result to return. Examples Result operationResult = await PerformOperationAsync(); string response = await operationResult.MatchAsync( onSuccess: async () => { await LogSuccessAsync(\"Operation completed\"); return \"Success!\"; }, onFailure: async error => { await LogErrorAsync($\"Operation failed: {error}\"); return \"Failed\"; } ); Remarks This is the async equivalent of the Match<TResult>(Func<TResult>, Func<string, TResult>) method. It enables pattern matching with async handlers, allowing for clean async/await usage within result handling. This method treats all failure types uniformly, calling onFailure with the error message. For more granular async failure handling, use the overload that provides separate handlers for each failure type. Exceptions ArgumentNullException Thrown when result, onSuccess, or onFailure is null. MatchAsync<TResult>(Result, Func<Task<TResult>>, Func<string, Task<TResult>>, Func<string, Task<TResult>>, Func<IDictionary<string, string[]>, Task<TResult>>, Func<string, Task<TResult>>) Transforms this result into a value of type TResult using async pattern matching with specific handlers for each failure type. public static Task<TResult> MatchAsync<TResult>(this Result result, Func<Task<TResult>> onSuccess, Func<string, Task<TResult>> onError, Func<string, Task<TResult>> onSecurityException, Func<IDictionary<string, string[]>, Task<TResult>> onValidationException, Func<string, Task<TResult>> onOperationCanceledException) Parameters result Result The result to perform pattern matching on. onSuccess Func<Task<TResult>> Async function to execute if the result is successful. onError Func<string, Task<TResult>> Async function to execute if the result is a general error. Receives the error message. onSecurityException Func<string, Task<TResult>> Async function to execute if the result is a security failure. Receives the error message. onValidationException Func<IDictionary<string, string[]>, Task<TResult>> Async function to execute if the result is a validation failure. Receives the validation errors dictionary. onOperationCanceledException Func<string, Task<TResult>> Async function to execute if the result is a cancellation failure. Receives the error message. Returns Task<TResult> A System.Threading.Tasks.Task<TResult> containing the value returned by the appropriate handler function. Type Parameters TResult The type of the result to return. Examples Result operationResult = await ProcessRequestAsync(); string response = await operationResult.MatchAsync( onSuccess: async () => await SendSuccessNotificationAsync(), onError: async error => await HandleSystemErrorAsync(error), onSecurityException: async error => await ReportSecurityViolationAsync(error), onValidationException: async errors => await DisplayValidationErrorsAsync(errors), onOperationCanceledException: async error => await HandleCancellationAsync(error) ); Remarks This async overload provides granular control over different failure types with async handlers, allowing you to implement specific async logic for each category of failure. This is particularly useful when different failure types require different async handling strategies (async logging, async notifications, etc.). Exceptions ArgumentNullException Thrown when result or any of the handler functions is null. MatchAsync<T, TResult>(Result<T>, Func<T, Task<TResult>>, Func<string, Task<TResult>>) Transforms this result into a value of type TResult using async pattern matching. public static Task<TResult> MatchAsync<T, TResult>(this Result<T> result, Func<T, Task<TResult>> onSuccess, Func<string, Task<TResult>> onFailure) Parameters result Result<T> The result to perform pattern matching on. onSuccess Func<T, Task<TResult>> Async function to execute if the result is successful. Receives the success value. onFailure Func<string, Task<TResult>> Async function to execute if the result is a failure. Receives the error message. Returns Task<TResult> A System.Threading.Tasks.Task<TResult> containing the value returned by either onSuccess or onFailure. Type Parameters T The type of the success value in the result. TResult The type of the result to return. Examples Result<User> userResult = await GetUserAsync(userId); string response = await userResult.MatchAsync( onSuccess: async user => { await AuditUserAccessAsync(user); return $\"Welcome, {user.Name}!\"; }, onFailure: async error => { await LogFailedLoginAsync(userId, error); return \"Login failed\"; } ); Remarks This is the async equivalent of the Match<TResult>(Func<T, TResult>, Func<string, TResult>) method. It enables pattern matching with async handlers that can work with the success value. Exceptions ArgumentNullException Thrown when result, onSuccess, or onFailure is null. MatchAsync<T, TResult>(Result<T>, Func<T, Task<TResult>>, Func<string, Task<TResult>>, Func<string, Task<TResult>>, Func<IDictionary<string, string[]>, Task<TResult>>, Func<string, Task<TResult>>) Transforms this result into a value of type TResult using async pattern matching with specific handlers for each failure type. public static Task<TResult> MatchAsync<T, TResult>(this Result<T> result, Func<T, Task<TResult>> onSuccess, Func<string, Task<TResult>> onError, Func<string, Task<TResult>> onSecurityException, Func<IDictionary<string, string[]>, Task<TResult>> onValidationException, Func<string, Task<TResult>> onOperationCanceledException) Parameters result Result<T> The result to perform pattern matching on. onSuccess Func<T, Task<TResult>> Async function to execute if the result is successful. Receives the success value. onError Func<string, Task<TResult>> Async function to execute if the result is a general error. Receives the error message. onSecurityException Func<string, Task<TResult>> Async function to execute if the result is a security failure. Receives the error message. onValidationException Func<IDictionary<string, string[]>, Task<TResult>> Async function to execute if the result is a validation failure. Receives the validation errors dictionary. onOperationCanceledException Func<string, Task<TResult>> Async function to execute if the result is a cancellation failure. Receives the error message. Returns Task<TResult> A System.Threading.Tasks.Task<TResult> containing the value returned by the appropriate handler function. Type Parameters T The type of the success value in the result. TResult The type of the result to return. Examples Result<Order> orderResult = await ProcessOrderAsync(request); IActionResult response = await orderResult.MatchAsync( onSuccess: async order => { await SendOrderConfirmationAsync(order); return Ok(order); }, onError: async error => await LogAndReturnErrorAsync(error), onSecurityException: async error => await HandleSecurityViolationAsync(error), onValidationException: async errors => await ReturnValidationErrorsAsync(errors), onOperationCanceledException: async error => await HandleTimeoutAsync(error) ); Exceptions ArgumentNullException Thrown when result or any of the handler functions is null. SwitchAsync(Result, Func<Task>, Func<string, Task>, bool) Executes async side-effect actions based on the result state. public static Task SwitchAsync(this Result result, Func<Task> onSuccess, Func<string, Task> onFailure, bool includeOperationCancelledFailures = false) Parameters result Result The result to perform switching on. onSuccess Func<Task> Async action to execute if the result is successful. onFailure Func<string, Task> Async action to execute if the result is a failure. Receives the error message. includeOperationCancelledFailures bool If true, operation cancelled failures will call onFailure. If false (default), they will be ignored. Returns Task A System.Threading.Tasks.Task representing the async operation. Examples Result result = await PerformOperationAsync(); await result.SwitchAsync( onSuccess: async () => { await LogSuccessAsync(\"Operation completed\"); await NotifySubscribersAsync(); }, onFailure: async error => { await LogErrorAsync($\"Operation failed: {error}\"); await SendAlertAsync(error); } ); Remarks This is the async equivalent of the imperative Switch(Action, Action<string>, bool) method. It executes async actions with side effects rather than returning transformed values. Exceptions ArgumentNullException Thrown when result, onSuccess, or onFailure is null. SwitchAsync(Result, Func<Task>, Func<string, Task>, Func<string, Task>, Func<IDictionary<string, string[]>, Task>, Func<string, Task>?) Executes async side-effect actions based on the result state with separate handlers for different failure types. public static Task SwitchAsync(this Result result, Func<Task> onSuccess, Func<string, Task> onError, Func<string, Task> onSecurityException, Func<IDictionary<string, string[]>, Task> onValidationException, Func<string, Task>? onOperationCanceledException = null) Parameters result Result The result to perform switching on. onSuccess Func<Task> Async action to execute if the result is successful. onError Func<string, Task> Async action to execute if the result is a general error. Receives the error message. onSecurityException Func<string, Task> Async action to execute if the result is a security failure. Receives the error message. onValidationException Func<IDictionary<string, string[]>, Task> Async action to execute if the result is a validation failure. Receives the validation errors dictionary. onOperationCanceledException Func<string, Task> Optional async action to execute if the result is a cancellation failure. Receives the error message. If null, cancellation failures are ignored. Returns Task A System.Threading.Tasks.Task representing the async operation. Examples Result result = await ProcessRequestAsync(); await result.SwitchAsync( onSuccess: async () => await SendSuccessNotificationAsync(), onError: async error => await LogSystemErrorAsync(error), onSecurityException: async error => await AlertSecurityTeamAsync(error), onValidationException: async errors => await DisplayValidationErrorsAsync(errors), onOperationCanceledException: async error => await CleanupResourcesAsync() ); Exceptions ArgumentNullException Thrown when result, onSuccess, onError, onSecurityException, or onValidationException is null. SwitchAsync<T>(Result<T>, Func<T, Task>, Func<string, Task>, bool) Executes async side-effect actions based on the result state. public static Task SwitchAsync<T>(this Result<T> result, Func<T, Task> onSuccess, Func<string, Task> onFailure, bool includeOperationCancelledFailures = false) Parameters result Result<T> The result to perform switching on. onSuccess Func<T, Task> Async action to execute if the result is successful. Receives the success value. onFailure Func<string, Task> Async action to execute if the result is a failure. Receives the error message. includeOperationCancelledFailures bool Whether to execute onFailure for OperationCanceled failures. Defaults to false. Returns Task A System.Threading.Tasks.Task representing the async operation. Type Parameters T The type of the success value in the result. Examples Result<User> userResult = await GetUserAsync(userId); await userResult.SwitchAsync( onSuccess: async user => { await LogUserAccessAsync(user); await UpdateLastLoginAsync(user); }, onFailure: async error => { await LogFailedLoginAsync(userId, error); await IncrementFailedLoginCountAsync(userId); } ); Exceptions ArgumentNullException Thrown when result, onSuccess, or onFailure is null. SwitchAsync<T>(Result<T>, Func<T, Task>, Func<string, Task>, Func<string, Task>, Func<IDictionary<string, string[]>, Task>, Func<string, Task>?) Executes async side-effect actions based on the result state with separate handlers for different failure types. public static Task SwitchAsync<T>(this Result<T> result, Func<T, Task> onSuccess, Func<string, Task> onError, Func<string, Task> onSecurityException, Func<IDictionary<string, string[]>, Task> onValidationException, Func<string, Task>? onOperationCanceledException = null) Parameters result Result<T> The result to perform switching on. onSuccess Func<T, Task> Async action to execute if the result is successful. Receives the success value. onError Func<string, Task> Async action to execute if the result is a general error. Receives the error message. onSecurityException Func<string, Task> Async action to execute if the result is a security failure. Receives the error message. onValidationException Func<IDictionary<string, string[]>, Task> Async action to execute if the result is a validation failure. Receives the validation errors dictionary. onOperationCanceledException Func<string, Task> Optional async action to execute if the result is a cancellation failure. Receives the error message. If null, cancellation failures are ignored. Returns Task A System.Threading.Tasks.Task representing the async operation. Type Parameters T The type of the success value in the result. Exceptions ArgumentNullException Thrown when result, onSuccess, onError, onSecurityException, or onValidationException is null. ThenAsync(Result, Func<Task<Result>>) Chains an async operation that returns a Result to be executed only if this result is successful. public static Task<Result> ThenAsync(this Result result, Func<Task<Result>> nextAsync) Parameters result Result The result to chain from. nextAsync Func<Task<Result>> The async function to execute if this result is successful. Returns Task<Result> A System.Threading.Tasks.Task<TResult> that contains the result of nextAsync if this result is successful, or the failure information from this result if it failed. Examples Result result = await ValidateInputAsync(); Result finalResult = await result.ThenAsync(async () => await ProcessValidatedInputAsync() ); Exceptions ArgumentNullException Thrown when result or nextAsync is null. ThenAsync<T>(Result, Func<Task<Result<T>>>) Chains an async operation that returns a Result<T> to be executed only if this result is successful. public static Task<Result<T>> ThenAsync<T>(this Result result, Func<Task<Result<T>>> nextAsync) Parameters result Result The result to chain from. nextAsync Func<Task<Result<T>>> The async function to execute if this result is successful. Returns Task<Result<T>> A System.Threading.Tasks.Task<TResult> that contains the result of nextAsync if this result is successful, or the failure information from this result if it failed. Type Parameters T The type of the result returned by the next operation. Examples Result result = await ValidateInputAsync(); Result<User> userResult = await result.ThenAsync(async () => await CreateUserAsync(validatedInput) ); Remarks This method enables async operation chaining while preserving the Result pattern semantics. If the current result is a failure, the next operation is not executed and the failure is propagated. Exceptions ArgumentNullException Thrown when result or nextAsync is null. ThenAsync<T>(Result<T>, Func<T, Task<Result>>) Chains an async operation that returns a Result to be executed only if this result is successful. public static Task<Result> ThenAsync<T>(this Result<T> result, Func<T, Task<Result>> nextAsync) Parameters result Result<T> The result to chain from. nextAsync Func<T, Task<Result>> The async function to execute if this result is successful. Receives the success value. Returns Task<Result> A System.Threading.Tasks.Task<TResult> that contains the result of nextAsync if this result is successful, or the failure information from this result if it failed. Type Parameters T The type of the success value in the current result. Examples Result<User> userResult = await GetUserAsync(); Result finalResult = await userResult.ThenAsync(async user => await ValidateAndSaveUserAsync(user) ); Exceptions ArgumentNullException Thrown when result or nextAsync is null. ThenAsync<T, TNext>(Result<T>, Func<T, Task<Result<TNext>>>) Chains an async operation that returns a Result<TNext> to be executed only if this result is successful. public static Task<Result<TNext>> ThenAsync<T, TNext>(this Result<T> result, Func<T, Task<Result<TNext>>> nextAsync) Parameters result Result<T> The result to chain from. nextAsync Func<T, Task<Result<TNext>>> The async function to execute if this result is successful. Receives the success value. Returns Task<Result<TNext>> A System.Threading.Tasks.Task<TResult> that contains the result of nextAsync if this result is successful, or the failure information from this result if it failed. Type Parameters T The type of the success value in the current result. TNext The type of the result returned by the next operation. Examples Result<User> userResult = await GetUserAsync(); Result<Order> orderResult = await userResult.ThenAsync(async user => await CreateOrderForUserAsync(user) ); Exceptions ArgumentNullException Thrown when result or nextAsync is null."
  },
  "api/FlowRight.Core.Extensions.html": {
    "href": "api/FlowRight.Core.Extensions.html",
    "title": "Namespace FlowRight.Core.Extensions | FlowRight - Result Pattern Library for .NET",
    "summary": "Namespace FlowRight.Core.Extensions Classes ResultAsyncExtensions Provides async-friendly extension methods for the Result and Result<T> types, enabling seamless composition of asynchronous operations with the Result pattern."
  },
  "api/FlowRight.Core.Results.IResult-1.html": {
    "href": "api/FlowRight.Core.Results.IResult-1.html",
    "title": "Interface IResult<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Interface IResult<T> Namespace FlowRight.Core.Results Assembly FlowRight.Core.dll Represents a Result pattern implementation that can contain a typed success value, providing pattern matching and functional programming capabilities. public interface IResult<out T> : IResult, IResultError<string> Type Parameters T The type of the success value that this result can contain. Inherited Members IResult.Failures IResult.FailureType IResult.IsFailure IResult.IsSuccess IResult.ResultType IResultError<string>.Error Examples // Example of using IResult<T> with pattern matching IResult<User> result = GetUser(userId); string message = result.Match( onSuccess: user => $\"Welcome, {user.Name}!\", onFailure: error => $\"Error: {error}\" ); // Example with detailed failure handling result.Switch( onSuccess: user => Console.WriteLine($\"User loaded: {user.Name}\"), onError: error => LogError(error), onSecurityException: error => LogSecurityViolation(error), onValidationException: errors => LogValidationErrors(errors) ); Remarks This interface extends IResult to add typed success value handling and provides pattern matching methods for functional-style result processing. The interface is covariant, allowing assignment from more derived types to less derived types. The interface provides two styles of result handling: Match methods: Functional style that transforms the result into another value Switch methods: Imperative style that executes side-effect actions Methods Match<TResult>(Func<T, TResult>, Func<string, TResult>) Provides pattern matching for the result, executing one of two functions based on success or failure state. TResult Match<TResult>(Func<out T, TResult> onSuccess, Func<string, TResult> onFailure) Parameters onSuccess Func<T, TResult> Function to execute if the result is successful, receiving the success value. onFailure Func<string, TResult> Function to execute if the result is a failure, receiving the error message. Returns TResult The value returned by either onSuccess or onFailure depending on the result state. Type Parameters TResult The type of value returned by both success and failure handlers. Examples Result<int> result = GetNumber(); string message = result.Match( onSuccess: value => $\"The number is {value}\", onFailure: error => $\"Failed: {error}\" ); Exceptions ArgumentNullException Thrown when onSuccess or onFailure is null. Match<TResult>(Func<T, TResult>, Func<string, TResult>, Func<string, TResult>, Func<IDictionary<string, string[]>, TResult>, Func<string, TResult>) Provides comprehensive pattern matching for the result with separate handlers for different failure types. TResult Match<TResult>(Func<out T, TResult> onSuccess, Func<string, TResult> onError, Func<string, TResult> onSecurityException, Func<IDictionary<string, string[]>, TResult> onValidationException, Func<string, TResult> onOperationCanceledException) Parameters onSuccess Func<T, TResult> Function to execute for successful results, receiving the success value. onError Func<string, TResult> Function to execute for general error failures, receiving the error message. onSecurityException Func<string, TResult> Function to execute for security-related failures, receiving the error message. onValidationException Func<IDictionary<string, string[]>, TResult> Function to execute for validation failures, receiving the validation error dictionary. onOperationCanceledException Func<string, TResult> Function to execute for operation canceled failures, receiving the error message. Returns TResult The value returned by the appropriate handler based on the result state and failure type. Type Parameters TResult The type of value returned by all handlers. Examples Result<User> result = AuthenticateUser(credentials); string response = result.Match( onSuccess: user => $\"Welcome {user.Name}\", onError: error => $\"System error: {error}\", onSecurityException: error => \"Access denied\", onValidationException: errors => $\"Validation failed: {errors.Count} errors\", onOperationCanceledException: error => \"Operation was cancelled\" ); Exceptions ArgumentNullException Thrown when any of the required handler parameters is null. Switch(Action<T>, Action<string>, Action<string>, Action<IDictionary<string, string[]>>, Action<string>?) Executes side-effect actions based on the result state with separate handlers for different failure types. void Switch(Action<out T> onSuccess, Action<string> onError, Action<string> onSecurityException, Action<IDictionary<string, string[]>> onValidationException, Action<string>? onOperationCanceledException = null) Parameters onSuccess Action<T> Action to execute for successful results, receiving the success value. onError Action<string> Action to execute for general error failures, receiving the error message. onSecurityException Action<string> Action to execute for security-related failures, receiving the error message. onValidationException Action<IDictionary<string, string[]>> Action to execute for validation failures, receiving the validation error dictionary. onOperationCanceledException Action<string> Optional action to execute for operation canceled failures, receiving the error message. If null, operation canceled failures are ignored. Examples Result<Order> result = ProcessOrder(orderData); result.Switch( onSuccess: order => SendConfirmationEmail(order), onError: error => LogSystemError(error), onSecurityException: error => AlertSecurityTeam(error), onValidationException: errors => ShowValidationErrors(errors), onOperationCanceledException: error => NotifyUserOfCancellation(error) ); Exceptions ArgumentNullException Thrown when any of the required action parameters is null. Switch(Action<T>, Action<string>, bool) Executes side-effect actions based on the result state, with simple success/failure handling. void Switch(Action<out T> onSuccess, Action<string> onFailure, bool includeOperationCancelledFailures = false) Parameters onSuccess Action<T> Action to execute if the result is successful, receiving the success value. onFailure Action<string> Action to execute if the result is a failure, receiving the error message. includeOperationCancelledFailures bool true to execute onFailure for operation canceled failures; false to ignore operation canceled failures. Default is false. Examples Result<Data> result = ProcessData(); result.Switch( onSuccess: data => SaveToDatabase(data), onFailure: error => LogError(error) ); Exceptions ArgumentNullException Thrown when onSuccess or onFailure is null."
  },
  "api/FlowRight.Core.Results.IResult.html": {
    "href": "api/FlowRight.Core.Results.IResult.html",
    "title": "Interface IResult | FlowRight - Result Pattern Library for .NET",
    "summary": "Interface IResult Namespace FlowRight.Core.Results Assembly FlowRight.Core.dll Represents the basic contract for Result pattern implementations, providing access to success/failure state and error information without exposing the success value. public interface IResult Remarks This interface defines the core properties that all Result types must implement, including failure tracking, success/failure state, and categorization of different failure types. Properties FailureType Gets the specific type of failure that occurred, providing detailed categorization of different error scenarios. ResultFailureType FailureType { get; } Property Value ResultFailureType A ResultFailureType value indicating the specific type of failure, or None for successful results. Failures Gets a dictionary of validation failures, where each key represents a field name and each value represents an array of error messages for that field. IDictionary<string, string[]> Failures { get; } Property Value IDictionary<string, string[]> An System.Collections.Generic.IDictionary<TKey, TValue> containing field-specific error messages. Returns an empty dictionary for successful results or non-validation failures. IsFailure Gets a value indicating whether the result represents a failure state. bool IsFailure { get; } Property Value bool true if the result represents a failure; otherwise, false. This property is always the logical inverse of IsSuccess. IsSuccess Gets a value indicating whether the result represents a successful state. bool IsSuccess { get; } Property Value bool true if the result represents success; otherwise, false. This property is always the logical inverse of IsFailure. ResultType Gets the general category of the result, providing high-level classification of success, informational, warning, or error states. ResultType ResultType { get; } Property Value ResultType A ResultType value indicating the general result category."
  },
  "api/FlowRight.Core.Results.IResultError-1.html": {
    "href": "api/FlowRight.Core.Results.IResultError-1.html",
    "title": "Interface IResultError<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Interface IResultError<T> Namespace FlowRight.Core.Results Assembly FlowRight.Core.dll Provides access to error messages from result operations, supporting covariant access to error information. public interface IResultError<out T> Type Parameters T The type of error message or information provided by the result. Remarks This interface is covariant, allowing assignment from more specific error types to more general ones. In a Result pattern library, \"Error\" is the most appropriate and intuitive property name for accessing error information, despite analyzer warnings about keyword conflicts in other .NET languages. Properties Error Gets the error message or information associated with a failed result. T Error { get; } Property Value T The error message or information for failed results, or a default/empty value for successful results. The specific type and content depend on the implementing result type."
  },
  "api/FlowRight.Core.Results.Result-1.html": {
    "href": "api/FlowRight.Core.Results.Result-1.html",
    "title": "Class Result<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class Result<T> Namespace FlowRight.Core.Results Assembly FlowRight.Core.dll Provides a generic Result implementation that represents the outcome of operations that return a typed value, supporting both success and failure states with comprehensive error handling. public class Result<T> : IResult<T>, IResult, IResultError<string> Type Parameters T The type of the success value that this result can contain. Inheritance object Result<T> Implements IResult<T> IResult IResultError<string> Extension Methods ResultAsyncExtensions.MapAsync<T, TResult>(Result<T>, Func<T, Task<TResult>>) ResultAsyncExtensions.MatchAsync<T, TResult>(Result<T>, Func<T, Task<TResult>>, Func<string, Task<TResult>>) ResultAsyncExtensions.MatchAsync<T, TResult>(Result<T>, Func<T, Task<TResult>>, Func<string, Task<TResult>>, Func<string, Task<TResult>>, Func<IDictionary<string, string[]>, Task<TResult>>, Func<string, Task<TResult>>) ResultAsyncExtensions.SwitchAsync<T>(Result<T>, Func<T, Task>, Func<string, Task>, bool) ResultAsyncExtensions.SwitchAsync<T>(Result<T>, Func<T, Task>, Func<string, Task>, Func<string, Task>, Func<IDictionary<string, string[]>, Task>, Func<string, Task>?) ResultAsyncExtensions.ThenAsync<T>(Result<T>, Func<T, Task<Result>>) ResultAsyncExtensions.ThenAsync<T, TNext>(Result<T>, Func<T, Task<Result<TNext>>>) Examples // Creating success results Result<User> userResult = Result.Success(user); Result<int> numberResult = Result.Success(42, ResultType.Information); // Creating failure results Result<User> failedResult = Result.Failure<User>(\"User not found\"); Result<Order> validationResult = Result.ValidationFailure<Order>(validationErrors); // Pattern matching string message = userResult.Match( onSuccess: user => $\"Welcome, {user.Name}!\", onFailure: error => $\"Login failed: {error}\" ); // Imperative handling userResult.Switch( onSuccess: user => RedirectToHome(user), onFailure: error => ShowErrorMessage(error) ); Remarks This class implements the Result pattern for operations that return a specific value type. It provides the same comprehensive error tracking and categorization as the non-generic Result class, while also safely encapsulating the success value. The Result<T> class supports pattern matching through both functional (Match<TResult>(Func<T, TResult>, Func<string, TResult>)) and imperative (Switch(Action<T>, Action<string>, bool)) APIs, enabling both functional programming and traditional procedural approaches. The class is designed to be immutable after construction and provides full JSON serialization support for both success values and error information. Properties Error Gets the error message associated with this result. [JsonInclude] public string Error { get; } Property Value string A string containing the error message for failed results, or an empty string for successful results. For validation failures, this contains a formatted summary of all validation errors. Remarks This property implements Error and provides the primary error message for the result. The content varies by failure type: Success: Empty string General errors: The specific error message Validation errors: Formatted summary of all field errors Security errors: Security exception message Cancellation: Operation canceled message FailureType Gets the specific type of failure that occurred. [JsonInclude] public ResultFailureType FailureType { get; } Property Value ResultFailureType A ResultFailureType value indicating the specific category of failure, or None for successful results. Remarks This property enables consumers to implement different handling strategies based on the type of failure. For example, validation failures might be displayed to users while security failures might be logged and result in access denial. Failures Gets a dictionary of field-specific validation failures. [JsonInclude] public IDictionary<string, string[]> Failures { get; } Property Value IDictionary<string, string[]> An System.Collections.Generic.IDictionary<TKey, TValue> where keys represent field names and values represent arrays of error messages for each field. Empty for non-validation failures. Remarks This property provides detailed field-level error information for validation failures. It allows consumers to display specific error messages for individual form fields or properties. For non-validation failures, this dictionary is empty. IsFailure Gets a value indicating whether this result represents a failure state. public bool IsFailure { get; } Property Value bool true if the result represents a failure; otherwise, false. Remarks This property is determined by checking if an error message is present. It is always the logical inverse of IsSuccess. IsSuccess Gets a value indicating whether this result represents a successful state. public bool IsSuccess { get; } Property Value bool true if the result represents success; otherwise, false. Remarks This property is determined by checking if no error message is present. It is always the logical inverse of IsFailure. ResultType Gets the general category of this result. [JsonInclude] public ResultType ResultType { get; } Property Value ResultType A ResultType value indicating the overall result category. Remarks This property provides high-level categorization that complements the more specific FailureType. It allows for broad categorization of results into success, informational, warning, or error states. Methods Match<TResult>(Func<T, TResult>, Func<string, TResult>) Transforms this result into a value of type TResult using pattern matching. public TResult Match<TResult>(Func<T, TResult> onSuccess, Func<string, TResult> onFailure) Parameters onSuccess Func<T, TResult> Function to execute if the result is successful. Receives the success value. onFailure Func<string, TResult> Function to execute if the result is a failure. Receives the error message. Returns TResult The value returned by either onSuccess or onFailure. Type Parameters TResult The type of the result to return. Examples Result<User> userResult = GetUser(userId); string message = userResult.Match( onSuccess: user => $\"Welcome, {user.Name}!\", onFailure: error => $\"Failed to load user: {error}\" ); Console.WriteLine(message); Remarks This is the primary pattern matching method for Result<T>. It provides a functional approach to handling both success and failure cases by requiring explicit handling of both scenarios. This method treats all failure types (Error, Security, Validation, OperationCanceled) uniformly, calling onFailure with the error message. For more granular failure handling, use the overload that provides separate handlers for each failure type. Exceptions ArgumentNullException Thrown when onSuccess or onFailure is null. Match<TResult>(Func<T, TResult>, Func<string, TResult>, Func<string, TResult>, Func<IDictionary<string, string[]>, TResult>, Func<string, TResult>) Transforms this result into a value of type TResult using pattern matching with specific handlers for each failure type. public TResult Match<TResult>(Func<T, TResult> onSuccess, Func<string, TResult> onError, Func<string, TResult> onSecurityException, Func<IDictionary<string, string[]>, TResult> onValidationException, Func<string, TResult> onOperationCanceledException) Parameters onSuccess Func<T, TResult> Function to execute if the result is successful. Receives the success value. onError Func<string, TResult> Function to execute if the result is a general error. Receives the error message. onSecurityException Func<string, TResult> Function to execute if the result is a security failure. Receives the error message. onValidationException Func<IDictionary<string, string[]>, TResult> Function to execute if the result is a validation failure. Receives the validation errors dictionary. onOperationCanceledException Func<string, TResult> Function to execute if the result is a cancellation failure. Receives the error message. Returns TResult The value returned by the appropriate handler function. Type Parameters TResult The type of the result to return. Examples Result<User> userResult = CreateUser(request); IActionResult response = userResult.Match( onSuccess: user => Ok(user), onError: error => StatusCode(500, error), onSecurityException: error => Unauthorized(error), onValidationException: errors => BadRequest(errors), onOperationCanceledException: error => StatusCode(408, \"Request timeout\") ); Remarks This overload of Match provides granular control over different failure types, allowing you to implement specific logic for each category of failure. This is particularly useful when different failure types require different handling strategies. The method routes failures to the appropriate handler based on FailureType: Error → onError Security → onSecurityException Validation → onValidationException OperationCanceled → onOperationCanceledException Exceptions ArgumentNullException Thrown when any of the handler functions is null. Switch(Action<T>, Action<string>, Action<string>, Action<IDictionary<string, string[]>>, Action<string>?) Executes an action based on the result state using imperative pattern matching with specific handlers for each failure type. public void Switch(Action<T> onSuccess, Action<string> onError, Action<string> onSecurityException, Action<IDictionary<string, string[]>> onValidationException, Action<string>? onOperationCanceledException = null) Parameters onSuccess Action<T> Action to execute if the result is successful. Receives the success value. onError Action<string> Action to execute if the result is a general error. Receives the error message. onSecurityException Action<string> Action to execute if the result is a security failure. Receives the error message. onValidationException Action<IDictionary<string, string[]>> Action to execute if the result is a validation failure. Receives the validation errors dictionary. onOperationCanceledException Action<string> Optional action to execute if the result is a cancellation failure. Receives the error message. If null, cancellation failures are ignored. Examples Result<Order> orderResult = ProcessOrder(request); orderResult.Switch( onSuccess: order => { logger.LogInformation(\"Order {OrderId} processed successfully\", order.Id); emailService.SendOrderConfirmation(order); }, onError: error => { logger.LogError(\"Order processing failed: {Error}\", error); alertService.NotifySystemError(error); }, onSecurityException: error => { logger.LogWarning(\"Security violation during order processing: {Error}\", error); auditService.LogSecurityEvent(error); }, onValidationException: errors => { logger.LogInformation(\"Order validation failed: {ErrorCount} errors\", errors.Count); // Validation errors are expected, no alerting needed }, onOperationCanceledException: error => { logger.LogInformation(\"Order processing was cancelled: {Error}\", error); } ); Remarks This overload of Switch provides granular control over different failure types using imperative actions, allowing you to implement specific side effects for each category of failure. This is particularly useful when different failure types require different handling strategies (logging, notifications, etc.). The method routes failures to the appropriate handler based on FailureType: Error → onError Security → onSecurityException Validation → onValidationException OperationCanceled → onOperationCanceledException (if provided) The onOperationCanceledException parameter is optional because cancellation often represents normal flow control rather than an error condition that requires specific handling. Exceptions ArgumentNullException Thrown when onSuccess, onError, onSecurityException, or onValidationException is null. Switch(Action<T>, Action<string>, bool) Executes an action based on the result state using imperative pattern matching. public void Switch(Action<T> onSuccess, Action<string> onFailure, bool includeOperationCancelledFailures = false) Parameters onSuccess Action<T> Action to execute if the result is successful. Receives the success value. onFailure Action<string> Action to execute if the result is a failure. Receives the error message. includeOperationCancelledFailures bool Whether to execute onFailure for OperationCanceled failures. Defaults to false. Examples Result<User> userResult = GetUser(userId); userResult.Switch( onSuccess: user => { Console.WriteLine($\"Welcome, {user.Name}!\"); LogUserLogin(user.Id); }, onFailure: error => { Console.WriteLine($\"Login failed: {error}\"); LogFailedLogin(userId); } ); Remarks This is the primary imperative pattern matching method for Result<T>. Unlike the functional Match<TResult>(Func<T, TResult>, Func<string, TResult>) method, this executes actions with side effects rather than returning transformed values. By default, OperationCanceled failures are ignored because cancellation often represents normal flow control rather than an error condition. Set includeOperationCancelledFailures to true if you need to handle cancellation scenarios. All other failure types (Error, Security, Validation) are handled uniformly by onFailure. For more granular failure handling, use the overload that provides separate handlers for each failure type. Exceptions ArgumentNullException Thrown when onSuccess or onFailure is null. TryGetValue(out T?) Attempts to retrieve the success value from this result. public bool TryGetValue(out T? value) Parameters value T When this method returns, contains the success value if the result is successful; otherwise, contains the default value for type T. Returns bool true if the result is successful and value contains the success value; otherwise, false. Examples Result<User> userResult = GetUser(userId); if (userResult.TryGetValue(out User user)) { // user is guaranteed to be non-null here Console.WriteLine($\"Found user: {user.Name}\"); } else { // Handle failure case Console.WriteLine($\"Failed to get user: {userResult.Error}\"); } Remarks This method provides a safe way to extract values from results using the standard .NET \"Try\" pattern, similar to System.Collections.Generic.Dictionary<TKey, TValue>.TryGetValue(TKey, out TValue) or int.TryParse(string, out int). The method uses the System.Diagnostics.CodeAnalysis.NotNullWhenAttribute attribute to help static analysis tools understand that value will not be null when the method returns true, even for nullable reference types. This is particularly useful when you need to conditionally access the success value without pattern matching, or when integrating with code that expects the \"Try\" pattern. Operators explicit operator bool(Result<T>) Explicitly converts a Result<T> to a boolean indicating success or failure. public static explicit operator bool(Result<T> result) Parameters result Result<T> The result to convert. Returns bool true if the result represents success; otherwise, false. Examples Result<string> result = GetMessage(); if ((bool)result) // Explicit conversion { Console.WriteLine(\"Operation succeeded!\"); } Remarks This explicit conversion provides a convenient way to use results in boolean contexts while making the conversion explicit to avoid accidental usage. explicit operator T(Result<T>) Explicitly converts a Result<T> to its underlying value. public static explicit operator T(Result<T> result) Parameters result Result<T> The result to extract the value from. Returns T The underlying value of the successful result. Examples Result<int> result = GetNumber(); if (result.IsSuccess) { int value = (int)result; // Explicit conversion Console.WriteLine($\"The number is {value}\"); } Remarks This explicit conversion provides a way to extract the value from a successful result. It will throw an exception if the result represents a failure, making it suitable for scenarios where you are certain the result is successful. For safer value extraction, consider using TryGetValue(out T?) or Match<TResult>(Func<T, TResult>, Func<string, TResult>) instead. Exceptions InvalidOperationException Thrown when the result represents a failure state. implicit operator Result(Result<T>) Implicitly converts a Result<T> to a non-generic Result. public static implicit operator Result(Result<T> result) Parameters result Result<T> The generic result to convert. Returns Result A non-generic Result that preserves the success/failure state and error information. Examples Result<User> userResult = GetUser(); Result result = userResult; // Implicit conversion if (result.IsSuccess) { // Success state is preserved, but value is not available } Remarks This implicit conversion allows a Result<T> to be used anywhere a Result is expected, providing seamless interoperability between generic and non-generic result types. The conversion preserves all error information including failure type, error messages, and validation details. For successful results, only the success state is preserved (the value is discarded). implicit operator Result<T>(T) Implicitly converts a value of type T to a successful Result<T>. public static implicit operator Result<T>(T value) Parameters value T The value to wrap in a successful result. Returns Result<T> A successful Result<T> containing the specified value. Examples public Result<string> GetMessage() { return \"Hello, World!\"; // Implicit conversion from string } public Result<int> Calculate() { return 42; // Implicit conversion from int } Remarks This implicit conversion provides a convenient way to create successful results without explicitly calling Success<T>(T, ResultType). It simplifies code when working with methods that return Result<T>. If the value is already a IResult<T>, this conversion will extract the result information and create an appropriate Result<T> preserving the original result's success/failure state."
  },
  "api/FlowRight.Core.Results.Result.html": {
    "href": "api/FlowRight.Core.Results.Result.html",
    "title": "Class Result | FlowRight - Result Pattern Library for .NET",
    "summary": "Class Result Namespace FlowRight.Core.Results Assembly FlowRight.Core.dll Provides a non-generic Result implementation that represents the outcome of operations that don't return a value, supporting both success and failure states with detailed error information. public class Result : IResult Inheritance object Result Implements IResult Extension Methods ResultAsyncExtensions.MatchAsync<TResult>(Result, Func<Task<TResult>>, Func<string, Task<TResult>>) ResultAsyncExtensions.MatchAsync<TResult>(Result, Func<Task<TResult>>, Func<string, Task<TResult>>, Func<string, Task<TResult>>, Func<IDictionary<string, string[]>, Task<TResult>>, Func<string, Task<TResult>>) ResultAsyncExtensions.SwitchAsync(Result, Func<Task>, Func<string, Task>, bool) ResultAsyncExtensions.SwitchAsync(Result, Func<Task>, Func<string, Task>, Func<string, Task>, Func<IDictionary<string, string[]>, Task>, Func<string, Task>?) ResultAsyncExtensions.ThenAsync(Result, Func<Task<Result>>) ResultAsyncExtensions.ThenAsync<T>(Result, Func<Task<Result<T>>>) Examples // Creating success results Result successResult = Result.Success(); Result infoResult = Result.Success(ResultType.Information); // Creating failure results Result errorResult = Result.Failure(\"Operation failed\"); Result validationResult = Result.ValidationFailure(validationErrors); Result securityResult = Result.SecurityFailure(\"Access denied\"); // Pattern matching with results string message = result.Match( onSuccess: () => \"Operation completed successfully\", onFailure: error => $\"Operation failed: {error}\" ); Remarks This class implements the Result pattern for operations that perform actions but don't return a specific value (similar to void methods). It provides comprehensive error tracking, categorization of different failure types, and full JSON serialization support. The Result class is designed to be immutable after construction and supports both simple success/failure scenarios and complex error handling with validation failures, security exceptions, and operation cancellation. Properties Error Gets the error message associated with this result. [JsonInclude] public string Error { get; } Property Value string A string containing the error message for failed results, or an empty string for successful results. For validation failures, this contains a formatted summary of all validation errors. Remarks This property implements Error and provides the primary error message for the result. The content varies by failure type: Success: Empty string General errors: The specific error message Validation errors: Formatted summary of all field errors Security errors: Security exception message Cancellation: Operation canceled message FailureType Gets the specific type of failure that occurred. [JsonInclude] public ResultFailureType FailureType { get; } Property Value ResultFailureType A ResultFailureType value indicating the specific category of failure, or None for successful results. Remarks This property enables consumers to implement different handling strategies based on the type of failure. For example, validation failures might be displayed to users while security failures might be logged and result in access denial. Failures Gets a dictionary of field-specific validation failures. [JsonInclude] public IDictionary<string, string[]> Failures { get; } Property Value IDictionary<string, string[]> An System.Collections.Generic.IDictionary<TKey, TValue> where keys represent field names and values represent arrays of error messages for each field. Empty for non-validation failures. Remarks This property provides detailed field-level error information for validation failures. It allows consumers to display specific error messages for individual form fields or properties. For non-validation failures, this dictionary is empty. IsFailure Gets a value indicating whether this result represents a failure state. public bool IsFailure { get; } Property Value bool true if the result represents a failure; otherwise, false. Remarks This property is determined by checking if an error message is present. It is always the logical inverse of IsSuccess. IsSuccess Gets a value indicating whether this result represents a successful state. public bool IsSuccess { get; } Property Value bool true if the result represents success; otherwise, false. Remarks This property is determined by checking if no error message is present. It is always the logical inverse of IsFailure. ResultType Gets the general category of this result. [JsonInclude] public ResultType ResultType { get; } Property Value ResultType A ResultType value indicating the overall result category. Remarks This property provides high-level categorization that complements the more specific FailureType. It allows for broad categorization of results into success, informational, warning, or error states. Methods Combine(params Result[]) Combines multiple Result instances into a single Result, aggregating all failure information and returning success only if all input results are successful. public static Result Combine(params Result[] results) Parameters results Result[] The array of Result instances to combine. Returns Result A Result that is successful if all input results are successful, or a failure result containing aggregated error information from all failed results. Examples Result[] operations = [ ValidateUser(user), ValidatePermissions(user), ValidateData(data) ]; Result combinedResult = Result.Combine(operations); if (combinedResult.IsFailure) { // Handle all collected errors at once LogErrors(combinedResult.Failures); } Remarks This method provides a way to aggregate multiple operation results into a single result. It's particularly useful for batch operations where you want to collect all errors rather than failing on the first error encountered. The combining logic preserves error categorization: Validation errors are merged by field name Other error types are grouped by failure type Multiple errors of the same type are collected together Exceptions ArgumentNullException Thrown when results is null. Combine<T>(params Result<T>[]) Combines multiple Result{T} instances into a single Result{T}, aggregating all failure information and returning success only if all input results are successful. public static Result<T> Combine<T>(params Result<T>[] results) Parameters results Result<T>[] The array of Result{T} instances to combine. Returns Result<T> A Result<T> that is successful with the value from the first successful result if all input results are successful, or a failure result containing aggregated error information from all failed results. Type Parameters T The type of the success values in the results. Examples Result{User}[] operations = [ ValidateUser(user), ValidatePermissions(user), ValidateData(data) ]; Result{User} combinedResult = Result.Combine(operations); if (combinedResult.IsFailure) { // Handle all collected errors at once LogErrors(combinedResult.Failures); } Remarks This method provides a way to aggregate multiple operation results into a single result. It's particularly useful for batch operations where you want to collect all errors rather than failing on the first error encountered. The combining logic preserves error categorization: Validation errors are merged by field name Other error types are grouped by failure type Multiple errors of the same type are collected together If all results are successful, the returned result will contain the value from the first successful result. If you need to combine the actual values, use a different approach such as collecting the values after confirming all results are successful. Exceptions ArgumentNullException Thrown when results is null. Failure(IDictionary<string, string[]>) Creates a failed result with multiple validation errors. public static Result Failure(IDictionary<string, string[]> errors) Parameters errors IDictionary<string, string[]> A dictionary containing field names as keys and arrays of error messages as values. Cannot be null. Returns Result A failed Result instance with Validation containing all the validation errors. Examples Dictionary<string, string[]> validationErrors = new() { [\"Email\"] = [\"Email is required\", \"Email format is invalid\"], [\"Password\"] = [\"Password must be at least 8 characters\"], [\"Age\"] = [\"Age must be between 18 and 120\"] }; Result validationResult = Result.Failure(validationErrors); // Access specific field errors if (validationResult.Failures.TryGetValue(\"Email\", out string[] emailErrors)) { foreach (string error in emailErrors) { Console.WriteLine($\"Email error: {error}\"); } } Remarks This method creates a validation failure result containing multiple field errors. It's the primary method for creating comprehensive validation failures that can report errors on multiple fields simultaneously. The error dictionary structure allows for multiple error messages per field, which is useful for complex validation scenarios where a single field might fail multiple validation rules. Exceptions ArgumentNullException Thrown when errors is null. Failure(OperationCanceledException) Creates a failed result from an operation canceled exception. public static Result Failure(OperationCanceledException operationCanceledException) Parameters operationCanceledException OperationCanceledException The operation canceled exception that occurred. Cannot be null. Returns Result A failed Result instance with OperationCanceled containing the cancellation information. Examples async Task<Result> ProcessDataAsync(CancellationToken cancellationToken) { try { await LongRunningOperation(cancellationToken); return Result.Success(); } catch (OperationCanceledException ex) { return Result.Failure(ex); } } Remarks This method creates a cancellation failure result from an System.OperationCanceledException. The resulting failure will have a FailureType of OperationCanceled and a ResultType of Warning, as cancellation is typically not an error condition. Cancellation failures represent normal application flow control rather than actual errors and may be handled differently from other failure types (such as being filtered out of error logging). Exceptions ArgumentNullException Thrown when operationCanceledException is null. Failure(SecurityException) Creates a failed result from a security exception. public static Result Failure(SecurityException securityException) Parameters securityException SecurityException The security exception that occurred. Cannot be null. Returns Result A failed Result instance with Security containing the security error. Examples try { // Some operation that might throw SecurityException PerformSecuritySensitiveOperation(); return Result.Success(); } catch (SecurityException ex) { return Result.Failure(ex); } Remarks This method creates a security failure result from a System.Security.SecurityException. The resulting failure will have a FailureType of Security and should be handled with appropriate security considerations. Security failures typically require special handling such as audit logging, security monitoring integration, and careful error message sanitization to avoid information disclosure. Exceptions ArgumentNullException Thrown when securityException is null. Failure(string, ResultType, ResultFailureType) Creates a failed result with the specified error message and failure classification. public static Result Failure(string error, ResultType resultType = ResultType.Error, ResultFailureType resultFailureType = ResultFailureType.Error) Parameters error string The error message describing what went wrong. Cannot be null. resultType ResultType The general result type classification. Defaults to Error. resultFailureType ResultFailureType The specific failure type classification. Defaults to Error. Returns Result A failed Result instance containing the error information. Examples // Basic error Result result = Result.Failure(\"Database connection failed\"); // Business logic error Result businessError = Result.Failure( \"Insufficient inventory for order\", ResultType.Error, ResultFailureType.Error ); Remarks This is the primary method for creating general failure results. It allows full control over both the result type and failure type classifications, enabling precise error categorization. Use this method when you need to create custom failure scenarios that don't fit the specialized failure methods (validation, security, cancellation). Exceptions ArgumentNullException Thrown when error is null. Failure(string, string) Creates a failed result with a single field validation error. public static Result Failure(string key, string error) Parameters key string The name of the field or property that failed validation. Cannot be null. error string The validation error message for the specified field. Cannot be null. Returns Result A failed Result instance with Validation containing the field error. Examples // Single field validation error Result emailError = Result.Failure(\"Email\", \"Email address is required\"); // The error will be available in Failures dictionary if (emailError.FailureType == ResultFailureType.Validation) { string[] emailErrors = emailError.Failures[\"Email\"]; } Remarks This method creates a validation failure result for a single field. The resulting failure will have a FailureType of Validation and the field error will be available in the Failures dictionary. This is useful for simple validation scenarios where only one field needs to be validated or when building up validation errors one at a time. Exceptions ArgumentNullException Thrown when key or error is null. Failure<T>(IDictionary<string, string[]>) Creates a failed result with multiple validation errors for a generic result type. public static Result<T> Failure<T>(IDictionary<string, string[]> errors) Parameters errors IDictionary<string, string[]> A dictionary containing field names as keys and arrays of error messages as values. Cannot be null. Returns Result<T> A failed Result<T> instance with Validation containing all the validation errors. Type Parameters T The type parameter for the generic result. Examples Result<User> CreateUser(CreateUserRequest request) { Dictionary<string, string[]> validationErrors = ValidateUser(request); if (validationErrors.Any()) return Result.Failure<User>(validationErrors); User user = new User(request); return Result.Success(user); } Remarks This method creates a validation failure result containing multiple field errors for operations that would normally return a typed value. It's used when comprehensive validation results in multiple field-level errors. Exceptions ArgumentNullException Thrown when errors is null. Failure<T>(OperationCanceledException) Creates a failed result from an operation canceled exception for a generic result type. public static Result<T> Failure<T>(OperationCanceledException operationCanceledException) Parameters operationCanceledException OperationCanceledException The operation canceled exception that occurred. Cannot be null. Returns Result<T> A failed Result<T> instance with OperationCanceled containing the cancellation information. Type Parameters T The type parameter for the generic result. Examples async Task<Result<Data>> FetchDataAsync(CancellationToken cancellationToken) { try { Data data = await dataService.GetAsync(cancellationToken); return Result.Success(data); } catch (OperationCanceledException ex) { return Result.Failure<Data>(ex); } } Remarks This method creates a cancellation failure result from an System.OperationCanceledException for operations that would normally return a typed value. Cancellation represents normal flow control rather than an error condition. Exceptions ArgumentNullException Thrown when operationCanceledException is null. Failure<T>(SecurityException) Creates a failed result from a security exception for a generic result type. public static Result<T> Failure<T>(SecurityException securityException) Parameters securityException SecurityException The security exception that occurred. Cannot be null. Returns Result<T> A failed Result<T> instance with Security containing the security error. Type Parameters T The type parameter for the generic result. Examples Result<Document> GetSecureDocument(int documentId) { try { Document doc = secureRepository.GetDocument(documentId); return Result.Success(doc); } catch (SecurityException ex) { return Result.Failure<Document>(ex); } } Remarks This method creates a security failure result from a System.Security.SecurityException for operations that would normally return a typed value. Security failures require special handling and monitoring considerations. Exceptions ArgumentNullException Thrown when securityException is null. Failure<T>(string, ResultType, ResultFailureType) Creates a failed result with the specified error message and result type classification. public static Result<T> Failure<T>(string error, ResultType resultType = ResultType.Error, ResultFailureType resultFailureType = ResultFailureType.Error) Parameters error string The error message describing what went wrong. Cannot be null. resultType ResultType The general result type classification. Defaults to Error. resultFailureType ResultFailureType The specific failure type classification. Defaults to Error. Returns Result<T> A failed Result<T> instance containing the error information. Type Parameters T The type parameter for the generic result. Examples // Operation that would return a User Result<User> GetUserResult(int userId) { if (userId <= 0) return Result.Failure<User>(\"Invalid user ID\"); User user = userRepository.GetById(userId); return user != null ? Result.Success(user) : Result.Failure<User>(\"User not found\"); } Remarks This is the primary method for creating general failure results that would have returned a typed value. It allows full control over both the result type and failure type classifications. Use this method when you need to create custom failure scenarios for operations that normally return a specific type but have encountered an error condition. Exceptions ArgumentNullException Thrown when error is null. Failure<T>(string, string) Creates a failed result with a single field validation error for a generic result type. public static Result<T> Failure<T>(string key, string error) Parameters key string The name of the field or property that failed validation. Cannot be null. error string The validation error message for the specified field. Cannot be null. Returns Result<T> A failed Result<T> instance with Validation containing the field error. Type Parameters T The type parameter for the generic result. Examples Result<Order> CreateOrder(CreateOrderRequest request) { if (string.IsNullOrEmpty(request.CustomerEmail)) return Result.Failure<Order>(\"CustomerEmail\", \"Email is required\"); // Continue with order creation... } Remarks This method creates a validation failure result for a single field in the context of an operation that would normally return a typed value. The resulting failure will have a FailureType of Validation. Exceptions ArgumentNullException Thrown when key or error is null. Match<TResult>(Func<TResult>, Func<string, TResult>) Transforms this result into a value of type TResult using pattern matching. public TResult Match<TResult>(Func<TResult> onSuccess, Func<string, TResult> onFailure) Parameters onSuccess Func<TResult> Function to execute if the result is successful. Returns the success value. onFailure Func<string, TResult> Function to execute if the result is a failure. Receives the error message. Returns TResult The value returned by either onSuccess or onFailure. Type Parameters TResult The type of the result to return. Examples Result operationResult = PerformOperation(); string message = operationResult.Match( onSuccess: () => \"Operation completed successfully!\", onFailure: error => $\"Operation failed: {error}\" ); Console.WriteLine(message); Remarks This is the primary pattern matching method for non-generic Result. It provides a functional approach to handling both success and failure cases by requiring explicit handling of both scenarios. This method treats all failure types (Error, Security, Validation, OperationCanceled) uniformly, calling onFailure with the error message. For more granular failure handling, use the overload that provides separate handlers for each failure type. Exceptions ArgumentNullException Thrown when onSuccess or onFailure is null. Match<TResult>(Func<TResult>, Func<string, TResult>, Func<string, TResult>, Func<IDictionary<string, string[]>, TResult>, Func<string, TResult>) Transforms this result into a value of type TResult using pattern matching with specific handlers for each failure type. public TResult Match<TResult>(Func<TResult> onSuccess, Func<string, TResult> onError, Func<string, TResult> onSecurityException, Func<IDictionary<string, string[]>, TResult> onValidationException, Func<string, TResult> onOperationCanceledException) Parameters onSuccess Func<TResult> Function to execute if the result is successful. Returns the success value. onError Func<string, TResult> Function to execute if the result is a general error. Receives the error message. onSecurityException Func<string, TResult> Function to execute if the result is a security failure. Receives the error message. onValidationException Func<IDictionary<string, string[]>, TResult> Function to execute if the result is a validation failure. Receives the validation errors dictionary. onOperationCanceledException Func<string, TResult> Function to execute if the result is a cancellation failure. Receives the error message. Returns TResult The value returned by the appropriate handler function. Type Parameters TResult The type of the result to return. Examples Result operationResult = ProcessRequest(); string response = operationResult.Match( onSuccess: () => \"Success!\", onError: error => $\"Error: {error}\", onSecurityException: error => \"Access denied\", onValidationException: errors => $\"Validation failed: {errors.Count} errors\", onOperationCanceledException: error => \"Operation was cancelled\" ); Remarks This overload of Match provides granular control over different failure types, allowing you to implement specific logic for each category of failure. This is particularly useful when different failure types require different handling strategies. The method routes failures to the appropriate handler based on FailureType: Error → onError Security → onSecurityException Validation → onValidationException OperationCanceled → onOperationCanceledException Exceptions ArgumentNullException Thrown when any of the handler functions is null. NotFound(string?) Creates a failed result indicating that a resource was not found. public static Result NotFound(string? resource = null) Parameters resource string Optional description of the resource that was not found. If not provided, defaults to \"Not Found\". Returns Result A failed Result instance with NotFound. Examples // Generic not found error Result result = Result.NotFound(); // Specific resource not found Result userResult = Result.NotFound(\"User with ID 123\"); // Usage in a service method public Result DeleteUser(int userId) { User user = userRepository.GetById(userId); if (user == null) return Result.NotFound($\"User with ID {userId}\"); userRepository.Delete(user); return Result.Success(); } Remarks This method creates a \"not found\" failure result that corresponds to HTTP 404 status codes and similar scenarios where a requested resource does not exist. The resulting failure will have a FailureType of NotFound. Not found failures are distinct from general errors as they represent expected scenarios in many applications (e.g., searching for data that doesn't exist) and may be handled differently from actual system errors. NotFound<T>(string?) Creates a failed result indicating that a resource was not found for a generic result type. public static Result<T> NotFound<T>(string? resource = null) Parameters resource string Optional description of the resource that was not found. If not provided, defaults to \"Not Found\". Returns Result<T> A failed Result<T> instance with NotFound. Type Parameters T The type parameter for the generic result. Examples // Generic not found error Result<User> result = Result.NotFound<User>(); // Specific resource not found Result<Document> docResult = Result.NotFound<Document>(\"Document with ID ABC123\"); // Usage in a repository method public Result<User> GetUser(int userId) { User user = database.Users.FirstOrDefault(u => u.Id == userId); return user != null ? Result.Success(user) : Result.NotFound<User>($\"User with ID {userId}\"); } Remarks This method creates a \"not found\" failure result for operations that would normally return a typed value. The resulting failure will have a FailureType of NotFound, allowing consumers to distinguish between not found scenarios and actual errors. ServerError(string?) Creates a failed result indicating that a server error occurred. public static Result ServerError(string? message = null) Parameters message string Optional custom error message. If not provided, defaults to \"Server Error\". Returns Result A failed Result instance with ServerError. Examples // Generic server error Result result = Result.ServerError(); // Specific server error Result dbResult = Result.ServerError(\"Database connection timeout\"); // Usage in a service method public Result ProcessRequest() { try { // Process request return Result.Success(); } catch (TimeoutException) { return Result.ServerError(\"Request timed out\"); } } Remarks This method creates a server error failure result that corresponds to HTTP 5xx status codes and similar scenarios where a server-side error has occurred. The resulting failure will have a FailureType of ServerError. Server errors represent temporary failures on the server side that may be resolved with retry mechanisms, circuit breakers, or service recovery. They are distinct from client errors and may be handled differently (e.g., with retry logic). ServerError<T>(string?) Creates a failed result indicating that a server error occurred for a generic result type. public static Result<T> ServerError<T>(string? message = null) Parameters message string Optional custom error message. If not provided, defaults to \"Server Error\". Returns Result<T> A failed Result<T> instance with ServerError. Type Parameters T The type parameter for the generic result. Examples // Generic server error Result<User> result = Result.ServerError<User>(); // Specific server error Result<Data> dataResult = Result.ServerError<Data>(\"Service unavailable\"); // Usage in a service method public Result<User> GetUser(int userId) { try { User user = userService.GetById(userId); return Result.Success(user); } catch (ServiceUnavailableException ex) { return Result.ServerError<User>(ex.Message); } } Remarks This method creates a server error failure result for operations that would normally return a typed value. The resulting failure will have a FailureType of ServerError, allowing consumers to distinguish between server errors and client errors for appropriate retry strategies. Success(ResultType) Creates a successful result without a value. public static Result Success(ResultType resultType = ResultType.Success) Parameters resultType ResultType The type classification for this successful result. Defaults to Success. Returns Result A successful Result instance. Examples // Basic success Result result = Result.Success(); // Success with additional classification Result infoResult = Result.Success(ResultType.Information); Result warningResult = Result.Success(ResultType.Warning); Remarks This method creates a non-generic result that represents a successful operation that doesn't return a specific value (similar to a void method that completed successfully). Common usage scenarios include: Operations that modify state but don't return data Validation operations that either pass or fail Delete or update operations SuccessOrNull<T>(T?, ResultType) Creates a successful result containing the specified value, allowing null values without throwing exceptions. public static Result<T?> SuccessOrNull<T>(T? value, ResultType resultType = ResultType.Success) Parameters value T The value to wrap in the result. Can be null. resultType ResultType The type classification for this successful result. Defaults to Success. Returns Result<T> A successful Result<T> instance containing the specified value, including null values. Type Parameters T The type of the success value. Examples // Create successful result with null value - no exception thrown Result<string?> nullResult = Result.SuccessOrNull<string>(null); // Create successful result with non-null value Result<string?> valueResult = Result.SuccessOrNull(\"Hello World\"); // Success with additional context Result<User?> userResult = Result.SuccessOrNull(user, ResultType.Information); // Pattern matching usage string displayMessage = userResult.Match( onSuccess: user => user != null ? $\"Welcome, {user.Name}!\" : \"No user found\", onFailure: error => $\"Error: {error}\" ); Remarks This method creates successful results that can contain null values without throwing exceptions, unlike the standard Success<T>(T, ResultType) method. This is particularly useful when deserializing JSON or handling API responses that may legitimately return null values. The result type parameter allows for additional classification of successful operations: Success - Standard successful operation Information - Success with informational context Warning - Success but with warnings Success<T>(T, ResultType) Creates a successful result containing the specified value. public static Result<T> Success<T>(T value, ResultType resultType = ResultType.Success) Parameters value T The value to wrap in the result. Cannot be null. resultType ResultType The type classification for this successful result. Defaults to Success. Returns Result<T> A successful Result<T> instance containing the specified value. Type Parameters T The type of the success value. Examples // Create successful result with value User user = GetCurrentUser(); Result<User> userResult = Result.Success(user); // Success with additional context Result<string> messageResult = Result.Success(\"Operation completed\", ResultType.Information); // Pattern matching usage string displayMessage = userResult.Match( onSuccess: user => $\"Welcome, {user.Name}!\", onFailure: error => $\"Error: {error}\" ); Remarks This is the primary method for creating successful results that return typed values. The result will be immutable and the value will be safely encapsulated. The result type parameter allows for additional classification of successful operations: Success - Standard successful operation Information - Success with informational context Warning - Success but with warnings Exceptions ArgumentNullException Thrown when value is null. Switch(Action, Action<string>, Action<string>, Action<IDictionary<string, string[]>>, Action<string>?) Executes side-effect actions based on the result state with separate handlers for different failure types. public void Switch(Action onSuccess, Action<string> onError, Action<string> onSecurityException, Action<IDictionary<string, string[]>> onValidationException, Action<string>? onOperationCanceledException = null) Parameters onSuccess Action Action to execute if the result is successful. onError Action<string> Action to execute if the result is a general error. Receives the error message. onSecurityException Action<string> Action to execute if the result is a security failure. Receives the error message. onValidationException Action<IDictionary<string, string[]>> Action to execute if the result is a validation failure. Receives the validation errors dictionary. onOperationCanceledException Action<string> Optional action to execute if the result is a cancellation failure. Receives the error message. If null, cancellation failures are ignored. Examples Result operationResult = ProcessRequest(); operationResult.Switch( onSuccess: () => { logger.LogInformation(\"Request processed successfully\"); SendSuccessNotification(); }, onError: error => { logger.LogError(\"System error: {Error}\", error); SendErrorNotification(error); }, onSecurityException: error => { logger.LogWarning(\"Security violation: {Error}\", error); AlertSecurityTeam(error); }, onValidationException: errors => { logger.LogInformation(\"Validation failed: {ErrorCount} errors\", errors.Count); ShowValidationErrors(errors); }, onOperationCanceledException: error => { logger.LogInformation(\"Request was cancelled: {Error}\", error); CleanupResources(); } ); Remarks This overload of Switch provides granular control over different failure types using imperative actions, allowing you to implement specific side effects for each category of failure. This is particularly useful when different failure types require different handling strategies (logging, notifications, etc.). The method routes failures to the appropriate handler based on FailureType: Error → onError Security → onSecurityException Validation → onValidationException OperationCanceled → onOperationCanceledException (if not null) Exceptions ArgumentNullException Thrown when onSuccess, onError, onSecurityException, or onValidationException is null. Switch(Action, Action<string>, bool) Executes side-effect actions based on the result state, with simple success/failure handling. public void Switch(Action onSuccess, Action<string> onFailure, bool includeOperationCancelledFailures = false) Parameters onSuccess Action Action to execute if the result is successful. onFailure Action<string> Action to execute if the result is a failure. Receives the error message. includeOperationCancelledFailures bool If true, operation cancelled failures will call onFailure. If false (default), they will be ignored. Examples Result operationResult = PerformOperation(); operationResult.Switch( onSuccess: () => { Console.WriteLine(\"Operation completed successfully!\"); LogSuccess(\"Operation\", DateTime.Now); }, onFailure: error => { Console.WriteLine($\"Operation failed: {error}\"); LogError(\"Operation\", error); } ); Remarks This is the primary imperative pattern matching method for non-generic Result. Unlike the functional Match<TResult>(Func<TResult>, Func<string, TResult>) method, this executes actions with side effects rather than returning transformed values. This method treats most failure types (Error, Security, Validation) uniformly, calling onFailure with the error message. Operation cancelled failures are treated specially based on the includeOperationCancelledFailures parameter. For more granular failure handling, use the overload that provides separate handlers for each failure type. Exceptions ArgumentNullException Thrown when onSuccess or onFailure is null. ValidationFailure(IDictionary<string, string[]>) Creates a failed result with multiple validation errors (convenience method). public static Result ValidationFailure(IDictionary<string, string[]> errors) Parameters errors IDictionary<string, string[]> A dictionary containing field names as keys and arrays of error messages as values. Cannot be null. Returns Result A failed Result instance with Validation containing all the validation errors. Examples Dictionary<string, string[]> validationErrors = new() { [\"Email\"] = [\"Email is required\", \"Email format is invalid\"], [\"Password\"] = [\"Password must be at least 8 characters\"] }; Result validationResult = Result.ValidationFailure(validationErrors); Remarks This is a convenience method that is equivalent to calling Failure(IDictionary<string, string[]>). It provides a more explicit name when creating validation-specific failures. Exceptions ArgumentNullException Thrown when errors is null. ValidationFailure<T>(IDictionary<string, string[]>) Creates a failed result with multiple validation errors for a generic result type (convenience method). public static Result<T> ValidationFailure<T>(IDictionary<string, string[]> errors) Parameters errors IDictionary<string, string[]> A dictionary containing field names as keys and arrays of error messages as values. Cannot be null. Returns Result<T> A failed Result<T> instance with Validation containing all the validation errors. Type Parameters T The type parameter for the generic result. Examples Dictionary<string, string[]> validationErrors = new() { [\"Name\"] = [\"Name is required\"], [\"Age\"] = [\"Age must be between 18 and 120\"] }; Result<User> validationResult = Result.ValidationFailure<User>(validationErrors); Remarks This is a convenience method that is equivalent to calling Failure<T>(IDictionary<string, string[]>). It provides a more explicit name when creating validation-specific failures. Exceptions ArgumentNullException Thrown when errors is null. Operators explicit operator bool(Result) Explicitly converts a Result to a boolean indicating success or failure. public static explicit operator bool(Result result) Parameters result Result The result to convert. Returns bool true if the result represents success; otherwise, false. Examples Result result = PerformOperation(); if ((bool)result) // Explicit conversion { Console.WriteLine(\"Operation succeeded!\"); } Remarks This explicit conversion provides a convenient way to use results in boolean contexts while making the conversion explicit to avoid accidental usage."
  },
  "api/FlowRight.Core.Results.ResultFailureType.html": {
    "href": "api/FlowRight.Core.Results.ResultFailureType.html",
    "title": "Enum ResultFailureType | FlowRight - Result Pattern Library for .NET",
    "summary": "Enum ResultFailureType Namespace FlowRight.Core.Results Assembly FlowRight.Core.dll Specifies the specific type of failure that occurred in a result operation, providing detailed categorization for different error scenarios and enabling appropriate error handling strategies. public enum ResultFailureType Fields Error = 1 Indicates a general error condition that doesn't fall into other specific categories. This represents system errors, unexpected exceptions, or business rule violations. This is the default failure type for most error scenarios including: System or infrastructure failures Unexpected exceptions Business logic violations General application errors None = 0 Indicates no failure occurred. This value is used for successful results and represents the absence of any error condition. This value should only be present in results where IsSuccess is true. It serves as the default value for successful operations. NotFound = 4 Indicates that the requested resource was not found or does not exist. This represents a client error where the resource does not exist or the client lacks permission to access it. Not found failures are common in REST APIs and data access scenarios. They typically: Correspond to HTTP 404 status codes Indicate that a specific resource or entity does not exist Can be handled differently from general errors May trigger fallback or alternative data retrieval strategies This failure type allows consumers to distinguish between actual errors and legitimate \"not found\" scenarios that may be expected during normal operation. OperationCanceled = 6 Indicates that the operation was canceled before completion, typically due to cancellation tokens, timeouts, or explicit user cancellation requests. Operation canceled failures represent a normal part of application flow control rather than actual errors. They may be handled differently from other failure types: Often ignored in logging May not be displayed to users as errors Can be filtered out of error handling in some scenarios Support graceful shutdown and timeout scenarios Security = 2 Indicates a security-related failure such as authentication failures, authorization violations, or security policy breaches. Security failures typically require special handling and may need to be: Logged to security audit trails Reported to security monitoring systems Handled with specific error messages that don't reveal sensitive information Subject to rate limiting or account lockout policies ServerError = 5 Indicates that the operation failed due to a server-side error, typically representing 5xx HTTP status codes or infrastructure-related failures. Server errors represent failures on the server side that are typically temporary and may be resolved with retry mechanisms or service recovery: Correspond to HTTP 5xx status codes (500-599) Include internal server errors, service unavailable, bad gateway, etc. May be candidates for retry logic with exponential backoff Should be monitored and potentially trigger alerts Distinguished from client errors to enable appropriate handling strategies Validation = 3 Indicates that the operation failed due to validation errors in the input data, typically containing detailed field-level error information. Validation failures are commonly encountered in user-facing applications and APIs. They typically: Contain detailed field-specific error messages Can be displayed directly to users Should not be logged as system errors May include multiple validation errors for different fields The detailed validation errors are typically available through Failures. Remarks This enumeration allows consumers to distinguish between different categories of failures and implement specific handling logic for each type. For example, validation failures might be displayed to users differently than security failures. The failure types are designed to align with common error scenarios in modern applications, including validation, security, and operation lifecycle concerns."
  },
  "api/FlowRight.Core.Results.ResultType.html": {
    "href": "api/FlowRight.Core.Results.ResultType.html",
    "title": "Enum ResultType | FlowRight - Result Pattern Library for .NET",
    "summary": "Enum ResultType Namespace FlowRight.Core.Results Assembly FlowRight.Core.dll Specifies the general category or severity level of a result, providing high-level classification for success states and various types of informational or error conditions. public enum ResultType Fields Error = 3 Indicates that the operation failed to complete successfully due to an error condition. This represents a failure state and typically contains error information instead of a success value. Error results represent various types of failures including system errors, validation failures, security violations, and business rule violations. The specific type of error can be determined using ResultFailureType. Information = 1 Indicates that the operation completed successfully and provides additional informational content that may be useful to the caller or end user. This result type is useful for operations that succeed but want to communicate additional context, such as warnings about deprecated features, informational messages about data transformations, or notifications about side effects. Success = 0 Indicates that the operation completed successfully without any issues. This is the most positive result state and typically contains a success value. Warning = 2 Indicates that the operation completed successfully but encountered conditions that warrant attention or may lead to issues in the future. Warning results are successful but highlight potential problems, configuration issues, or situations that should be addressed. For example, using deprecated APIs, approaching resource limits, or data quality concerns. Remarks This enumeration provides a way to categorize results beyond simple success/failure, allowing for more nuanced result handling in scenarios where different types of non-failure outcomes need to be distinguished. The values are ordered by severity, with Success representing the most positive outcome and Error representing the most severe negative outcome."
  },
  "api/FlowRight.Core.Results.html": {
    "href": "api/FlowRight.Core.Results.html",
    "title": "Namespace FlowRight.Core.Results | FlowRight - Result Pattern Library for .NET",
    "summary": "Namespace FlowRight.Core.Results Classes Result Provides a non-generic Result implementation that represents the outcome of operations that don't return a value, supporting both success and failure states with detailed error information. Result<T> Provides a generic Result implementation that represents the outcome of operations that return a typed value, supporting both success and failure states with comprehensive error handling. Interfaces IResult Represents the basic contract for Result pattern implementations, providing access to success/failure state and error information without exposing the success value. IResultError<T> Provides access to error messages from result operations, supporting covariant access to error information. IResult<T> Represents a Result pattern implementation that can contain a typed success value, providing pattern matching and functional programming capabilities. Enums ResultFailureType Specifies the specific type of failure that occurred in a result operation, providing detailed categorization for different error scenarios and enabling appropriate error handling strategies. ResultType Specifies the general category or severity level of a result, providing high-level classification for success states and various types of informational or error conditions."
  },
  "api/FlowRight.Core.Serialization.ResultJsonConverter.html": {
    "href": "api/FlowRight.Core.Serialization.ResultJsonConverter.html",
    "title": "Class ResultJsonConverter | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ResultJsonConverter Namespace FlowRight.Core.Serialization Assembly FlowRight.Core.dll Provides custom JSON serialization and deserialization for Result instances. public sealed class ResultJsonConverter : JsonConverter<Result> Inheritance object JsonConverter JsonConverter<Result> ResultJsonConverter Examples // Register the converter globally JsonSerializerOptions options = new() { Converters = { new ResultJsonConverter() } }; Result result = Result.Success(); string json = JsonSerializer.Serialize(result, options); Result deserialized = JsonSerializer.Deserialize<Result>(json, options); Remarks This converter ensures proper serialization of Result objects while maintaining immutability and supporting all failure types including validation failures, security exceptions, and operation cancellations. The converter handles both serialization and deserialization in a way that preserves the exact state of Result objects. The converter serializes Result objects as JSON objects with the following structure: { \"error\": \"string\", \"failures\": { \"field\": [\"error1\", \"error2\"] }, \"failureType\": \"None|Error|Security|Validation|OperationCanceled\", \"resultType\": \"Success|Information|Warning|Error\" } Methods CanConvert(Type) Gets a value indicating whether this converter can convert the specified type. public override bool CanConvert(Type typeToConvert) Parameters typeToConvert Type The type to check for conversion capability. Returns bool true if the type is Result or can be handled by this converter; otherwise, false. Read(ref Utf8JsonReader, Type, JsonSerializerOptions) Deserializes a JSON object into a Result instance. public override Result Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) Parameters reader Utf8JsonReader The JSON reader positioned at the start of the Result object. typeToConvert Type The type to convert (should be Result). options JsonSerializerOptions The JSON serializer options. Returns Result A Result instance representing the deserialized JSON data. Remarks This method reconstructs Result objects from JSON by reading the serialized properties and using the appropriate static factory methods to create immutable Result instances. The method preserves the exact failure type and error information from the original object. The deserialization process handles all Result states: Success states with appropriate ResultType General error failures Security failures Validation failures with field-specific errors Operation cancellation failures Exceptions JsonException Thrown when the JSON structure is invalid or contains unexpected data. Write(Utf8JsonWriter, Result, JsonSerializerOptions) Serializes a Result instance to JSON. public override void Write(Utf8JsonWriter writer, Result value, JsonSerializerOptions options) Parameters writer Utf8JsonWriter The JSON writer to write the serialized data to. value Result The Result instance to serialize. options JsonSerializerOptions The JSON serializer options. Remarks This method serializes Result objects to JSON by writing their properties as a JSON object. The serialization preserves all error information, failure types, and result states to enable complete round-trip serialization. The method writes the following JSON structure: error: The error message string failures: Dictionary of field-specific validation errors failureType: The specific failure type enumeration resultType: The general result type enumeration"
  },
  "api/FlowRight.Core.Serialization.ResultTJsonConverter-1.html": {
    "href": "api/FlowRight.Core.Serialization.ResultTJsonConverter-1.html",
    "title": "Class ResultTJsonConverter<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ResultTJsonConverter<T> Namespace FlowRight.Core.Serialization Assembly FlowRight.Core.dll Provides custom JSON serialization and deserialization for Result<T> instances. public sealed class ResultTJsonConverter<T> : JsonConverter<Result<T>> Type Parameters T The type of the success value that the result can contain. Inheritance object JsonConverter JsonConverter<Result<T>> ResultTJsonConverter<T> Examples // Register the converter globally JsonSerializerOptions options = new() { Converters = { new ResultTJsonConverter<User>() } }; Result<User> result = Result.Success(user); string json = JsonSerializer.Serialize(result, options); Result<User> deserialized = JsonSerializer.Deserialize<Result<User>>(json, options); Remarks This converter ensures proper serialization of Result<T> objects while maintaining immutability and supporting all failure types including validation failures, security exceptions, and operation cancellations. The converter handles both serialization and deserialization in a way that preserves the exact state of Result<T> objects including their success values. The converter serializes Result<T> objects as JSON objects with the following structure: { \"value\": T, \"error\": \"string\", \"failures\": { \"field\": [\"error1\", \"error2\"] }, \"failureType\": \"None|Error|Security|Validation|OperationCanceled\", \"resultType\": \"Success|Information|Warning|Error\" } For successful results, the \"value\" property contains the success value. For failed results, the \"value\" property is omitted from the JSON output. Methods CanConvert(Type) Gets a value indicating whether this converter can convert the specified type. public override bool CanConvert(Type typeToConvert) Parameters typeToConvert Type The type to check for conversion capability. Returns bool true if the type is Result<T> of the matching generic type; otherwise, false. Remarks This converter only handles Result<T> where T matches the generic type parameter specified when the converter was instantiated. Each generic Result type requires its own converter instance. Read(ref Utf8JsonReader, Type, JsonSerializerOptions) Deserializes a JSON object into a Result<T> instance. public override Result<T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) Parameters reader Utf8JsonReader The JSON reader positioned at the start of the Result<T> object. typeToConvert Type The type to convert (should be Result<T>). options JsonSerializerOptions The JSON serializer options. Returns Result<T> A Result<T> instance representing the deserialized JSON data. Remarks This method reconstructs Result<T> objects from JSON by reading the serialized properties and using the appropriate static factory methods to create immutable Result<T> instances. The method preserves the exact failure type, error information, and success value from the original object. The deserialization process handles all Result<T> states: Success states with typed values and appropriate ResultType General error failures Security failures Validation failures with field-specific errors Operation cancellation failures When deserializing successful results, the \"value\" property is deserialized according to the type T. For failed results, the value is ignored even if present in the JSON. Exceptions JsonException Thrown when the JSON structure is invalid or contains unexpected data. Write(Utf8JsonWriter, Result<T>, JsonSerializerOptions) Serializes a Result<T> instance to JSON. public override void Write(Utf8JsonWriter writer, Result<T> value, JsonSerializerOptions options) Parameters writer Utf8JsonWriter The JSON writer to write the serialized data to. value Result<T> The Result<T> instance to serialize. options JsonSerializerOptions The JSON serializer options. Remarks This method serializes Result<T> objects to JSON by writing their properties as a JSON object. The serialization preserves all error information, failure types, result states, and success values to enable complete round-trip serialization. The method writes the following JSON structure: value: The success value of type T (only for successful results) error: The error message string failures: Dictionary of field-specific validation errors failureType: The specific failure type enumeration resultType: The general result type enumeration For successful results, the \"value\" property is included with the success value serialized according to type T. For failed results, the \"value\" property is omitted entirely."
  },
  "api/FlowRight.Core.Serialization.html": {
    "href": "api/FlowRight.Core.Serialization.html",
    "title": "Namespace FlowRight.Core.Serialization | FlowRight - Result Pattern Library for .NET",
    "summary": "Namespace FlowRight.Core.Serialization Classes ResultJsonConverter Provides custom JSON serialization and deserialization for Result instances. ResultTJsonConverter<T> Provides custom JSON serialization and deserialization for Result<T> instances."
  },
  "api/FlowRight.Http.Extensions.HttpResponseMessageExtensions.html": {
    "href": "api/FlowRight.Http.Extensions.HttpResponseMessageExtensions.html",
    "title": "Class HttpResponseMessageExtensions | FlowRight - Result Pattern Library for .NET",
    "summary": "Class HttpResponseMessageExtensions Namespace FlowRight.Http.Extensions Assembly FlowRight.Http.dll Provides extension methods for converting HTTP response messages to Result types. public static class HttpResponseMessageExtensions Inheritance object HttpResponseMessageExtensions Methods GetContentTypeInfo(HttpResponseMessage) Gets detailed content type information from the HTTP response message. public static ContentTypeInfo GetContentTypeInfo(this HttpResponseMessage responseMessage) Parameters responseMessage HttpResponseMessage The HTTP response message. Returns ContentTypeInfo A ContentTypeInfo object containing parsed content type details. IsBinaryContentType(HttpResponseMessage) Determines if the response content type represents binary content. public static bool IsBinaryContentType(this HttpResponseMessage responseMessage) Parameters responseMessage HttpResponseMessage The HTTP response message. Returns bool True if the content type represents binary content. IsContentType(HttpResponseMessage, string) Determines if the response content type matches the specified media type. public static bool IsContentType(this HttpResponseMessage responseMessage, string expectedMediaType) Parameters responseMessage HttpResponseMessage The HTTP response message. expectedMediaType string The expected media type to match. Returns bool True if the content types match (ignoring parameters like charset). IsJsonContentType(HttpResponseMessage) Determines if the response content type is a JSON variant. public static bool IsJsonContentType(this HttpResponseMessage responseMessage) Parameters responseMessage HttpResponseMessage The HTTP response message. Returns bool True if the content type represents JSON content. IsTextContentType(HttpResponseMessage) Determines if the response content type represents text content. public static bool IsTextContentType(this HttpResponseMessage responseMessage) Parameters responseMessage HttpResponseMessage The HTTP response message. Returns bool True if the content type represents text content. IsXmlContentType(HttpResponseMessage) Determines if the response content type is an XML variant. public static bool IsXmlContentType(this HttpResponseMessage responseMessage) Parameters responseMessage HttpResponseMessage The HTTP response message. Returns bool True if the content type represents XML content. ToResultAsBytesAsync(HttpResponseMessage, CancellationToken) Converts an HTTP response message to a Result<byte[]> by reading the content as bytes. public static Task<Result<byte[]?>> ToResultAsBytesAsync(this HttpResponseMessage responseMessage, CancellationToken cancellationToken = default) Parameters responseMessage HttpResponseMessage The HTTP response message to convert. cancellationToken CancellationToken Token to cancel the operation. Returns Task<Result<byte[]>> A Result<byte[]> containing the byte content on success, or failure information on error. Examples HttpResponseMessage response = await client.GetAsync(\"/api/file\"); Result<byte[]?> bytesResult = await response.ToResultAsBytesAsync(); if (bytesResult.IsSuccess) { byte[]? bytes = bytesResult.Value; } ToResultAsFormDataAsync(HttpResponseMessage, CancellationToken) Converts an HTTP response message to a Result<Dictionary<string, string>> by parsing form data content. public static Task<Result<Dictionary<string, string>?>> ToResultAsFormDataAsync(this HttpResponseMessage responseMessage, CancellationToken cancellationToken = default) Parameters responseMessage HttpResponseMessage The HTTP response message to convert. cancellationToken CancellationToken Token to cancel the operation. Returns Task<Result<Dictionary<string, string>>> A Result<Dictionary<string, string>> containing the parsed form data on success, or failure information on error. Examples HttpResponseMessage response = await client.PostAsync(\"/api/form\", formContent); Result<Dictionary<string, string>?> formResult = await response.ToResultAsFormDataAsync(); if (formResult.IsSuccess) { Dictionary<string, string>? formData = formResult.Value; } ToResultAsTextAsync(HttpResponseMessage, CancellationToken) Converts an HTTP response message to a Result<string> by reading the content as text. public static Task<Result<string?>> ToResultAsTextAsync(this HttpResponseMessage responseMessage, CancellationToken cancellationToken = default) Parameters responseMessage HttpResponseMessage The HTTP response message to convert. cancellationToken CancellationToken Token to cancel the operation. Returns Task<Result<string>> A Result<string> containing the text content on success, or failure information on error. Examples HttpResponseMessage response = await client.GetAsync(\"/api/text\"); Result<string?> textResult = await response.ToResultAsTextAsync(); if (textResult.IsSuccess) { string? text = textResult.Value; } ToResultAsync(HttpResponseMessage, CancellationToken) Converts an HTTP response message to a Result, handling various HTTP status codes appropriately. public static Task<Result> ToResultAsync(this HttpResponseMessage responseMessage, CancellationToken cancellationToken = default) Parameters responseMessage HttpResponseMessage The HTTP response message to convert. cancellationToken CancellationToken Token to cancel the operation. Returns Task<Result> A Result representing the success or failure of the HTTP operation. Examples HttpResponseMessage response = await client.GetAsync(\"/api/users\"); Result result = await response.ToResultAsync(); if (result.IsSuccess) { // Handle success } ToResultFromJsonAsync<T>(HttpResponseMessage, JsonSerializerOptions?, CancellationToken) Converts an HTTP response message to a Result<T> by deserializing the JSON content. public static Task<Result<T?>> ToResultFromJsonAsync<T>(this HttpResponseMessage responseMessage, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default) Parameters responseMessage HttpResponseMessage The HTTP response message to convert. options JsonSerializerOptions Optional JSON serializer options. cancellationToken CancellationToken Token to cancel the operation. Returns Task<Result<T>> A Result<T> containing the deserialized value on success, or failure information on error. Type Parameters T The type to deserialize the JSON content to. Examples HttpResponseMessage response = await client.GetAsync(\"/api/users/1\"); Result<User?> userResult = await response.ToResultFromJsonAsync<User>(); if (userResult.IsSuccess) { User? user = userResult.Value; } ToResultFromJsonAsync<T>(HttpResponseMessage, JsonTypeInfo<T>, CancellationToken) Converts an HTTP response message to a Result<T> by deserializing the JSON content using a JsonTypeInfo. public static Task<Result<T?>> ToResultFromJsonAsync<T>(this HttpResponseMessage responseMessage, JsonTypeInfo<T> jsonTypeInfo, CancellationToken cancellationToken = default) Parameters responseMessage HttpResponseMessage The HTTP response message to convert. jsonTypeInfo JsonTypeInfo<T> The JsonTypeInfo for source generation serialization. cancellationToken CancellationToken Token to cancel the operation. Returns Task<Result<T>> A Result<T> containing the deserialized value on success, or failure information on error. Type Parameters T The type to deserialize the JSON content to. Examples HttpResponseMessage response = await client.GetAsync(\"/api/users/1\"); Result<User?> userResult = await response.ToResultFromJsonAsync(UserJsonContext.Default.User); if (userResult.IsSuccess) { User? user = userResult.Value; } ToResultFromXmlAsync<T>(HttpResponseMessage, CancellationToken) Converts an HTTP response message to a Result<T> by deserializing the XML content. public static Task<Result<T?>> ToResultFromXmlAsync<T>(this HttpResponseMessage responseMessage, CancellationToken cancellationToken = default) Parameters responseMessage HttpResponseMessage The HTTP response message to convert. cancellationToken CancellationToken Token to cancel the operation. Returns Task<Result<T>> A Result<T> containing the deserialized value on success, or failure information on error. Type Parameters T The type to deserialize the XML content to. Examples HttpResponseMessage response = await client.GetAsync(\"/api/users/1\"); Result<User?> userResult = await response.ToResultFromXmlAsync<User>(); if (userResult.IsSuccess) { User? user = userResult.Value; } ToResultWithContentTypeValidation<T>(HttpResponseMessage, string, CancellationToken) Converts an HTTP response message to a Result<T> with content type validation. public static Task<Result<T?>> ToResultWithContentTypeValidation<T>(this HttpResponseMessage responseMessage, string expectedContentType, CancellationToken cancellationToken = default) Parameters responseMessage HttpResponseMessage The HTTP response message to convert. expectedContentType string The expected content type. cancellationToken CancellationToken Token to cancel the operation. Returns Task<Result<T>> A Result<T> containing the deserialized value on success, or failure information on error. Type Parameters T The type to deserialize the content to. Examples HttpResponseMessage response = await client.GetAsync(\"/api/users/1\"); Result<User?> userResult = await response.ToResultWithContentTypeValidation<User>(\"application/json\"); if (userResult.IsSuccess) { User? user = userResult.Value; } ValidateContentType(HttpResponseMessage, string[]) Validates that the response content type is one of the supported types. public static Result ValidateContentType(this HttpResponseMessage responseMessage, string[] supportedTypes) Parameters responseMessage HttpResponseMessage The HTTP response message. supportedTypes string[] Array of supported content types. Returns Result A Result indicating whether the content type is supported."
  },
  "api/FlowRight.Http.Extensions.html": {
    "href": "api/FlowRight.Http.Extensions.html",
    "title": "Namespace FlowRight.Http.Extensions | FlowRight - Result Pattern Library for .NET",
    "summary": "Namespace FlowRight.Http.Extensions Classes HttpResponseMessageExtensions Provides extension methods for converting HTTP response messages to Result types."
  },
  "api/FlowRight.Http.Models.ContentTypeInfo.html": {
    "href": "api/FlowRight.Http.Models.ContentTypeInfo.html",
    "title": "Class ContentTypeInfo | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ContentTypeInfo Namespace FlowRight.Http.Models Assembly FlowRight.Http.dll Represents parsed content type information including media type, charset, and parameters. public sealed class ContentTypeInfo Inheritance object ContentTypeInfo Properties Charset Gets the charset parameter (e.g., \"utf-8\"). public string? Charset { get; init; } Property Value string MediaType Gets the media type (e.g., \"application/json\"). public string MediaType { get; init; } Property Value string Parameters Gets additional content type parameters. public ReadOnlyDictionary<string, string> Parameters { get; init; } Property Value ReadOnlyDictionary<string, string> Methods FromContentType(ContentType?) Creates a ContentTypeInfo instance from a ContentType object. public static ContentTypeInfo FromContentType(ContentType? contentType) Parameters contentType ContentType The ContentType to parse. Returns ContentTypeInfo A ContentTypeInfo instance with parsed information. IsBinary() Determines if this content type represents binary content. public bool IsBinary() Returns bool True if the media type represents binary content. IsFormData() Determines if this content type represents form data. public bool IsFormData() Returns bool True if the media type represents form data. IsJson() Determines if this content type is a JSON variant. public bool IsJson() Returns bool True if the media type represents JSON content. IsMediaType(string) Determines if this content type matches another media type. public bool IsMediaType(string mediaType) Parameters mediaType string The media type to compare against. Returns bool True if the media types match (ignoring parameters). IsText() Determines if this content type represents text content. public bool IsText() Returns bool True if the media type represents text content. IsXml() Determines if this content type is an XML variant. public bool IsXml() Returns bool True if the media type represents XML content."
  },
  "api/FlowRight.Http.Models.ValidationProblemJsonSerializerContext.html": {
    "href": "api/FlowRight.Http.Models.ValidationProblemJsonSerializerContext.html",
    "title": "Class ValidationProblemJsonSerializerContext | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ValidationProblemJsonSerializerContext Namespace FlowRight.Http.Models Assembly FlowRight.Http.dll Provides JSON serialization context for ValidationProblemResponse to enable AOT compilation. [JsonSerializable(typeof(ValidationProblemResponse))] public sealed class ValidationProblemJsonSerializerContext : JsonSerializerContext Inheritance object JsonSerializerContext ValidationProblemJsonSerializerContext Examples ValidationProblemResponse response = new() { Errors = new() { { \"Field\", [\"Error\"] } } }; string json = JsonSerializer.Serialize(response, ValidationProblemJsonSerializerContext.Default.ValidationProblemResponse); Remarks This context can be used with System.Text.Json for source-generated serialization, improving performance and enabling Native AOT compilation scenarios. Constructors ValidationProblemJsonSerializerContext() public ValidationProblemJsonSerializerContext() ValidationProblemJsonSerializerContext(JsonSerializerOptions) Creates an instance of System.Text.Json.Serialization.JsonSerializerContext and binds it with the indicated System.Text.Json.JsonSerializerOptions. public ValidationProblemJsonSerializerContext(JsonSerializerOptions options) Parameters options JsonSerializerOptions The run time provided options for the context instance. Properties Default The default System.Text.Json.Serialization.JsonSerializerContext associated with a default System.Text.Json.JsonSerializerOptions instance. public static ValidationProblemJsonSerializerContext Default { get; } Property Value ValidationProblemJsonSerializerContext DictionaryStringStringArray Defines the source generated JSON serialization contract metadata for a given type. public JsonTypeInfo<Dictionary<string, string[]>> DictionaryStringStringArray { get; } Property Value JsonTypeInfo<Dictionary<string, string[]>> GeneratedSerializerOptions The source-generated options associated with this context. protected override JsonSerializerOptions? GeneratedSerializerOptions { get; } Property Value JsonSerializerOptions Int32 Defines the source generated JSON serialization contract metadata for a given type. public JsonTypeInfo<int> Int32 { get; } Property Value JsonTypeInfo<int> NullableInt32 Defines the source generated JSON serialization contract metadata for a given type. public JsonTypeInfo<int?> NullableInt32 { get; } Property Value JsonTypeInfo<int?> String Defines the source generated JSON serialization contract metadata for a given type. public JsonTypeInfo<string> String { get; } Property Value JsonTypeInfo<string> StringArray Defines the source generated JSON serialization contract metadata for a given type. public JsonTypeInfo<string[]> StringArray { get; } Property Value JsonTypeInfo<string[]> ValidationProblemResponse Defines the source generated JSON serialization contract metadata for a given type. public JsonTypeInfo<ValidationProblemResponse> ValidationProblemResponse { get; } Property Value JsonTypeInfo<ValidationProblemResponse> Methods GetTypeInfo(Type) Gets metadata for the specified type. public override JsonTypeInfo? GetTypeInfo(Type type) Parameters type Type The type to fetch metadata for. Returns JsonTypeInfo The metadata for the specified type, or null if the context has no metadata for the type."
  },
  "api/FlowRight.Http.Models.ValidationProblemResponse.html": {
    "href": "api/FlowRight.Http.Models.ValidationProblemResponse.html",
    "title": "Class ValidationProblemResponse | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ValidationProblemResponse Namespace FlowRight.Http.Models Assembly FlowRight.Http.dll Represents a validation problem response that follows RFC 7807 Problem Details specification and contains field-specific error messages. public sealed class ValidationProblemResponse Inheritance object ValidationProblemResponse Remarks This class is designed to be fully compatible with ASP.NET Core's ValidationProblemDetails and provides serialization support for error responses from HTTP APIs following the RFC 7807 standard for Problem Details for HTTP APIs. The class includes all standard RFC 7807 properties (type, title, status, detail, instance) plus the validation-specific errors dictionary. This ensures compatibility with both minimal error responses containing only the errors property and full RFC 7807 compliant responses from ASP.NET Core APIs. Properties Detail Gets or sets a human-readable explanation specific to this occurrence of the problem. [JsonPropertyName(\"detail\")] [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)] public string? Detail { get; set; } Property Value string A human-readable explanation specific to this occurrence of the problem. This should focus on helping the client correct the problem. Examples Detail = \"The request failed validation. See errors for details.\" Errors Gets or sets the dictionary of validation errors keyed by field name. [JsonPropertyName(\"errors\")] public Dictionary<string, string[]> Errors { get; set; } Property Value Dictionary<string, string[]> A dictionary where keys are field names and values are arrays of error messages for that field. This property is specific to validation problems and extends the base RFC 7807 structure. Examples ValidationProblemResponse response = new() { Type = \"https://tools.ietf.org/html/rfc7231#section-6.5.1\", Title = \"One or more validation errors occurred.\", Status = 400, Errors = new Dictionary<string, string[]> { { \"Email\", [\"Email is required\", \"Email format is invalid\"] }, { \"Name\", [\"Name is required\"] } } }; Instance Gets or sets a URI reference that identifies the specific occurrence of the problem. [JsonPropertyName(\"instance\")] [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)] public string? Instance { get; set; } Property Value string A URI that identifies the specific occurrence of the problem. This can be used to provide a reference to a specific request or operation. Examples Instance = \"/api/users/validation-error/12345\" Status Gets or sets the HTTP status code generated by the origin server for this occurrence of the problem. [JsonPropertyName(\"status\")] [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)] public int? Status { get; set; } Property Value int? The HTTP status code for this problem. When present, it should match the status code used in the HTTP response. Examples Status = 400 Title Gets or sets a short, human-readable summary of the problem type. [JsonPropertyName(\"title\")] [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)] public string? Title { get; set; } Property Value string A human-readable summary of the problem type. This should not change between occurrences of the problem, except for purposes of localization. Examples Title = \"One or more validation errors occurred.\" Type Gets or sets a URI reference that identifies the problem type. [JsonPropertyName(\"type\")] [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)] public string? Type { get; set; } Property Value string A URI that identifies the problem type. When absent, it defaults to \"about:blank\". Examples Type = \"https://tools.ietf.org/html/rfc7231#section-6.5.1\""
  },
  "api/FlowRight.Http.Models.html": {
    "href": "api/FlowRight.Http.Models.html",
    "title": "Namespace FlowRight.Http.Models | FlowRight - Result Pattern Library for .NET",
    "summary": "Namespace FlowRight.Http.Models Classes ContentTypeInfo Represents parsed content type information including media type, charset, and parameters. ValidationProblemJsonSerializerContext Provides JSON serialization context for ValidationProblemResponse to enable AOT compilation. ValidationProblemResponse Represents a validation problem response that follows RFC 7807 Problem Details specification and contains field-specific error messages."
  },
  "api/FlowRight.Validation.Builders.ValidationBuilder-1.html": {
    "href": "api/FlowRight.Validation.Builders.ValidationBuilder-1.html",
    "title": "Class ValidationBuilder<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ValidationBuilder<T> Namespace FlowRight.Validation.Builders Assembly FlowRight.Validation.dll A fluent validation builder that integrates with the Result<T> pattern to provide comprehensive validation capabilities with automatic error aggregation and Result<T> composition support. public class ValidationBuilder<T> Type Parameters T The type of object being validated and constructed. Inheritance object ValidationBuilder<T> Examples Basic Usage: Result<Character> result = new ValidationBuilder<Character>() .RuleFor(x => x.Name, request.Name) .NotEmpty() .MaximumLength(50) .RuleFor(x => x.Age, request.Age) .GreaterThan(0) .LessThan(120) .Build(() => new Character(request.Name, request.Age)); Result<T> Composition: Result<Character> result = new ValidationBuilder<Character>() .RuleFor(x => x.Attributes, AttributeSet.Create(attributes), out AttributeSet? validatedAttributes) .RuleFor(x => x.Edge, Edge.Create(startingEdge), out Edge? validatedEdge) .Build(() => new Character(name, validatedAttributes!, validatedEdge!)); Conditional Validation: ValidationBuilder<DicePool> builder = new(); return builder .RuleFor(x => x.Limit, limit) .GreaterThanOrEqualTo(0) .When(value => !ignoreLimit) .WithMessage(\"Limit must be specified when not using Edge\"); Constructors ValidationBuilder() Initializes a new instance of the ValidationBuilder class with default settings. public ValidationBuilder() Remarks This constructor creates a ValidationBuilder without validation context support. For context-aware validation scenarios, use the constructor that accepts an IValidationContext. ValidationBuilder(IValidationContext) Initializes a new instance of the ValidationBuilder class with validation context support. public ValidationBuilder(IValidationContext validationContext) Parameters validationContext IValidationContext The validation context for complex validation scenarios. Examples User user = new UserBuilder().Build(); IValidationContext context = ValidationContext.Create(user, serviceProvider); context.SetCustomData(\"ValidationMode\", \"Strict\"); ValidationBuilder<User> builder = new(context); Result<User> result = builder .RuleFor(x => x.Email, request.Email) .Must((email, ctx) => ValidateWithContext(email, ctx), \"Invalid email\") .Build(() => user); Remarks This constructor enables context-aware validation scenarios including cross-property validation, service integration, custom data sharing, and hierarchical validation. Properties HasErrors Gets a value indicating whether any validation errors have been accumulated. public bool HasErrors { get; } Property Value bool true if there are validation errors; otherwise, false. Remarks This property is used internally by the Build method to determine whether to return a success or failure result. It can also be used externally to check validation state before calling Build(). Methods Build(Func<T>) Builds the final Result<T> by validating all accumulated rules and constructing the object if validation succeeds. public Result<T> Build(Func<T> factory) Parameters factory Func<T> A factory function to create the validated object when all validations pass. Returns Result<T> A Result<T> containing either the successfully created object or a validation failure with all accumulated errors. Examples Result<User> result = builder.Build(() => new User(validatedName, validatedEmail)); return result.Match( onSuccess: user => Ok(user), onValidationException: errors => BadRequest(errors)); Exceptions ArgumentNullException Thrown when factory is null. GetErrors() Gets all accumulated validation errors as a dictionary mapping property names to error message arrays. public Dictionary<string, string[]> GetErrors() Returns Dictionary<string, string[]> A dictionary where keys are property names and values are arrays of error messages for that property. Returns an empty dictionary if no validation errors have been accumulated. Examples ValidationBuilder<User> builder = new(); builder.RuleFor(x => x.Name, \"\").NotEmpty(); builder.RuleFor(x => x.Email, \"invalid\").EmailAddress(); Dictionary<string, string[]> errors = builder.GetErrors(); // errors[\"Name\"] contains [\"Name is required\"] // errors[\"Email\"] contains [\"Email address format is invalid\"] RuleFor(Expression<Func<T, bool>>, bool, out bool?, string?) Creates validation rules for a boolean property with out parameter support for value extraction. public ValidationBuilder<T> RuleFor(Expression<Func<T, bool>> propertySelector, bool value, out bool? validatedValue, string? displayName = null) Parameters propertySelector Expression<Func<T, bool>> An expression selecting the property to validate. value bool The actual boolean value to be validated. validatedValue bool? Output parameter that receives the validated value. displayName string Optional custom display name for error messages. Returns ValidationBuilder<T> The ValidationBuilder<T> for continued chaining. RuleFor(Expression<Func<T, bool>>, bool, string?) Creates validation rules for a boolean property using a fluent interface. public GenericPropertyValidator<T, bool> RuleFor(Expression<Func<T, bool>> propertySelector, bool value, string? displayName = null) Parameters propertySelector Expression<Func<T, bool>> An expression selecting the property to validate (e.g., x => x.IsActive). value bool The actual boolean value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns GenericPropertyValidator<T, bool> A GenericPropertyValidator<T, bool> for chaining additional validation rules. Examples ValidationBuilder<User> builder = new(); builder.RuleFor(x => x.HasAcceptedTerms, request.HasAcceptedTerms) .Equal(true) .WithMessage(\"Terms and conditions must be accepted\"); RuleFor(Expression<Func<T, byte>>, byte, string?) Creates validation rules for a byte numeric property using a fluent interface. public NumericPropertyValidator<T, byte> RuleFor(Expression<Func<T, byte>> propertySelector, byte value, string? displayName = null) Parameters propertySelector Expression<Func<T, byte>> Expression selecting the property to validate. value byte The byte value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, byte> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, char>>, char, string?) Creates validation rules for a character property using a fluent interface. public GenericPropertyValidator<T, char> RuleFor(Expression<Func<T, char>> propertySelector, char value, string? displayName = null) Parameters propertySelector Expression<Func<T, char>> An expression selecting the property to validate (e.g., x => x.Grade). value char The actual character value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns GenericPropertyValidator<T, char> A GenericPropertyValidator<T, char> for chaining additional validation rules. Examples ValidationBuilder<Student> builder = new(); builder.RuleFor(x => x.Grade, request.Grade) .Must(grade => \"ABCDF\".Contains(grade), \"Grade must be A, B, C, D, or F\") .WithMessage(\"Invalid grade provided\"); RuleFor(Expression<Func<T, DateTime>>, DateTime, out DateTime?, string?) Creates validation rules for a DateTime property with out parameter support for value extraction. public ValidationBuilder<T> RuleFor(Expression<Func<T, DateTime>> propertySelector, DateTime value, out DateTime? validatedValue, string? displayName = null) Parameters propertySelector Expression<Func<T, DateTime>> An expression selecting the property to validate. value DateTime The actual DateTime value to be validated. validatedValue DateTime? Output parameter that receives the validated value if validation succeeds, or null if validation fails. displayName string Optional custom display name for error messages. Returns ValidationBuilder<T> The ValidationBuilder<T> for continued chaining. RuleFor(Expression<Func<T, DateTime>>, DateTime, string?) Creates validation rules for a DateTime property using a fluent interface. public GenericPropertyValidator<T, DateTime> RuleFor(Expression<Func<T, DateTime>> propertySelector, DateTime value, string? displayName = null) Parameters propertySelector Expression<Func<T, DateTime>> An expression selecting the property to validate (e.g., x => x.CreatedAt). value DateTime The actual DateTime value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns GenericPropertyValidator<T, DateTime> A GenericPropertyValidator<T, DateTime> for chaining additional validation rules. Examples ValidationBuilder<Event> builder = new(); builder.RuleFor(x => x.StartDate, request.StartDate) .NotEqual(default) .Must(date => date > DateTime.Now, \"Start date must be in the future\") .WithMessage(\"Invalid start date provided\"); RuleFor(Expression<Func<T, decimal>>, decimal, out decimal?, string?) Creates validation rules for a decimal property with out parameter support for value extraction. public ValidationBuilder<T> RuleFor(Expression<Func<T, decimal>> propertySelector, decimal value, out decimal? validatedValue, string? displayName = null) Parameters propertySelector Expression<Func<T, decimal>> An expression selecting the property to validate. value decimal The actual decimal value to be validated. validatedValue decimal? Output parameter that receives the validated value if validation succeeds, or null if validation fails. displayName string Optional custom display name for error messages. Returns ValidationBuilder<T> The ValidationBuilder<T> for continued chaining. RuleFor(Expression<Func<T, decimal>>, decimal, string?) Creates validation rules for a decimal numeric property using a fluent interface. public NumericPropertyValidator<T, decimal> RuleFor(Expression<Func<T, decimal>> propertySelector, decimal value, string? displayName = null) Parameters propertySelector Expression<Func<T, decimal>> Expression selecting the property to validate. value decimal The decimal value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, decimal> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, double>>, double, string?) Creates validation rules for a double numeric property using a fluent interface. public NumericPropertyValidator<T, double> RuleFor(Expression<Func<T, double>> propertySelector, double value, string? displayName = null) Parameters propertySelector Expression<Func<T, double>> Expression selecting the property to validate. value double The double value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, double> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, short>>, short, string?) Creates validation rules for a short numeric property using a fluent interface. public NumericPropertyValidator<T, short> RuleFor(Expression<Func<T, short>> propertySelector, short value, string? displayName = null) Parameters propertySelector Expression<Func<T, short>> Expression selecting the property to validate. value short The short value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, short> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, int>>, int, out int?, string?) Creates validation rules for an integer property with out parameter support for value extraction. This overload performs basic validation immediately and provides the validated value through the out parameter. public ValidationBuilder<T> RuleFor(Expression<Func<T, int>> propertySelector, int value, out int? validatedValue, string? displayName = null) Parameters propertySelector Expression<Func<T, int>> An expression selecting the property to validate (e.g., x => x.Age). value int The actual integer value to be validated. validatedValue int? Output parameter that receives the validated value if validation succeeds, or null if validation fails. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns ValidationBuilder<T> The ValidationBuilder<T> for continued chaining of other property validations. Examples ValidationBuilder<User> builder = new(); builder.RuleFor(x => x.Age, request.Age, out int? validatedAge); Result<User> result = builder.Build(() => new User(\"name\", \"email\", validatedAge!.Value)); Remarks This overload enables extraction of validated values for use in object construction patterns. The out parameter will contain the input value if it passes basic validation (greater than or equal to 0), or null if the basic validation fails. For more complex validation rules, use the standard RuleFor overload that returns a property validator. RuleFor(Expression<Func<T, int>>, int, string?) Creates validation rules for an integer property using a fluent interface. public NumericPropertyValidator<T, int> RuleFor(Expression<Func<T, int>> propertySelector, int value, string? displayName = null) Parameters propertySelector Expression<Func<T, int>> An expression selecting the property to validate (e.g., x => x.Age). value int The actual integer value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns NumericPropertyValidator<T, int> A NumericPropertyValidator<T, int> for chaining additional numeric validation rules. Examples ValidationBuilder<User> builder = new(); builder.RuleFor(x => x.Age, request.Age) .GreaterThan(0) .LessThan(120) .WithMessage(\"Age must be between 1 and 119\"); RuleFor(Expression<Func<T, long>>, long, string?) Creates validation rules for a long numeric property using a fluent interface. public NumericPropertyValidator<T, long> RuleFor(Expression<Func<T, long>> propertySelector, long value, string? displayName = null) Parameters propertySelector Expression<Func<T, long>> Expression selecting the property to validate. value long The long value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, long> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, bool?>>, bool?, string?) Creates validation rules for a nullable boolean property using a fluent interface. public GenericPropertyValidator<T, bool?> RuleFor(Expression<Func<T, bool?>> propertySelector, bool? value, string? displayName = null) Parameters propertySelector Expression<Func<T, bool?>> An expression selecting the property to validate (e.g., x => x.IsVerified). value bool? The actual nullable boolean value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns GenericPropertyValidator<T, bool?> A GenericPropertyValidator<T, bool?> for chaining additional validation rules. Examples ValidationBuilder<Account> builder = new(); builder.RuleFor(x => x.IsEmailVerified, request.IsEmailVerified) .Notnull() .Equal(true) .WithMessage(\"Email verification is required\"); RuleFor(Expression<Func<T, byte?>>, byte?, string?) Creates validation rules for a nullable byte numeric property using a fluent interface. public GenericPropertyValidator<T, byte?> RuleFor(Expression<Func<T, byte?>> propertySelector, byte? value, string? displayName = null) Parameters propertySelector Expression<Func<T, byte?>> Expression selecting the property to validate. value byte? The nullable byte value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, byte?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, char?>>, char?, string?) Creates validation rules for a nullable character property using a fluent interface. public GenericPropertyValidator<T, char?> RuleFor(Expression<Func<T, char?>> propertySelector, char? value, string? displayName = null) Parameters propertySelector Expression<Func<T, char?>> An expression selecting the property to validate (e.g., x => x.MiddleInitial). value char? The actual nullable character value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns GenericPropertyValidator<T, char?> A GenericPropertyValidator<T, char?> for chaining additional validation rules. Examples ValidationBuilder<Person> builder = new(); builder.RuleFor(x => x.MiddleInitial, request.MiddleInitial) .Must(initial => initial is null || char.IsLetter(initial.Value), \"Middle initial must be a letter\") .WithMessage(\"Invalid middle initial provided\"); RuleFor(Expression<Func<T, DateTime?>>, DateTime?, string?) Creates validation rules for a nullable DateTime property using a fluent interface. public GenericPropertyValidator<T, DateTime?> RuleFor(Expression<Func<T, DateTime?>> propertySelector, DateTime? value, string? displayName = null) Parameters propertySelector Expression<Func<T, DateTime?>> An expression selecting the property to validate (e.g., x => x.UpdatedAt). value DateTime? The actual nullable DateTime value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns GenericPropertyValidator<T, DateTime?> A GenericPropertyValidator<T, DateTime?> for chaining additional validation rules. Examples ValidationBuilder<Event> builder = new(); builder.RuleFor(x => x.EndDate, request.EndDate) .Notnull() .Must(date => date > DateTime.Now, \"End date must be in the future\") .WithMessage(\"End date is required and must be valid\"); RuleFor(Expression<Func<T, decimal?>>, decimal?, string?) Creates validation rules for a nullable decimal numeric property using a fluent interface. public GenericPropertyValidator<T, decimal?> RuleFor(Expression<Func<T, decimal?>> propertySelector, decimal? value, string? displayName = null) Parameters propertySelector Expression<Func<T, decimal?>> Expression selecting the property to validate. value decimal? The nullable decimal value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, decimal?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, double?>>, double?, string?) Creates validation rules for a nullable double numeric property using a fluent interface. public GenericPropertyValidator<T, double?> RuleFor(Expression<Func<T, double?>> propertySelector, double? value, string? displayName = null) Parameters propertySelector Expression<Func<T, double?>> Expression selecting the property to validate. value double? The nullable double value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, double?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, Guid?>>, Guid?, out Guid?, string?) Creates validation rules for a Guid? property with out parameter support for value extraction. public ValidationBuilder<T> RuleFor(Expression<Func<T, Guid?>> propertySelector, Guid? value, out Guid? validatedValue, string? displayName = null) Parameters propertySelector Expression<Func<T, Guid?>> An expression selecting the property to validate. value Guid? The actual Guid? value to be validated. validatedValue Guid? Output parameter that receives the validated value if validation succeeds, or null if validation fails. displayName string Optional custom display name for error messages. Returns ValidationBuilder<T> The ValidationBuilder<T> for continued chaining. RuleFor(Expression<Func<T, Guid?>>, Guid?, string?) Creates validation rules for a Guid? property using a fluent interface. public GuidPropertyValidator<T> RuleFor(Expression<Func<T, Guid?>> propertySelector, Guid? value, string? displayName = null) Parameters propertySelector Expression<Func<T, Guid?>> An expression selecting the property to validate (e.g., x => x.Id). value Guid? The actual value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns GuidPropertyValidator<T> A GuidPropertyValidator<T> for chaining additional validation rules. Examples ValidationBuilder<Entity> builder = new(); builder.RuleFor(x => x.Id, request.Id) .NotEqual(Guid.Empty) .WithMessage(\"Entity ID cannot be empty\"); RuleFor(Expression<Func<T, short?>>, short?, string?) Creates validation rules for a nullable short numeric property using a fluent interface. public GenericPropertyValidator<T, short?> RuleFor(Expression<Func<T, short?>> propertySelector, short? value, string? displayName = null) Parameters propertySelector Expression<Func<T, short?>> Expression selecting the property to validate. value short? The nullable short value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, short?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, int?>>, int?, string?) Creates validation rules for a nullable integer numeric property using a fluent interface. public GenericPropertyValidator<T, int?> RuleFor(Expression<Func<T, int?>> propertySelector, int? value, string? displayName = null) Parameters propertySelector Expression<Func<T, int?>> Expression selecting the property to validate. value int? The nullable integer value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, int?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, long?>>, long?, string?) Creates validation rules for a nullable long numeric property using a fluent interface. public GenericPropertyValidator<T, long?> RuleFor(Expression<Func<T, long?>> propertySelector, long? value, string? displayName = null) Parameters propertySelector Expression<Func<T, long?>> Expression selecting the property to validate. value long? The nullable long value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, long?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, sbyte?>>, sbyte?, string?) Creates validation rules for a nullable signed byte numeric property using a fluent interface. public GenericPropertyValidator<T, sbyte?> RuleFor(Expression<Func<T, sbyte?>> propertySelector, sbyte? value, string? displayName = null) Parameters propertySelector Expression<Func<T, sbyte?>> Expression selecting the property to validate. value sbyte? The nullable sbyte value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, sbyte?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, float?>>, float?, string?) Creates validation rules for a nullable float numeric property using a fluent interface. public GenericPropertyValidator<T, float?> RuleFor(Expression<Func<T, float?>> propertySelector, float? value, string? displayName = null) Parameters propertySelector Expression<Func<T, float?>> Expression selecting the property to validate. value float? The nullable float value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, float?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, uint?>>, uint?, string?) Creates validation rules for a nullable unsigned integer numeric property using a fluent interface. public GenericPropertyValidator<T, uint?> RuleFor(Expression<Func<T, uint?>> propertySelector, uint? value, string? displayName = null) Parameters propertySelector Expression<Func<T, uint?>> Expression selecting the property to validate. value uint? The nullable uint value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, uint?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, ulong?>>, ulong?, string?) Creates validation rules for a nullable unsigned long numeric property using a fluent interface. public GenericPropertyValidator<T, ulong?> RuleFor(Expression<Func<T, ulong?>> propertySelector, ulong? value, string? displayName = null) Parameters propertySelector Expression<Func<T, ulong?>> Expression selecting the property to validate. value ulong? The nullable ulong value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, ulong?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, sbyte>>, sbyte, string?) Creates validation rules for a signed byte numeric property using a fluent interface. public NumericPropertyValidator<T, sbyte> RuleFor(Expression<Func<T, sbyte>> propertySelector, sbyte value, string? displayName = null) Parameters propertySelector Expression<Func<T, sbyte>> Expression selecting the property to validate. value sbyte The sbyte value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, sbyte> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, float>>, float, string?) Creates validation rules for a float numeric property using a fluent interface. public NumericPropertyValidator<T, float> RuleFor(Expression<Func<T, float>> propertySelector, float value, string? displayName = null) Parameters propertySelector Expression<Func<T, float>> Expression selecting the property to validate. value float The float value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, float> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, string>>, string, string?) Creates validation rules for a string property using a fluent interface. public StringPropertyValidator<T> RuleFor(Expression<Func<T, string>> propertySelector, string value, string? displayName = null) Parameters propertySelector Expression<Func<T, string>> An expression selecting the property to validate (e.g., x => x.Name). value string The actual string value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns StringPropertyValidator<T> A StringPropertyValidator<T> for chaining additional string-specific validation rules. Examples ValidationBuilder<User> builder = new(); builder.RuleFor(x => x.Name, request.Name) .NotEmpty() .MinimumLength(2) .MaximumLength(50) .Matches(\"^[a-zA-Z ]+$\") .WithMessage(\"Name must contain only letters and spaces\"); RuleFor(Expression<Func<T, string>>, string, out string?, string?) Creates validation rules for a string property with out parameter support for value extraction. This overload performs basic validation immediately and provides the validated value through the out parameter. public ValidationBuilder<T> RuleFor(Expression<Func<T, string>> propertySelector, string value, out string? validatedValue, string? displayName = null) Parameters propertySelector Expression<Func<T, string>> An expression selecting the property to validate (e.g., x => x.Name). value string The actual string value to be validated. validatedValue string Output parameter that receives the validated value if validation succeeds, or null if validation fails. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns ValidationBuilder<T> The ValidationBuilder<T> for continued chaining of other property validations. Examples ValidationBuilder<User> builder = new(); builder.RuleFor(x => x.Name, request.Name, out string? validatedName); builder.RuleFor(x => x.Age, request.Age, out int? validatedAge); Result<User> result = builder.Build(() => new User(validatedName!, validatedAge!.Value, \"email\")); Remarks This overload enables extraction of validated values for use in object construction patterns. The out parameter will contain the input value if it passes basic validation (not null/empty for strings), or null if the basic validation fails. For more complex validation rules, use the standard RuleFor overload that returns a property validator. RuleFor(Expression<Func<T, uint>>, uint, string?) Creates validation rules for an unsigned integer numeric property using a fluent interface. public NumericPropertyValidator<T, uint> RuleFor(Expression<Func<T, uint>> propertySelector, uint value, string? displayName = null) Parameters propertySelector Expression<Func<T, uint>> Expression selecting the property to validate. value uint The uint value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, uint> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, ulong>>, ulong, string?) Creates validation rules for an unsigned long numeric property using a fluent interface. public NumericPropertyValidator<T, ulong> RuleFor(Expression<Func<T, ulong>> propertySelector, ulong value, string? displayName = null) Parameters propertySelector Expression<Func<T, ulong>> Expression selecting the property to validate. value ulong The ulong value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, ulong> A numeric property validator for further rule configuration. RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>>, IEnumerable<TItem>, out IEnumerable<TItem>?, string?) Creates validation rules for an enumerable property with out parameter support for value extraction. public ValidationBuilder<T> RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>> propertySelector, IEnumerable<TItem> value, out IEnumerable<TItem>? validatedValue, string? displayName = null) Parameters propertySelector Expression<Func<T, IEnumerable<TItem>>> An expression selecting the property to validate. value IEnumerable<TItem> The actual enumerable value to be validated. validatedValue IEnumerable<TItem> Output parameter that receives the validated value if validation succeeds, or null if validation fails. displayName string Optional custom display name for error messages. Returns ValidationBuilder<T> The ValidationBuilder<T> for continued chaining. Type Parameters TItem The type of items in the enumerable. RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>>, IEnumerable<TItem>, string?) Creates validation rules for an enumerable property using a fluent interface. public EnumerablePropertyValidator<T, TItem> RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>> propertySelector, IEnumerable<TItem> value, string? displayName = null) Parameters propertySelector Expression<Func<T, IEnumerable<TItem>>> An expression selecting the property to validate (e.g., x => x.Skills). value IEnumerable<TItem> The actual enumerable value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns EnumerablePropertyValidator<T, TItem> An EnumerablePropertyValidator<T, TItem> for chaining additional collection-specific validation rules. Type Parameters TItem The type of items in the enumerable. Examples ValidationBuilder<Character> builder = new(); builder.RuleFor(x => x.Skills, request.Skills) .NotEmpty() .MinCount(1) .MaxCount(20) .Unique() .WithMessage(\"Character must have 1-20 unique skills\"); RuleFor<TProp>(Expression<Func<T, TProp>>, Result<TProp>, out TProp?) Integrates Result<T> validation into the validation builder, automatically extracting failures and providing access to successful values. This is the key method that enables composition of multiple Result<T> operations in a single validation chain. public ValidationBuilder<T> RuleFor<TProp>(Expression<Func<T, TProp>> propertySelector, Result<TProp> result, out TProp? value) Parameters propertySelector Expression<Func<T, TProp>> An expression selecting the property (e.g., x => x.Attributes). result Result<TProp> A Result<TProp> containing either a successful value or validation errors. value TProp Output parameter providing access to the successful value for object construction, or default if validation failed. Returns ValidationBuilder<T> The ValidationBuilder<T> for continued chaining. Type Parameters TProp The type of property being validated through a Result<T>. Examples // Compose multiple Result<T> validations Result<Character> result = new ValidationBuilder<Character>() .RuleFor(x => x.Attributes, AttributeSet.Create(request.Attributes), out AttributeSet? attributes) .RuleFor(x => x.Edge, Edge.Create(request.StartingEdge), out Edge? edge) .RuleFor(x => x.Health, ConditionMonitor.Create(attributes), out ConditionMonitor? health) .Build(() => new Character(request.Name, attributes!, edge!, health!)); // All validation failures are automatically aggregated // Success values are available through out parameters Remarks This method automatically handles all Result<T> failure types: - Simple errors: Added as single error messages - Validation exceptions: Merged with existing validation errors - Security exceptions: Added as security-related errors - Operation cancelled exceptions: Added as cancellation errors The out parameter allows access to successful validation results for object construction, enabling patterns like: new Character(name, validatedAttributes!, validatedEdge!) RuleFor<TProp>(Expression<Func<T, TProp>>, TProp, string?) Creates validation rules for any property type using a fluent interface. This is the fallback validator for types that don't have specialized validators (string, numeric, enumerable, guid). public GenericPropertyValidator<T, TProp> RuleFor<TProp>(Expression<Func<T, TProp>> propertySelector, TProp value, string? displayName = null) Parameters propertySelector Expression<Func<T, TProp>> An expression selecting the property to validate (e.g., x => x.CustomType). value TProp The actual value to be validated. displayName string Optional custom display name for error messages. If null, uses the property name from the expression. Returns GenericPropertyValidator<T, TProp> A GenericPropertyValidator<T, TProp> for chaining general validation rules. Type Parameters TProp The type of property being validated. Examples ValidationBuilder<Order> builder = new(); builder.RuleFor(x => x.Status, request.Status) .NotNull() .Must(status => status != OrderStatus.Invalid, \"Order status cannot be Invalid\") .Equal(OrderStatus.Pending);"
  },
  "api/FlowRight.Validation.Builders.html": {
    "href": "api/FlowRight.Validation.Builders.html",
    "title": "Namespace FlowRight.Validation.Builders | FlowRight - Result Pattern Library for .NET",
    "summary": "Namespace FlowRight.Validation.Builders Classes ValidationBuilder<T> A fluent validation builder that integrates with the Result<T> pattern to provide comprehensive validation capabilities with automatic error aggregation and Result<T> composition support."
  },
  "api/FlowRight.Validation.Context.IValidationContext.html": {
    "href": "api/FlowRight.Validation.Context.IValidationContext.html",
    "title": "Interface IValidationContext | FlowRight - Result Pattern Library for .NET",
    "summary": "Interface IValidationContext Namespace FlowRight.Validation.Context Assembly FlowRight.Validation.dll Provides validation context for complex validation scenarios, enabling access to parent objects, services, custom data storage, and hierarchical validation support. public interface IValidationContext Examples // Context-aware validation with service integration IValidationContext context = ValidationContext.Create(user, serviceProvider); context.SetCustomData(\"MaxRetryAttempts\", 3); Result<User> result = new ValidationBuilder<User>(context) .RuleFor(x => x.Email, request.Email) .MustAsync(async (email, ctx) => { IEmailService? emailService = ctx.GetService<IEmailService>(); return emailService != null && await emailService.IsValidAsync(email); }, \"Email validation failed\") .RuleFor(x => x.Username, request.Username) .Must((username, ctx) => { User? rootUser = ctx.GetRootObject<User>(); return rootUser != null && !string.Equals(username, rootUser.Email, StringComparison.OrdinalIgnoreCase); }, \"Username cannot be the same as email\") .Build(() => new User(request.Email, request.Username)); Remarks The ValidationContext enables sophisticated validation scenarios by providing: Access to root object being validated for cross-property validation Service provider integration for external dependency validation Custom data storage for sharing state between validation rules Hierarchical validation support with parent-child context relationships Rule execution tracking for conditional validation logic Property path tracking for nested object validation This interface is particularly useful for validation scenarios that require: Business rule validation that depends on multiple properties External service integration (database lookups, API calls) Conditional validation based on previous validation results Complex nested object validation with context propagation State sharing between validation rules within the same validation session Properties CustomData Gets the custom data dictionary for storing validation state. IReadOnlyDictionary<string, object> CustomData { get; } Property Value IReadOnlyDictionary<string, object> A read-only dictionary containing custom data set during validation. Remarks Custom data provides a mechanism for storing and sharing state between validation rules within the same validation session. This is useful for caching expensive calculations or sharing computed values across multiple validation rules. Parent Gets the parent validation context, if this is a child context. IValidationContext? Parent { get; } Property Value IValidationContext The parent validation context, or null if this is a root context. RootObject Gets the root object being validated, if available. object? RootObject { get; } Property Value object The root object being validated, or null if no root object was provided during context creation. Remarks The root object provides access to the entire object being validated, enabling cross-property validation scenarios where one property's validation depends on the values of other properties. ServiceProvider Gets the service provider for dependency injection, if available. IServiceProvider? ServiceProvider { get; } Property Value IServiceProvider The service provider instance, or null if no service provider was provided during context creation. Remarks The service provider enables validation rules to access external dependencies such as repositories, web services, or other business services required for validation logic. Methods CreateChildContext(object, string?) Creates a child validation context for nested object validation. IValidationContext CreateChildContext(object childObject, string? propertyName = null) Parameters childObject object The child object being validated. propertyName string The name of the property containing the child object. Returns IValidationContext A new validation context that inherits from the current context. Examples IValidationContext childContext = parentContext.CreateChildContext(user.Profile, \"Profile\"); // Child context has access to parent's custom data and services Remarks Child contexts inherit custom data and service providers from their parent context, enabling consistent validation behavior across nested object hierarchies. GetCurrentPropertyPath() Gets the current property path being validated. string GetCurrentPropertyPath() Returns string The full property path from the root object to the current property being validated. Examples string path = context.GetCurrentPropertyPath(); // Returns \"User.Profile.Bio\" Remarks Property paths use dot notation for nested properties (e.g., \"User.Profile.Bio\") and bracket notation for collection indices (e.g., \"User.Roles[0].Name\"). GetCustomData<T>(string) Gets custom data from the validation context. T? GetCustomData<T>(string key) Parameters key string The key identifying the data. Returns T The data value cast to type T, or the default value of T if the key is not found or cannot be cast. Type Parameters T The type of data to retrieve. Examples int maxAge = context.GetCustomData<int>(\"MaxAllowedAge\"); User? dbUser = context.GetCustomData<User>(\"DatabaseUser\"); GetExecutedRules() Gets a read-only list of validation rules that have been executed in this context. IReadOnlyList<string> GetExecutedRules() Returns IReadOnlyList<string> A list of rule identifiers representing the validation rules that have been executed. Examples IReadOnlyList<string> executedRules = context.GetExecutedRules(); bool nameValidated = executedRules.Any(rule => rule.Contains(\"Name.NotEmpty\")); Remarks Rule execution tracking enables conditional validation logic where the execution of subsequent rules can depend on which previous rules have been executed and their results. GetRootObject<T>() Gets the root object being validated as the specified type. T? GetRootObject<T>() where T : class Returns T The root object cast to type T, or null if the root object is null or not of type T. Type Parameters T The type to cast the root object to. Examples User? user = context.GetRootObject<User>(); if (user != null) { // Access user properties for validation logic return someProperty != user.SomeOtherProperty; } GetService<T>() Gets a service of the specified type from the service provider. T? GetService<T>() where T : class Returns T The service instance if found, or null if the service is not available or no service provider exists. Type Parameters T The type of service to retrieve. Examples IEmailValidationService? emailService = context.GetService<IEmailValidationService>(); if (emailService != null) { return await emailService.IsValidEmailAsync(email); } HasCustomData(string) Determines whether the validation context contains custom data with the specified key. bool HasCustomData(string key) Parameters key string The key to check for. Returns bool true if the context contains data with the specified key; otherwise, false. RecordRuleExecution(string, string, bool) Records that a validation rule has been executed. void RecordRuleExecution(string ruleIdentifier, string propertyName, bool success) Parameters ruleIdentifier string A unique identifier for the validation rule. propertyName string The name of the property being validated. success bool Whether the validation rule passed or failed. Remarks This method is typically called internally by the validation framework to track rule execution for conditional validation scenarios. RemoveCustomData(string) Removes custom data from the validation context. bool RemoveCustomData(string key) Parameters key string The key identifying the data to remove. Returns bool true if the data was found and removed; otherwise, false. SetCustomData(string, object) Sets custom data in the validation context. void SetCustomData(string key, object value) Parameters key string The key to identify the data. value object The value to store. Examples context.SetCustomData(\"DatabaseUser\", currentUser); context.SetCustomData(\"MaxAllowedAge\", 65); Remarks Custom data is stored for the lifetime of the validation context and can be accessed by any validation rule within the same validation session."
  },
  "api/FlowRight.Validation.Context.ValidationContext.html": {
    "href": "api/FlowRight.Validation.Context.ValidationContext.html",
    "title": "Class ValidationContext | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ValidationContext Namespace FlowRight.Validation.Context Assembly FlowRight.Validation.dll Concrete implementation of IValidationContext that provides comprehensive validation context for complex validation scenarios with object access, service integration, custom data storage, and hierarchical validation support. public sealed class ValidationContext : IValidationContext Inheritance object ValidationContext Implements IValidationContext Examples // Create context with services and root object IValidationContext context = ValidationContext.Create(user, serviceProvider); context.SetCustomData(\"ValidationMode\", \"Strict\"); // Use in ValidationBuilder Result<User> result = new ValidationBuilder<User>(context) .RuleFor(x => x.Email, request.Email) .Must((email, ctx) => ValidateEmailWithContext(email, ctx), \"Invalid email\") .Build(() => new User(request.Email)); Remarks This implementation provides a complete validation context system that enables: Cross-property validation through root object access External service integration via dependency injection State sharing through custom data storage Nested validation with parent-child context relationships Rule execution tracking for conditional validation Property path tracking for error reporting and debugging The ValidationContext follows an immutable design pattern where child contexts inherit from their parents but cannot modify parent state, ensuring validation isolation and predictability. Properties CustomData Gets the custom data dictionary for storing validation state. public IReadOnlyDictionary<string, object> CustomData { get; } Property Value IReadOnlyDictionary<string, object> A read-only dictionary containing custom data set during validation. Remarks Custom data provides a mechanism for storing and sharing state between validation rules within the same validation session. This is useful for caching expensive calculations or sharing computed values across multiple validation rules. Parent Gets the parent validation context, if this is a child context. public IValidationContext? Parent { get; } Property Value IValidationContext The parent validation context, or null if this is a root context. RootObject Gets the root object being validated, if available. public object? RootObject { get; } Property Value object The root object being validated, or null if no root object was provided during context creation. Remarks The root object provides access to the entire object being validated, enabling cross-property validation scenarios where one property's validation depends on the values of other properties. ServiceProvider Gets the service provider for dependency injection, if available. public IServiceProvider? ServiceProvider { get; } Property Value IServiceProvider The service provider instance, or null if no service provider was provided during context creation. Remarks The service provider enables validation rules to access external dependencies such as repositories, web services, or other business services required for validation logic. Methods Create() Creates a new validation context with default settings. public static IValidationContext Create() Returns IValidationContext A new ValidationContext instance with no root object or service provider. Examples IValidationContext context = ValidationContext.Create(); context.SetCustomData(\"ValidationLevel\", \"Basic\"); Create(IServiceProvider) Creates a new validation context with the specified service provider. public static IValidationContext Create(IServiceProvider serviceProvider) Parameters serviceProvider IServiceProvider The service provider for dependency injection. Returns IValidationContext A new ValidationContext instance with the specified service provider. Examples IValidationContext context = ValidationContext.Create(serviceProvider: myServiceProvider); Create(object) Creates a new validation context with the specified root object. public static IValidationContext Create(object rootObject) Parameters rootObject object The root object being validated. Returns IValidationContext A new ValidationContext instance with the specified root object. Examples User user = new UserBuilder().Build(); IValidationContext context = ValidationContext.Create(user); Create(object?, IServiceProvider?) Creates a new validation context with the specified root object and service provider. public static IValidationContext Create(object? rootObject = null, IServiceProvider? serviceProvider = null) Parameters rootObject object The root object being validated. serviceProvider IServiceProvider The service provider for dependency injection. Returns IValidationContext A new ValidationContext instance with the specified root object and service provider. Examples User user = new UserBuilder().Build(); IValidationContext context = ValidationContext.Create(user, serviceProvider); CreateChildContext(object, string?) Creates a child validation context for nested object validation. public IValidationContext CreateChildContext(object childObject, string? propertyName = null) Parameters childObject object The child object being validated. propertyName string The name of the property containing the child object. Returns IValidationContext A new validation context that inherits from the current context. Examples IValidationContext childContext = parentContext.CreateChildContext(user.Profile, \"Profile\"); // Child context has access to parent's custom data and services Remarks Child contexts inherit custom data and service providers from their parent context, enabling consistent validation behavior across nested object hierarchies. GetCurrentPropertyPath() Gets the current property path being validated. public string GetCurrentPropertyPath() Returns string The full property path from the root object to the current property being validated. Examples string path = context.GetCurrentPropertyPath(); // Returns \"User.Profile.Bio\" Remarks Property paths use dot notation for nested properties (e.g., \"User.Profile.Bio\") and bracket notation for collection indices (e.g., \"User.Roles[0].Name\"). GetCustomData<T>(string) Gets custom data from the validation context. public T? GetCustomData<T>(string key) Parameters key string The key identifying the data. Returns T The data value cast to type T, or the default value of T if the key is not found or cannot be cast. Type Parameters T The type of data to retrieve. Examples int maxAge = context.GetCustomData<int>(\"MaxAllowedAge\"); User? dbUser = context.GetCustomData<User>(\"DatabaseUser\"); GetExecutedRules() Gets a read-only list of validation rules that have been executed in this context. public IReadOnlyList<string> GetExecutedRules() Returns IReadOnlyList<string> A list of rule identifiers representing the validation rules that have been executed. Examples IReadOnlyList<string> executedRules = context.GetExecutedRules(); bool nameValidated = executedRules.Any(rule => rule.Contains(\"Name.NotEmpty\")); Remarks Rule execution tracking enables conditional validation logic where the execution of subsequent rules can depend on which previous rules have been executed and their results. GetRootObject<T>() Gets the root object being validated as the specified type. public T? GetRootObject<T>() where T : class Returns T The root object cast to type T, or null if the root object is null or not of type T. Type Parameters T The type to cast the root object to. Examples User? user = context.GetRootObject<User>(); if (user != null) { // Access user properties for validation logic return someProperty != user.SomeOtherProperty; } GetService<T>() Gets a service of the specified type from the service provider. public T? GetService<T>() where T : class Returns T The service instance if found, or null if the service is not available or no service provider exists. Type Parameters T The type of service to retrieve. Examples IEmailValidationService? emailService = context.GetService<IEmailValidationService>(); if (emailService != null) { return await emailService.IsValidEmailAsync(email); } HasCustomData(string) Determines whether the validation context contains custom data with the specified key. public bool HasCustomData(string key) Parameters key string The key to check for. Returns bool true if the context contains data with the specified key; otherwise, false. RecordRuleExecution(string, string, bool) Records that a validation rule has been executed. public void RecordRuleExecution(string ruleIdentifier, string propertyName, bool success) Parameters ruleIdentifier string A unique identifier for the validation rule. propertyName string The name of the property being validated. success bool Whether the validation rule passed or failed. Remarks This method is typically called internally by the validation framework to track rule execution for conditional validation scenarios. RemoveCustomData(string) Removes custom data from the validation context. public bool RemoveCustomData(string key) Parameters key string The key identifying the data to remove. Returns bool true if the data was found and removed; otherwise, false. SetCustomData(string, object) Sets custom data in the validation context. public void SetCustomData(string key, object value) Parameters key string The key to identify the data. value object The value to store. Examples context.SetCustomData(\"DatabaseUser\", currentUser); context.SetCustomData(\"MaxAllowedAge\", 65); Remarks Custom data is stored for the lifetime of the validation context and can be accessed by any validation rule within the same validation session."
  },
  "api/FlowRight.Validation.Context.html": {
    "href": "api/FlowRight.Validation.Context.html",
    "title": "Namespace FlowRight.Validation.Context | FlowRight - Result Pattern Library for .NET",
    "summary": "Namespace FlowRight.Validation.Context Classes ValidationContext Concrete implementation of IValidationContext that provides comprehensive validation context for complex validation scenarios with object access, service integration, custom data storage, and hierarchical validation support. Interfaces IValidationContext Provides validation context for complex validation scenarios, enabling access to parent objects, services, custom data storage, and hierarchical validation support."
  },
  "api/FlowRight.Validation.Rules.AlphaNumericDashRule.html": {
    "href": "api/FlowRight.Validation.Rules.AlphaNumericDashRule.html",
    "title": "Class AlphaNumericDashRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class AlphaNumericDashRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value contains only alphanumeric characters and dashes. public sealed class AlphaNumericDashRule : IRule<string> Inheritance object AlphaNumericDashRule Implements IRule<string> Methods Validate(string, string) Validates that the string value contains only alphanumeric characters and dashes. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value contains invalid characters; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.AlphaNumericRule.html": {
    "href": "api/FlowRight.Validation.Rules.AlphaNumericRule.html",
    "title": "Class AlphaNumericRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class AlphaNumericRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value contains only alphanumeric characters. public sealed class AlphaNumericRule : IRule<string> Inheritance object AlphaNumericRule Implements IRule<string> Methods Validate(string, string) Validates that the string value contains only alphanumeric characters (letters and digits). public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value contains non-alphanumeric characters; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.AlphaNumericSpaceRule.html": {
    "href": "api/FlowRight.Validation.Rules.AlphaNumericSpaceRule.html",
    "title": "Class AlphaNumericSpaceRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class AlphaNumericSpaceRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value contains only alphanumeric characters and spaces. public sealed class AlphaNumericSpaceRule : IRule<string> Inheritance object AlphaNumericSpaceRule Implements IRule<string> Methods Validate(string, string) Validates that the string value contains only alphanumeric characters and spaces. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value contains invalid characters; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.AlphaRule.html": {
    "href": "api/FlowRight.Validation.Rules.AlphaRule.html",
    "title": "Class AlphaRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class AlphaRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value contains only alphabetic characters. public sealed class AlphaRule : IRule<string> Inheritance object AlphaRule Implements IRule<string> Methods Validate(string, string) Validates that the string value contains only alphabetic characters (letters). public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value contains non-alphabetic characters; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.BetweenRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.BetweenRule-1.html",
    "title": "Class BetweenRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class BetweenRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is between two bounds (inclusive). This is an alias for InclusiveBetweenRule for backward compatibility and intuitive naming. public sealed class BetweenRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object BetweenRule<T> Implements IRule<T> Constructors BetweenRule(T, T) A validation rule that ensures a value is between two bounds (inclusive). This is an alias for InclusiveBetweenRule for backward compatibility and intuitive naming. public BetweenRule(T from, T to) Parameters from T The lower bound (inclusive). to T The upper bound (inclusive). Methods Validate(T, string) Validates that the value is between the bounds (inclusive). public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not between the bounds; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.ContainsItemRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.ContainsItemRule-1.html",
    "title": "Class ContainsItemRule<TItem> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ContainsItemRule<TItem> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a collection contains a specific item. public sealed class ContainsItemRule<TItem> : IRule<IEnumerable<TItem>> Type Parameters TItem The type of items in the collection. Inheritance object ContainsItemRule<TItem> Implements IRule<IEnumerable<TItem>> Constructors ContainsItemRule(TItem) A validation rule that ensures a collection contains a specific item. public ContainsItemRule(TItem expectedItem) Parameters expectedItem TItem The item that must be present in the collection. Methods Validate(IEnumerable<TItem>, string) Validates that the collection contains the expected item. public string? Validate(IEnumerable<TItem> value, string displayName) Parameters value IEnumerable<TItem> The collection to validate. displayName string The display name for the property being validated. Returns string An error message if the collection does not contain the expected item; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.ContainsRule.html": {
    "href": "api/FlowRight.Validation.Rules.ContainsRule.html",
    "title": "Class ContainsRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ContainsRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value contains a specified substring. public sealed class ContainsRule : IRule<string> Inheritance object ContainsRule Implements IRule<string> Constructors ContainsRule(string, StringComparison) Initializes a new instance of the ContainsRule with the specified substring and comparison type. public ContainsRule(string substring, StringComparison comparison = StringComparison.Ordinal) Parameters substring string The substring that must be contained in the value. comparison StringComparison The string comparison type to use. Methods Validate(string, string) Validates that the string value contains the specified substring. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value does not contain the substring; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.CountRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.CountRule-1.html",
    "title": "Class CountRule<TItem> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class CountRule<TItem> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a collection contains an exact number of items. public sealed class CountRule<TItem> : IRule<IEnumerable<TItem>> Type Parameters TItem The type of items in the collection. Inheritance object CountRule<TItem> Implements IRule<IEnumerable<TItem>> Constructors CountRule(int) A validation rule that ensures a collection contains an exact number of items. public CountRule(int expectedCount) Parameters expectedCount int The exact number of items the collection must contain. Methods Validate(IEnumerable<TItem>, string) Validates that the collection contains exactly the expected number of items. public string? Validate(IEnumerable<TItem> value, string displayName) Parameters value IEnumerable<TItem> The collection to validate. displayName string The display name for the property being validated. Returns string An error message if the collection does not contain the expected count; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.CreditCardRule.html": {
    "href": "api/FlowRight.Validation.Rules.CreditCardRule.html",
    "title": "Class CreditCardRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class CreditCardRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that validates credit card numbers using the Luhn algorithm. public sealed class CreditCardRule : IRule<string> Inheritance object CreditCardRule Implements IRule<string> Methods Validate(string, string) Validates that the string value is a valid credit card number using the Luhn algorithm. public string? Validate(string value, string displayName) Parameters value string The credit card number to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not a valid credit card number; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.EachRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.EachRule-1.html",
    "title": "Class EachRule<TItem> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class EachRule<TItem> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that validates each item in a collection using a nested validation rule. public sealed class EachRule<TItem> : IRule<IEnumerable<TItem>> Type Parameters TItem The type of items in the collection. Inheritance object EachRule<TItem> Implements IRule<IEnumerable<TItem>> Constructors EachRule(IRule<TItem>) A validation rule that validates each item in a collection using a nested validation rule. public EachRule(IRule<TItem> nestedRule) Parameters nestedRule IRule<TItem> The rule to apply to each item in the collection. Methods Validate(IEnumerable<TItem>, string) Validates each item in the collection using the nested rule. public string? Validate(IEnumerable<TItem> value, string displayName) Parameters value IEnumerable<TItem> The collection to validate. displayName string The display name for the property being validated. Returns string An error message if any item fails validation; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.EmailRule.html": {
    "href": "api/FlowRight.Validation.Rules.EmailRule.html",
    "title": "Class EmailRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class EmailRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value is a valid email address format. public class EmailRule : IRule<string> Inheritance object EmailRule Implements IRule<string> Methods Validate(string, string) Validates that the string value is a valid email address format. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not a valid email format; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.EmptyRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.EmptyRule-1.html",
    "title": "Class EmptyRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class EmptyRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is empty or in its default state. public sealed class EmptyRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object EmptyRule<T> Implements IRule<T> Methods Validate(T, string) Validates that the value is empty or in its default state. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not empty; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.EndsWithRule.html": {
    "href": "api/FlowRight.Validation.Rules.EndsWithRule.html",
    "title": "Class EndsWithRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class EndsWithRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value ends with a specified suffix. public sealed class EndsWithRule : IRule<string> Inheritance object EndsWithRule Implements IRule<string> Constructors EndsWithRule(string, StringComparison) Initializes a new instance of the EndsWithRule with the specified suffix and comparison type. public EndsWithRule(string suffix, StringComparison comparison = StringComparison.Ordinal) Parameters suffix string The suffix that the value must end with. comparison StringComparison The string comparison type to use. Methods Validate(string, string) Validates that the string value ends with the specified suffix. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value does not end with the suffix; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.EqualRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.EqualRule-1.html",
    "title": "Class EqualRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class EqualRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is equal to a specified comparison value. public sealed class EqualRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object EqualRule<T> Implements IRule<T> Constructors EqualRule(T, IEqualityComparer<T>?) A validation rule that ensures a value is equal to a specified comparison value. public EqualRule(T comparisonValue, IEqualityComparer<T>? comparer = null) Parameters comparisonValue T The value to compare against. comparer IEqualityComparer<T> Optional equality comparer to use for comparison. Methods Validate(T, string) Validates that the value equals the comparison value. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the values are not equal; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.EqualToRule.html": {
    "href": "api/FlowRight.Validation.Rules.EqualToRule.html",
    "title": "Class EqualToRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class EqualToRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value is equal to a specific expected value. public sealed class EqualToRule : IRule<string> Inheritance object EqualToRule Implements IRule<string> Constructors EqualToRule(string) A validation rule that ensures a string value is equal to a specific expected value. public EqualToRule(string expectedValue) Parameters expectedValue string The expected string value. Methods Validate(string, string) Validates that the string value is equal to the expected value. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not equal to the expected value; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.ExactLengthRule.html": {
    "href": "api/FlowRight.Validation.Rules.ExactLengthRule.html",
    "title": "Class ExactLengthRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ExactLengthRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string has an exact specified length. public sealed class ExactLengthRule : IRule<string> Inheritance object ExactLengthRule Implements IRule<string> Constructors ExactLengthRule(int) A validation rule that ensures a string has an exact specified length. public ExactLengthRule(int length) Parameters length int The exact length the string must have. Methods Validate(string, string) Validates that the string has the exact specified length. public string? Validate(string value, string displayName) Parameters value string The string to validate. displayName string The display name for the property being validated. Returns string An error message if the string length does not match; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.ExclusiveBetweenRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.ExclusiveBetweenRule-1.html",
    "title": "Class ExclusiveBetweenRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ExclusiveBetweenRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is between two bounds (exclusive). public sealed class ExclusiveBetweenRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object ExclusiveBetweenRule<T> Implements IRule<T> Constructors ExclusiveBetweenRule(T, T) A validation rule that ensures a value is between two bounds (exclusive). public ExclusiveBetweenRule(T from, T to) Parameters from T The lower bound (exclusive). to T The upper bound (exclusive). Methods Validate(T, string) Validates that the value is between the bounds (exclusive). public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not between the bounds; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.GreaterThanOrEqualToRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.GreaterThanOrEqualToRule-1.html",
    "title": "Class GreaterThanOrEqualToRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class GreaterThanOrEqualToRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is greater than or equal to a specified comparison value. public sealed class GreaterThanOrEqualToRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object GreaterThanOrEqualToRule<T> Implements IRule<T> Constructors GreaterThanOrEqualToRule(T) A validation rule that ensures a value is greater than or equal to a specified comparison value. public GreaterThanOrEqualToRule(T valueToCompare) Parameters valueToCompare T The value to compare against. Methods Validate(T, string) Validates that the value is greater than or equal to the comparison value. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is less than the comparison value; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.GreaterThanRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.GreaterThanRule-1.html",
    "title": "Class GreaterThanRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class GreaterThanRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is greater than a specified comparison value. public sealed class GreaterThanRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object GreaterThanRule<T> Implements IRule<T> Constructors GreaterThanRule(T) A validation rule that ensures a value is greater than a specified comparison value. public GreaterThanRule(T valueToCompare) Parameters valueToCompare T The value to compare against. Methods Validate(T, string) Validates that the value is greater than the comparison value. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not greater than the comparison value; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.GuidNonZeroTimestampRule.html": {
    "href": "api/FlowRight.Validation.Rules.GuidNonZeroTimestampRule.html",
    "title": "Class GuidNonZeroTimestampRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class GuidNonZeroTimestampRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll Validation rule that ensures a GUID has non-zero timestamp bits, indicating it was not created at epoch time. This can help identify potentially invalid or placeholder GUIDs that may have been generated incorrectly. public sealed class GuidNonZeroTimestampRule : IRule<Guid?> Inheritance object GuidNonZeroTimestampRule Implements IRule<Guid?> Examples // Valid GUID with non-zero timestamp rule.Validate(Guid.NewGuid(), \"ID\") // Returns null (valid) // Invalid GUID with all-zero timestamp (very unlikely in practice) rule.Validate(someEpochGuid, \"ID\") // Returns \"ID must have a valid timestamp component\" // Null GUID rule.Validate(null, \"ID\") // Returns \"ID must have a valid timestamp component\" Methods Validate(Guid?, string) Validates the specified value and returns an error message if validation fails. public string? Validate(Guid? value, string displayName) Parameters value Guid? The value to validate. displayName string The display name for the property being validated, used in error messages. Returns string An error message if validation fails; otherwise, null indicating validation passed."
  },
  "api/FlowRight.Validation.Rules.GuidNotEmptyRule.html": {
    "href": "api/FlowRight.Validation.Rules.GuidNotEmptyRule.html",
    "title": "Class GuidNotEmptyRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class GuidNotEmptyRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll Validation rule that ensures a GUID is not the empty GUID (00000000-0000-0000-0000-000000000000). This provides a more semantic alternative to NotEqual(Guid.Empty) for GUID-specific validation. public sealed class GuidNotEmptyRule : IRule<Guid?> Inheritance object GuidNotEmptyRule Implements IRule<Guid?> Examples // Valid non-empty GUID rule.Validate(Guid.NewGuid(), \"ID\") // Returns null (valid) // Invalid empty GUID rule.Validate(Guid.Empty, \"ID\") // Returns \"ID cannot be empty\" // Null GUID rule.Validate(null, \"ID\") // Returns \"ID cannot be empty\" Methods Validate(Guid?, string) Validates the specified value and returns an error message if validation fails. public string? Validate(Guid? value, string displayName) Parameters value Guid? The value to validate. displayName string The display name for the property being validated, used in error messages. Returns string An error message if validation fails; otherwise, null indicating validation passed."
  },
  "api/FlowRight.Validation.Rules.GuidValidFormatRule.html": {
    "href": "api/FlowRight.Validation.Rules.GuidValidFormatRule.html",
    "title": "Class GuidValidFormatRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class GuidValidFormatRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll Validation rule that ensures a GUID follows the standard hyphenated format (8-4-4-4-12 characters). This validates the string representation of the GUID is properly formatted. public sealed class GuidValidFormatRule : IRule<Guid?> Inheritance object GuidValidFormatRule Implements IRule<Guid?> Examples // Valid format rule.Validate(Guid.Parse(\"f47ac10b-58cc-4372-a567-0e02b2c3d479\"), \"ID\") // Returns null (valid) // Any valid GUID should pass this rule as System.Guid ensures valid format rule.Validate(Guid.NewGuid(), \"ID\") // Returns null (valid) // Null GUID rule.Validate(null, \"ID\") // Returns \"ID must be in valid GUID format\" Methods Validate(Guid?, string) Validates the specified value and returns an error message if validation fails. public string? Validate(Guid? value, string displayName) Parameters value Guid? The value to validate. displayName string The display name for the property being validated, used in error messages. Returns string An error message if validation fails; otherwise, null indicating validation passed."
  },
  "api/FlowRight.Validation.Rules.IAsyncContextAwareRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.IAsyncContextAwareRule-1.html",
    "title": "Interface IAsyncContextAwareRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Interface IAsyncContextAwareRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll Defines an asynchronous validation rule that can access validation context for complex validation scenarios. This interface enables context-aware validation with async operations such as database lookups or web service calls. public interface IAsyncContextAwareRule<in T> Type Parameters T The type of value this rule can validate. Examples public class UniqueEmailRule : IAsyncContextAwareRule<string> { public async Task<string?> ValidateAsync(string email, string displayName, IValidationContext context) { IUserRepository? repository = context.GetService<IUserRepository>(); if (repository != null) { bool exists = await repository.EmailExistsAsync(email); if (exists) { return \"Email address is already in use\"; } } return null; // Validation passed } } Remarks Async context-aware rules enable advanced validation scenarios that require: Asynchronous operations such as database queries or web service calls Access to the root object being validated for cross-property validation Integration with external services through dependency injection Access to custom data shared between validation rules Hierarchical validation with parent-child relationships Conditional validation based on previously executed rules Async context-aware rules should be used when validation logic requires asynchronous operations and information beyond the single property value being validated. For simple synchronous validation, use IContextAwareRule<T> or IRule<T> interfaces. Methods ValidateAsync(T, string, IValidationContext) Asynchronously validates the specified value with access to validation context and returns an error message if validation fails. Task<string?> ValidateAsync(T value, string displayName, IValidationContext context) Parameters value T The value to validate. displayName string The display name for the property being validated, used in error messages. context IValidationContext The validation context providing access to root object, services, and custom data. Returns Task<string> A task that represents the asynchronous validation operation. The task result contains an error message if validation fails; otherwise, null indicating validation passed. Examples public async Task<string?> ValidateAsync(string value, string displayName, IValidationContext context) { // Access services for async external validation IEmailValidationService? emailService = context.GetService<IEmailValidationService>(); if (emailService != null) { bool isValid = await emailService.ValidateEmailAsync(value); if (!isValid) { return $\"{displayName} failed external validation\"; } } // Access custom data for configuration int maxRetries = context.GetCustomData<int>(\"MaxRetries\"); return null; // Validation passed } Remarks This method provides full access to the validation context and supports asynchronous operations, enabling complex validation scenarios that require external data access or web service calls. The context parameter should not be null when called by the validation framework."
  },
  "api/FlowRight.Validation.Rules.IContextAwareRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.IContextAwareRule-1.html",
    "title": "Interface IContextAwareRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Interface IContextAwareRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll Defines a validation rule that can access validation context for complex validation scenarios. This interface extends the basic IRule functionality to enable context-aware validation. public interface IContextAwareRule<in T> : IRule<T> Type Parameters T The type of value this rule can validate. Inherited Members IRule<T>.Validate(T, string) Examples public class EmailMustMatchUserNameRule : IContextAwareRule<string> { public string? Validate(string email, string displayName, IValidationContext context) { User? user = context.GetRootObject<User>(); if (user != null && !email.StartsWith(user.UserName)) { return \"Email must start with username\"; } return null; // Validation passed } } Remarks Context-aware rules enable advanced validation scenarios that require: Access to the root object being validated for cross-property validation Integration with external services through dependency injection Access to custom data shared between validation rules Hierarchical validation with parent-child relationships Conditional validation based on previously executed rules Context-aware rules should be used when validation logic requires information beyond the single property value being validated. For simple property-only validation, the standard IRule<T> interface is more appropriate. Methods Validate(T, string, IValidationContext) Validates the specified value with access to validation context and returns an error message if validation fails. string? Validate(T value, string displayName, IValidationContext context) Parameters value T The value to validate. displayName string The display name for the property being validated, used in error messages. context IValidationContext The validation context providing access to root object, services, and custom data. Returns string An error message if validation fails; otherwise, null indicating validation passed. Examples public string? Validate(string value, string displayName, IValidationContext context) { // Access root object for cross-property validation User? rootUser = context.GetRootObject<User>(); // Access services for external validation IEmailService? emailService = context.GetService<IEmailService>(); // Access custom data for shared state bool strictMode = context.GetCustomData<bool>(\"StrictValidation\"); // Perform context-aware validation logic return ValidateWithContext(value, rootUser, emailService, strictMode); } Remarks This method provides full access to the validation context, enabling complex validation scenarios that require information beyond the single property value. The context parameter should not be null when called by the validation framework."
  },
  "api/FlowRight.Validation.Rules.IRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.IRule-1.html",
    "title": "Interface IRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Interface IRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll Defines a validation rule that can be applied to values of type T, providing error messages when validation fails. public interface IRule<in T> Type Parameters T The type of value this rule can validate. Methods Validate(T, string) Validates the specified value and returns an error message if validation fails. string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated, used in error messages. Returns string An error message if validation fails; otherwise, null indicating validation passed."
  },
  "api/FlowRight.Validation.Rules.InclusiveBetweenRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.InclusiveBetweenRule-1.html",
    "title": "Class InclusiveBetweenRule<TNumeric> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class InclusiveBetweenRule<TNumeric> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a numeric value is between two bounds (inclusive). public sealed class InclusiveBetweenRule<TNumeric> : IRule<TNumeric> where TNumeric : struct, INumber<TNumeric> Type Parameters TNumeric The numeric type being validated (int, long, decimal, double, float, short, etc.). Inheritance object InclusiveBetweenRule<TNumeric> Implements IRule<TNumeric> Constructors InclusiveBetweenRule(TNumeric, TNumeric) A validation rule that ensures a numeric value is between two bounds (inclusive). public InclusiveBetweenRule(TNumeric from, TNumeric to) Parameters from TNumeric The lower bound (inclusive). to TNumeric The upper bound (inclusive). Methods Validate(TNumeric, string) Validates that the numeric value is between the bounds (inclusive). public string? Validate(TNumeric value, string displayName) Parameters value TNumeric The numeric value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not between the bounds; otherwise, null. Examples // Integer validation InclusiveBetweenRule<int> intRule = new(1, 10); string? error = intRule.Validate(5, \"Age\"); // Returns null (valid) string? error2 = intRule.Validate(15, \"Age\"); // Returns error message // Decimal validation InclusiveBetweenRule<decimal> decimalRule = new(0.0m, 100.0m); string? error3 = decimalRule.Validate(50.5m, \"Percentage\"); // Returns null (valid)"
  },
  "api/FlowRight.Validation.Rules.InclusiveBetweenRule.html": {
    "href": "api/FlowRight.Validation.Rules.InclusiveBetweenRule.html",
    "title": "Class InclusiveBetweenRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class InclusiveBetweenRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures an integer value is between two bounds (inclusive). public sealed class InclusiveBetweenRule : IRule<int> Inheritance object InclusiveBetweenRule Implements IRule<int> Constructors InclusiveBetweenRule(int, int) A validation rule that ensures an integer value is between two bounds (inclusive). public InclusiveBetweenRule(int from, int to) Parameters from int The lower bound (inclusive). to int The upper bound (inclusive). Methods Validate(int, string) Validates that the integer value is between the bounds (inclusive). public string? Validate(int value, string displayName) Parameters value int The integer value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not between the bounds; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.LengthRule.html": {
    "href": "api/FlowRight.Validation.Rules.LengthRule.html",
    "title": "Class LengthRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class LengthRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string length is within specified bounds. public sealed class LengthRule : IRule<string> Inheritance object LengthRule Implements IRule<string> Constructors LengthRule(int, int) A validation rule that ensures a string length is within specified bounds. public LengthRule(int min, int max) Parameters min int The minimum allowed length. max int The maximum allowed length. Methods Validate(string, string) Validates that the string length is within the specified bounds. public string? Validate(string value, string displayName) Parameters value string The string to validate. displayName string The display name for the property being validated. Returns string An error message if the length is outside bounds; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.LessThanOrEqualToRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.LessThanOrEqualToRule-1.html",
    "title": "Class LessThanOrEqualToRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class LessThanOrEqualToRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is less than or equal to a specified comparison value. public sealed class LessThanOrEqualToRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object LessThanOrEqualToRule<T> Implements IRule<T> Constructors LessThanOrEqualToRule(T) A validation rule that ensures a value is less than or equal to a specified comparison value. public LessThanOrEqualToRule(T valueToCompare) Parameters valueToCompare T The value to compare against. Methods Validate(T, string) Validates that the value is less than or equal to the comparison value. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is greater than the comparison value; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.LessThanRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.LessThanRule-1.html",
    "title": "Class LessThanRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class LessThanRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is less than a specified comparison value. public sealed class LessThanRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object LessThanRule<T> Implements IRule<T> Constructors LessThanRule(T) A validation rule that ensures a value is less than a specified comparison value. public LessThanRule(T valueToCompare) Parameters valueToCompare T The value to compare against. Methods Validate(T, string) Validates that the value is less than the comparison value. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not less than the comparison value; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.LowerCaseRule.html": {
    "href": "api/FlowRight.Validation.Rules.LowerCaseRule.html",
    "title": "Class LowerCaseRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class LowerCaseRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value is in lowercase. public sealed class LowerCaseRule : IRule<string> Inheritance object LowerCaseRule Implements IRule<string> Methods Validate(string, string) Validates that the string value is in lowercase. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not in lowercase; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.MatchesRule.html": {
    "href": "api/FlowRight.Validation.Rules.MatchesRule.html",
    "title": "Class MatchesRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class MatchesRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value matches a specified regular expression pattern. public sealed class MatchesRule : IRule<string> Inheritance object MatchesRule Implements IRule<string> Constructors MatchesRule(string, RegexOptions) Initializes a new instance of the MatchesRule with a pattern and options. public MatchesRule(string pattern, RegexOptions options = RegexOptions.None) Parameters pattern string The regular expression pattern. options RegexOptions Optional regex options. MatchesRule(Regex) Initializes a new instance of the MatchesRule with a compiled regex. public MatchesRule(Regex regex) Parameters regex Regex The compiled regular expression. Methods Validate(string, string) Validates that the string value matches the regular expression pattern. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value does not match the pattern; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.MaxCountRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.MaxCountRule-1.html",
    "title": "Class MaxCountRule<TItem> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class MaxCountRule<TItem> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a collection contains at most a specified number of items. public sealed class MaxCountRule<TItem> : IRule<IEnumerable<TItem>> Type Parameters TItem The type of items in the collection. Inheritance object MaxCountRule<TItem> Implements IRule<IEnumerable<TItem>> Constructors MaxCountRule(int) A validation rule that ensures a collection contains at most a specified number of items. public MaxCountRule(int maxCount) Parameters maxCount int The maximum number of items allowed. Methods Validate(IEnumerable<TItem>, string) Validates that the collection contains at most the maximum number of items. public string? Validate(IEnumerable<TItem> value, string displayName) Parameters value IEnumerable<TItem> The collection to validate. displayName string The display name for the property being validated. Returns string An error message if the collection exceeds the maximum count; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.MaxLengthRule.html": {
    "href": "api/FlowRight.Validation.Rules.MaxLengthRule.html",
    "title": "Class MaxLengthRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class MaxLengthRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string does not exceed a specified maximum length. public sealed class MaxLengthRule : IRule<string> Inheritance object MaxLengthRule Implements IRule<string> Constructors MaxLengthRule(int) A validation rule that ensures a string does not exceed a specified maximum length. public MaxLengthRule(int maxLength) Parameters maxLength int The maximum allowed length. Methods Validate(string, string) Validates that the string does not exceed the maximum length. public string? Validate(string value, string displayName) Parameters value string The string to validate. displayName string The display name for the property being validated. Returns string An error message if the string exceeds the maximum length; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.MinCountRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.MinCountRule-1.html",
    "title": "Class MinCountRule<TItem> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class MinCountRule<TItem> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a collection contains at least a specified number of items. public sealed class MinCountRule<TItem> : IRule<IEnumerable<TItem>> Type Parameters TItem The type of items in the collection. Inheritance object MinCountRule<TItem> Implements IRule<IEnumerable<TItem>> Constructors MinCountRule(int) A validation rule that ensures a collection contains at least a specified number of items. public MinCountRule(int minCount) Parameters minCount int The minimum number of items required. Methods Validate(IEnumerable<TItem>, string) Validates that the collection contains at least the minimum number of items. public string? Validate(IEnumerable<TItem> value, string displayName) Parameters value IEnumerable<TItem> The collection to validate. displayName string The display name for the property being validated. Returns string An error message if the collection has fewer than the minimum count; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.MinLengthRule.html": {
    "href": "api/FlowRight.Validation.Rules.MinLengthRule.html",
    "title": "Class MinLengthRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class MinLengthRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string meets a minimum length requirement. public sealed class MinLengthRule : IRule<string> Inheritance object MinLengthRule Implements IRule<string> Constructors MinLengthRule(int) A validation rule that ensures a string meets a minimum length requirement. public MinLengthRule(int minLength) Parameters minLength int The minimum required length. Methods Validate(string, string) Validates that the string meets the minimum length requirement. public string? Validate(string value, string displayName) Parameters value string The string to validate. displayName string The display name for the property being validated. Returns string An error message if the string is shorter than the minimum length; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.MustAsyncContextAwareRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.MustAsyncContextAwareRule-1.html",
    "title": "Class MustAsyncContextAwareRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class MustAsyncContextAwareRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll An asynchronous context-aware validation rule that applies a custom condition function with access to validation context. This rule enables complex validation scenarios that require async operations and access to root objects, services, or custom data. public sealed class MustAsyncContextAwareRule<T> : IAsyncContextAwareRule<T> Type Parameters T The type of value to validate. Inheritance object MustAsyncContextAwareRule<T> Implements IAsyncContextAwareRule<T> Examples // Async database validation with context var rule = new MustAsyncContextAwareRule<string>( async (email, context) => { IUserRepository? repository = context.GetService<IUserRepository>(); if (repository != null) { return !await repository.EmailExistsAsync(email); } return false; }, \"Email address is already in use\"); // Async web service validation with cross-property check var serviceRule = new MustAsyncContextAwareRule<string>( async (value, context) => { User? user = context.GetRootObject<User>(); IValidationService? service = context.GetService<IValidationService>(); if (user != null && service != null) { return await service.ValidateWithUserContextAsync(value, user.Id); } return false; }, \"Value failed external validation service\"); // Async validation with custom data and retry logic var retryRule = new MustAsyncContextAwareRule<string>( async (value, context) => { int maxRetries = context.GetCustomData<int>(\"MaxRetries\"); IExternalService? service = context.GetService<IExternalService>(); for (int i = 0; i <= maxRetries; i++) { try { return await service?.ValidateAsync(value) ?? false; } catch when (i < maxRetries) { await Task.Delay(TimeSpan.FromMilliseconds(100 * (i + 1))); } } return false; }, \"External validation failed after retries\"); Remarks This rule extends validation capabilities to support asynchronous operations while providing access to the validation context. It enables validation logic that depends on: Asynchronous database queries or web service calls Other properties of the root object being validated External services accessed through dependency injection Custom data shared between validation rules Parent-child relationships in hierarchical validation Previously executed validation rules and their results The condition function should return true if the validation passes, or false if it fails. When the condition returns false, the specified error message will be used as the validation error. Constructors MustAsyncContextAwareRule(Func<T, IValidationContext, Task<bool>>, string) An asynchronous context-aware validation rule that applies a custom condition function with access to validation context. This rule enables complex validation scenarios that require async operations and access to root objects, services, or custom data. public MustAsyncContextAwareRule(Func<T, IValidationContext, Task<bool>> condition, string errorMessage) Parameters condition Func<T, IValidationContext, Task<bool>> The async condition function that receives both the value and validation context. errorMessage string The error message to return when validation fails. Examples // Async database validation with context var rule = new MustAsyncContextAwareRule<string>( async (email, context) => { IUserRepository? repository = context.GetService<IUserRepository>(); if (repository != null) { return !await repository.EmailExistsAsync(email); } return false; }, \"Email address is already in use\"); // Async web service validation with cross-property check var serviceRule = new MustAsyncContextAwareRule<string>( async (value, context) => { User? user = context.GetRootObject<User>(); IValidationService? service = context.GetService<IValidationService>(); if (user != null && service != null) { return await service.ValidateWithUserContextAsync(value, user.Id); } return false; }, \"Value failed external validation service\"); // Async validation with custom data and retry logic var retryRule = new MustAsyncContextAwareRule<string>( async (value, context) => { int maxRetries = context.GetCustomData<int>(\"MaxRetries\"); IExternalService? service = context.GetService<IExternalService>(); for (int i = 0; i <= maxRetries; i++) { try { return await service?.ValidateAsync(value) ?? false; } catch when (i < maxRetries) { await Task.Delay(TimeSpan.FromMilliseconds(100 * (i + 1))); } } return false; }, \"External validation failed after retries\"); Remarks This rule extends validation capabilities to support asynchronous operations while providing access to the validation context. It enables validation logic that depends on: Asynchronous database queries or web service calls Other properties of the root object being validated External services accessed through dependency injection Custom data shared between validation rules Parent-child relationships in hierarchical validation Previously executed validation rules and their results The condition function should return true if the validation passes, or false if it fails. When the condition returns false, the specified error message will be used as the validation error. Methods ValidateAsync(T, string, IValidationContext) Asynchronously validates the value using the custom condition function with access to validation context. public Task<string?> ValidateAsync(T value, string displayName, IValidationContext context) Parameters value T The value to validate. displayName string The display name for the property being validated. context IValidationContext The validation context providing access to root object, services, and custom data. Returns Task<string> A task that represents the asynchronous validation operation. The task result contains an error message if validation fails; otherwise, null indicating validation passed."
  },
  "api/FlowRight.Validation.Rules.MustContextAwareRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.MustContextAwareRule-1.html",
    "title": "Class MustContextAwareRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class MustContextAwareRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A context-aware validation rule that applies a custom condition function with access to validation context. This rule enables complex validation scenarios that require access to root objects, services, or custom data. public sealed class MustContextAwareRule<T> : IContextAwareRule<T>, IRule<T> Type Parameters T The type of value to validate. Inheritance object MustContextAwareRule<T> Implements IContextAwareRule<T> IRule<T> Examples // Cross-property validation using root object var rule = new MustContextAwareRule<string>( (email, context) => { User? user = context.GetRootObject<User>(); return user == null || !string.Equals(email, user.Username, StringComparison.OrdinalIgnoreCase); }, \"Email cannot be the same as username\"); // Service integration validation var serviceRule = new MustContextAwareRule<string>( (value, context) => { IValidationService? service = context.GetService<IValidationService>(); return service?.IsValid(value) ?? false; }, \"Value failed service validation\"); // Custom data validation var dataRule = new MustContextAwareRule<int>( (age, context) => { int maxAge = context.GetCustomData<int>(\"MaxAllowedAge\"); return maxAge == 0 || age <= maxAge; }, \"Age exceeds maximum allowed limit\"); Remarks This rule extends the basic MustRule functionality to provide access to the validation context, enabling validation logic that depends on: Other properties of the root object being validated External services accessed through dependency injection Custom data shared between validation rules Parent-child relationships in hierarchical validation Previously executed validation rules and their results The condition function should return true if the validation passes, or false if it fails. When the condition returns false, the specified error message will be used as the validation error. Constructors MustContextAwareRule(Func<T, IValidationContext, bool>, string) A context-aware validation rule that applies a custom condition function with access to validation context. This rule enables complex validation scenarios that require access to root objects, services, or custom data. public MustContextAwareRule(Func<T, IValidationContext, bool> condition, string errorMessage) Parameters condition Func<T, IValidationContext, bool> The condition function that receives both the value and validation context. errorMessage string The error message to return when validation fails. Examples // Cross-property validation using root object var rule = new MustContextAwareRule<string>( (email, context) => { User? user = context.GetRootObject<User>(); return user == null || !string.Equals(email, user.Username, StringComparison.OrdinalIgnoreCase); }, \"Email cannot be the same as username\"); // Service integration validation var serviceRule = new MustContextAwareRule<string>( (value, context) => { IValidationService? service = context.GetService<IValidationService>(); return service?.IsValid(value) ?? false; }, \"Value failed service validation\"); // Custom data validation var dataRule = new MustContextAwareRule<int>( (age, context) => { int maxAge = context.GetCustomData<int>(\"MaxAllowedAge\"); return maxAge == 0 || age <= maxAge; }, \"Age exceeds maximum allowed limit\"); Remarks This rule extends the basic MustRule functionality to provide access to the validation context, enabling validation logic that depends on: Other properties of the root object being validated External services accessed through dependency injection Custom data shared between validation rules Parent-child relationships in hierarchical validation Previously executed validation rules and their results The condition function should return true if the validation passes, or false if it fails. When the condition returns false, the specified error message will be used as the validation error. Methods Validate(T, string) Validates the value using the standard IRule interface (without context). This implementation creates a minimal context for compatibility. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string The error message if validation fails; otherwise, null. Remarks This method provides fallback compatibility with the standard IRule interface. When called without a context, a minimal empty context is created, which may limit the functionality of context-dependent validation logic. Validate(T, string, IValidationContext) Validates the value using the custom condition function with access to validation context. public string? Validate(T value, string displayName, IValidationContext context) Parameters value T The value to validate. displayName string The display name for the property being validated. context IValidationContext The validation context providing access to root object, services, and custom data. Returns string The error message if the condition fails; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.MustRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.MustRule-1.html",
    "title": "Class MustRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class MustRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that applies a custom condition function to validate values. public sealed class MustRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object MustRule<T> Implements IRule<T> Constructors MustRule(Func<T, bool>, string) A validation rule that applies a custom condition function to validate values. public MustRule(Func<T, bool> condition, string errorMessage) Parameters condition Func<T, bool> The condition function to apply. errorMessage string The error message to return when validation fails. Methods Validate(T, string) Validates the value using the custom condition function. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string The error message if the condition fails; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.NegativeRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.NegativeRule-1.html",
    "title": "Class NegativeRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class NegativeRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a numeric value is negative (less than zero). public sealed class NegativeRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object NegativeRule<T> Implements IRule<T> Methods Validate(T, string) Validates that the numeric value is negative (less than zero). public string? Validate(T value, string displayName) Parameters value T The numeric value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not negative; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.NotEmptyRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.NotEmptyRule-1.html",
    "title": "Class NotEmptyRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class NotEmptyRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll Validation rule that ensures a value is not considered \"empty\" according to type-specific logic. Handles nulls, empty strings, default values, empty GUIDs, and empty collections. public sealed class NotEmptyRule<T> : IRule<T> Type Parameters T The type of value being validated. Inheritance object NotEmptyRule<T> Implements IRule<T> Examples // String validation rule.Validate(\"\", \"Name\") // Returns \"Name must not be empty\" rule.Validate(\" \", \"Name\") // Returns null (whitespace is not empty) rule.Validate(\"Value\", \"Name\") // Returns null (valid) // GUID validation rule.Validate(Guid.Empty, \"ID\") // Returns \"ID must not be empty\" rule.Validate(Guid.NewGuid(), \"ID\") // Returns null (valid) // Collection validation rule.Validate(new List<string>(), \"Items\") // Returns \"Items must not be empty\" rule.Validate(new[] { \"item\" }, \"Items\") // Returns null (valid) Methods Validate(T, string) Validates the specified value and returns an error message if validation fails. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated, used in error messages. Returns string An error message if validation fails; otherwise, null indicating validation passed."
  },
  "api/FlowRight.Validation.Rules.NotEqualRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.NotEqualRule-1.html",
    "title": "Class NotEqualRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class NotEqualRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is not equal to a specified comparison value. public sealed class NotEqualRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object NotEqualRule<T> Implements IRule<T> Constructors NotEqualRule(T, IEqualityComparer<T>?) A validation rule that ensures a value is not equal to a specified comparison value. public NotEqualRule(T comparisonValue, IEqualityComparer<T>? comparer = null) Parameters comparisonValue T The value to compare against. comparer IEqualityComparer<T> Optional equality comparer to use for comparison. Methods Validate(T, string) Validates that the value does not equal the comparison value. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the values are equal; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.NotNullRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.NotNullRule-1.html",
    "title": "Class NotNullRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class NotNullRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is not null. public sealed class NotNullRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object NotNullRule<T> Implements IRule<T> Methods Validate(T, string) Validates that the value is not null. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is null; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.NullRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.NullRule-1.html",
    "title": "Class NullRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class NullRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a value is null. public sealed class NullRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object NullRule<T> Implements IRule<T> Methods Validate(T, string) Validates that the value is null. public string? Validate(T value, string displayName) Parameters value T The value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not null; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.PhoneRule.html": {
    "href": "api/FlowRight.Validation.Rules.PhoneRule.html",
    "title": "Class PhoneRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class PhoneRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that validates phone numbers in various common formats. public sealed class PhoneRule : IRule<string> Inheritance object PhoneRule Implements IRule<string> Methods Validate(string, string) Validates that the string value is a valid phone number format. public string? Validate(string value, string displayName) Parameters value string The phone number to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not a valid phone number; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.PositiveRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.PositiveRule-1.html",
    "title": "Class PositiveRule<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class PositiveRule<T> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a numeric value is positive (greater than zero). public sealed class PositiveRule<T> : IRule<T> Type Parameters T The type of value to validate. Inheritance object PositiveRule<T> Implements IRule<T> Methods Validate(T, string) Validates that the numeric value is positive (greater than zero). public string? Validate(T value, string displayName) Parameters value T The numeric value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not positive; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.PostalCodeRule.html": {
    "href": "api/FlowRight.Validation.Rules.PostalCodeRule.html",
    "title": "Class PostalCodeRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class PostalCodeRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that validates postal codes for various countries (US ZIP, Canadian postal, UK postal codes). public sealed class PostalCodeRule : IRule<string> Inheritance object PostalCodeRule Implements IRule<string> Methods Validate(string, string) Validates that the string value is a valid postal code format (US ZIP, Canadian postal, or UK postal code). public string? Validate(string value, string displayName) Parameters value string The postal code to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not a valid postal code; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.PrecisionScaleRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.PrecisionScaleRule-1.html",
    "title": "Class PrecisionScaleRule<TNumeric> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class PrecisionScaleRule<TNumeric> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a numeric value meets precision and scale requirements. public sealed class PrecisionScaleRule<TNumeric> : IRule<TNumeric> where TNumeric : struct, INumber<TNumeric> Type Parameters TNumeric The numeric type to validate. Inheritance object PrecisionScaleRule<TNumeric> Implements IRule<TNumeric> Constructors PrecisionScaleRule(int, int) A validation rule that ensures a numeric value meets precision and scale requirements. public PrecisionScaleRule(int precision, int scale) Parameters precision int The maximum total number of digits. scale int The maximum number of decimal places. Methods Validate(TNumeric, string) Validates that the numeric value meets the precision and scale requirements. public string? Validate(TNumeric value, string displayName) Parameters value TNumeric The numeric value to validate. displayName string The display name for the property being validated. Returns string An error message if the value exceeds precision or scale limits; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.SpecificGuidValueRule.html": {
    "href": "api/FlowRight.Validation.Rules.SpecificGuidValueRule.html",
    "title": "Class SpecificGuidValueRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class SpecificGuidValueRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a GUID value matches a specific expected GUID. public sealed class SpecificGuidValueRule : IRule<Guid?> Inheritance object SpecificGuidValueRule Implements IRule<Guid?> Constructors SpecificGuidValueRule(Guid) A validation rule that ensures a GUID value matches a specific expected GUID. public SpecificGuidValueRule(Guid expectedGuid) Parameters expectedGuid Guid The expected GUID value. Methods Validate(Guid?, string) Validates that the GUID value matches the expected GUID. public string? Validate(Guid? value, string displayName) Parameters value Guid? The GUID value to validate. displayName string The display name for the property being validated. Returns string An error message if the value does not match the expected GUID; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.StartsWithRule.html": {
    "href": "api/FlowRight.Validation.Rules.StartsWithRule.html",
    "title": "Class StartsWithRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class StartsWithRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value starts with a specified prefix. public sealed class StartsWithRule : IRule<string> Inheritance object StartsWithRule Implements IRule<string> Constructors StartsWithRule(string, StringComparison) Initializes a new instance of the StartsWithRule with the specified prefix and comparison type. public StartsWithRule(string prefix, StringComparison comparison = StringComparison.Ordinal) Parameters prefix string The prefix that the value must start with. comparison StringComparison The string comparison type to use. Methods Validate(string, string) Validates that the string value starts with the specified prefix. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value does not start with the prefix; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.UniqueRule-1.html": {
    "href": "api/FlowRight.Validation.Rules.UniqueRule-1.html",
    "title": "Class UniqueRule<TItem> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class UniqueRule<TItem> Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures all items in a collection are unique. public sealed class UniqueRule<TItem> : IRule<IEnumerable<TItem>> Type Parameters TItem The type of items in the collection. Inheritance object UniqueRule<TItem> Implements IRule<IEnumerable<TItem>> Constructors UniqueRule(IEqualityComparer<TItem>?) A validation rule that ensures all items in a collection are unique. public UniqueRule(IEqualityComparer<TItem>? comparer = null) Parameters comparer IEqualityComparer<TItem> Optional equality comparer for determining uniqueness. Methods Validate(IEnumerable<TItem>, string) Validates that all items in the collection are unique. public string? Validate(IEnumerable<TItem> value, string displayName) Parameters value IEnumerable<TItem> The collection to validate. displayName string The display name for the property being validated. Returns string An error message if duplicate items are found; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.UpperCaseRule.html": {
    "href": "api/FlowRight.Validation.Rules.UpperCaseRule.html",
    "title": "Class UpperCaseRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class UpperCaseRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value is in uppercase. public sealed class UpperCaseRule : IRule<string> Inheritance object UpperCaseRule Implements IRule<string> Methods Validate(string, string) Validates that the string value is in uppercase. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not in uppercase; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.UrlRule.html": {
    "href": "api/FlowRight.Validation.Rules.UrlRule.html",
    "title": "Class UrlRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class UrlRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that ensures a string value is a valid URL format. public class UrlRule : IRule<string> Inheritance object UrlRule Implements IRule<string> Methods Validate(string, string) Validates that the string value is a valid URL format. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not a valid URL format; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.ValidGuidFormatRule.html": {
    "href": "api/FlowRight.Validation.Rules.ValidGuidFormatRule.html",
    "title": "Class ValidGuidFormatRule | FlowRight - Result Pattern Library for .NET",
    "summary": "Class ValidGuidFormatRule Namespace FlowRight.Validation.Rules Assembly FlowRight.Validation.dll A validation rule that validates a string is in a proper GUID format. public sealed class ValidGuidFormatRule : IRule<string> Inheritance object ValidGuidFormatRule Implements IRule<string> Methods Validate(string, string) Validates that the string value is in a valid GUID format. public string? Validate(string value, string displayName) Parameters value string The string value to validate. displayName string The display name for the property being validated. Returns string An error message if the value is not a valid GUID format; otherwise, null."
  },
  "api/FlowRight.Validation.Rules.html": {
    "href": "api/FlowRight.Validation.Rules.html",
    "title": "Namespace FlowRight.Validation.Rules | FlowRight - Result Pattern Library for .NET",
    "summary": "Namespace FlowRight.Validation.Rules Classes AlphaNumericDashRule A validation rule that ensures a string value contains only alphanumeric characters and dashes. AlphaNumericRule A validation rule that ensures a string value contains only alphanumeric characters. AlphaNumericSpaceRule A validation rule that ensures a string value contains only alphanumeric characters and spaces. AlphaRule A validation rule that ensures a string value contains only alphabetic characters. BetweenRule<T> A validation rule that ensures a value is between two bounds (inclusive). This is an alias for InclusiveBetweenRule for backward compatibility and intuitive naming. ContainsItemRule<TItem> A validation rule that ensures a collection contains a specific item. ContainsRule A validation rule that ensures a string value contains a specified substring. CountRule<TItem> A validation rule that ensures a collection contains an exact number of items. CreditCardRule A validation rule that validates credit card numbers using the Luhn algorithm. EachRule<TItem> A validation rule that validates each item in a collection using a nested validation rule. EmailRule A validation rule that ensures a string value is a valid email address format. EmptyRule<T> A validation rule that ensures a value is empty or in its default state. EndsWithRule A validation rule that ensures a string value ends with a specified suffix. EqualRule<T> A validation rule that ensures a value is equal to a specified comparison value. EqualToRule A validation rule that ensures a string value is equal to a specific expected value. ExactLengthRule A validation rule that ensures a string has an exact specified length. ExclusiveBetweenRule<T> A validation rule that ensures a value is between two bounds (exclusive). GreaterThanOrEqualToRule<T> A validation rule that ensures a value is greater than or equal to a specified comparison value. GreaterThanRule<T> A validation rule that ensures a value is greater than a specified comparison value. GuidNonZeroTimestampRule Validation rule that ensures a GUID has non-zero timestamp bits, indicating it was not created at epoch time. This can help identify potentially invalid or placeholder GUIDs that may have been generated incorrectly. GuidNotEmptyRule Validation rule that ensures a GUID is not the empty GUID (00000000-0000-0000-0000-000000000000). This provides a more semantic alternative to NotEqual(Guid.Empty) for GUID-specific validation. GuidValidFormatRule Validation rule that ensures a GUID follows the standard hyphenated format (8-4-4-4-12 characters). This validates the string representation of the GUID is properly formatted. InclusiveBetweenRule A validation rule that ensures an integer value is between two bounds (inclusive). InclusiveBetweenRule<TNumeric> A validation rule that ensures a numeric value is between two bounds (inclusive). LengthRule A validation rule that ensures a string length is within specified bounds. LessThanOrEqualToRule<T> A validation rule that ensures a value is less than or equal to a specified comparison value. LessThanRule<T> A validation rule that ensures a value is less than a specified comparison value. LowerCaseRule A validation rule that ensures a string value is in lowercase. MatchesRule A validation rule that ensures a string value matches a specified regular expression pattern. MaxCountRule<TItem> A validation rule that ensures a collection contains at most a specified number of items. MaxLengthRule A validation rule that ensures a string does not exceed a specified maximum length. MinCountRule<TItem> A validation rule that ensures a collection contains at least a specified number of items. MinLengthRule A validation rule that ensures a string meets a minimum length requirement. MustAsyncContextAwareRule<T> An asynchronous context-aware validation rule that applies a custom condition function with access to validation context. This rule enables complex validation scenarios that require async operations and access to root objects, services, or custom data. MustContextAwareRule<T> A context-aware validation rule that applies a custom condition function with access to validation context. This rule enables complex validation scenarios that require access to root objects, services, or custom data. MustRule<T> A validation rule that applies a custom condition function to validate values. NegativeRule<T> A validation rule that ensures a numeric value is negative (less than zero). NotEmptyRule<T> Validation rule that ensures a value is not considered \"empty\" according to type-specific logic. Handles nulls, empty strings, default values, empty GUIDs, and empty collections. NotEqualRule<T> A validation rule that ensures a value is not equal to a specified comparison value. NotNullRule<T> A validation rule that ensures a value is not null. NullRule<T> A validation rule that ensures a value is null. PhoneRule A validation rule that validates phone numbers in various common formats. PositiveRule<T> A validation rule that ensures a numeric value is positive (greater than zero). PostalCodeRule A validation rule that validates postal codes for various countries (US ZIP, Canadian postal, UK postal codes). PrecisionScaleRule<TNumeric> A validation rule that ensures a numeric value meets precision and scale requirements. SpecificGuidValueRule A validation rule that ensures a GUID value matches a specific expected GUID. StartsWithRule A validation rule that ensures a string value starts with a specified prefix. UniqueRule<TItem> A validation rule that ensures all items in a collection are unique. UpperCaseRule A validation rule that ensures a string value is in uppercase. UrlRule A validation rule that ensures a string value is a valid URL format. ValidGuidFormatRule A validation rule that validates a string is in a proper GUID format. Interfaces IAsyncContextAwareRule<T> Defines an asynchronous validation rule that can access validation context for complex validation scenarios. This interface enables context-aware validation with async operations such as database lookups or web service calls. IContextAwareRule<T> Defines a validation rule that can access validation context for complex validation scenarios. This interface extends the basic IRule functionality to enable context-aware validation. IRule<T> Defines a validation rule that can be applied to values of type T, providing error messages when validation fails."
  },
  "api/FlowRight.Validation.Validators.EnumerablePropertyValidator-2.html": {
    "href": "api/FlowRight.Validation.Validators.EnumerablePropertyValidator-2.html",
    "title": "Class EnumerablePropertyValidator<T, TItem> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class EnumerablePropertyValidator<T, TItem> Namespace FlowRight.Validation.Validators Assembly FlowRight.Validation.dll Provides validation rules for enumerable/collection properties with fluent configuration. public sealed class EnumerablePropertyValidator<T, TItem> : PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>> Type Parameters T The type containing the property being validated. TItem The type of items in the collection. Inheritance object PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>> EnumerablePropertyValidator<T, TItem> Inherited Members PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.Build(Func<T>) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.Empty() PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.Equal(IEnumerable<TItem>, IEqualityComparer<IEnumerable<TItem>>) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.Must(Func<IEnumerable<TItem>, bool>, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.NotEmpty() PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.NotEqual(IEnumerable<TItem>, IEqualityComparer<IEnumerable<TItem>>) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.NotNull() PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.Null() PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor<TDifferentProp>(Expression<Func<T, TDifferentProp>>, Result<TDifferentProp>, out TDifferentProp) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, string>>, string, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, Guid?>>, Guid?, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, int>>, int, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, long>>, long, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, decimal>>, decimal, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, double>>, double, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, float>>, float, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, short>>, short, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>>, IEnumerable<TItem>, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, DateTime>>, DateTime, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, DateTime?>>, DateTime?, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, bool>>, bool, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, bool?>>, bool?, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, byte>>, byte, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, sbyte>>, sbyte, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, uint>>, uint, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, ulong>>, ulong, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, char>>, char, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.RuleFor(Expression<Func<T, char?>>, char?, string) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.Unless(Func<IEnumerable<TItem>, bool>) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.When(Func<IEnumerable<TItem>, bool>) PropertyValidator<T, IEnumerable<TItem>, EnumerablePropertyValidator<T, TItem>>.WithMessage(string) Methods Count(int) Validates that the collection contains exactly the specified number of items. public EnumerablePropertyValidator<T, TItem> Count(int count) Parameters count int The exact number of items required. Returns EnumerablePropertyValidator<T, TItem> This validator for method chaining. MaxCount(int) Validates that the collection contains at most the specified number of items. public EnumerablePropertyValidator<T, TItem> MaxCount(int max) Parameters max int The maximum number of items allowed. Returns EnumerablePropertyValidator<T, TItem> This validator for method chaining. MinCount(int) Validates that the collection contains at least the specified number of items. public EnumerablePropertyValidator<T, TItem> MinCount(int min) Parameters min int The minimum number of items required. Returns EnumerablePropertyValidator<T, TItem> This validator for method chaining. Unique(IEqualityComparer<TItem>?) Validates that all items in the collection are unique. public EnumerablePropertyValidator<T, TItem> Unique(IEqualityComparer<TItem>? comparer = null) Parameters comparer IEqualityComparer<TItem> Optional equality comparer for determining uniqueness. Returns EnumerablePropertyValidator<T, TItem> This validator for method chaining."
  },
  "api/FlowRight.Validation.Validators.GenericPropertyValidator-2.html": {
    "href": "api/FlowRight.Validation.Validators.GenericPropertyValidator-2.html",
    "title": "Class GenericPropertyValidator<T, TProp> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class GenericPropertyValidator<T, TProp> Namespace FlowRight.Validation.Validators Assembly FlowRight.Validation.dll Property validator for generic types that provides basic validation operations. public sealed class GenericPropertyValidator<T, TProp> : PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>> Type Parameters T The type being validated. TProp The property type being validated. Inheritance object PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>> GenericPropertyValidator<T, TProp> Inherited Members PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.Build(Func<T>) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.Empty() PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.Equal(TProp, IEqualityComparer<TProp>) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.Must(Func<TProp, bool>, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.NotEmpty() PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.NotEqual(TProp, IEqualityComparer<TProp>) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.NotNull() PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.Null() PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor<TDifferentProp>(Expression<Func<T, TDifferentProp>>, Result<TDifferentProp>, out TDifferentProp) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, string>>, string, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, Guid?>>, Guid?, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, int>>, int, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, long>>, long, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, decimal>>, decimal, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, double>>, double, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, float>>, float, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, short>>, short, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>>, IEnumerable<TItem>, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, DateTime>>, DateTime, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, DateTime?>>, DateTime?, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, bool>>, bool, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, bool?>>, bool?, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, byte>>, byte, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, sbyte>>, sbyte, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, uint>>, uint, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, ulong>>, ulong, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, char>>, char, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.RuleFor(Expression<Func<T, char?>>, char?, string) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.Unless(Func<TProp, bool>) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.When(Func<TProp, bool>) PropertyValidator<T, TProp, GenericPropertyValidator<T, TProp>>.WithMessage(string)"
  },
  "api/FlowRight.Validation.Validators.GuidPropertyValidator-1.html": {
    "href": "api/FlowRight.Validation.Validators.GuidPropertyValidator-1.html",
    "title": "Class GuidPropertyValidator<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class GuidPropertyValidator<T> Namespace FlowRight.Validation.Validators Assembly FlowRight.Validation.dll Provides fluent validation rules specifically designed for GUID properties, offering comprehensive GUID-specific validation capabilities including empty GUID checks, version validation, and format validation. public sealed class GuidPropertyValidator<T> : PropertyValidator<T, Guid?, GuidPropertyValidator<T>> Type Parameters T The type of object being validated. Inheritance object PropertyValidator<T, Guid?, GuidPropertyValidator<T>> GuidPropertyValidator<T> Inherited Members PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.Build(Func<T>) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.Empty() PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.Equal(Guid?, IEqualityComparer<Guid?>) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.Must(Func<Guid?, bool>, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.NotEmpty() PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.NotEqual(Guid?, IEqualityComparer<Guid?>) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.NotNull() PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.Null() PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor<TDifferentProp>(Expression<Func<T, TDifferentProp>>, Result<TDifferentProp>, out TDifferentProp) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, string>>, string, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, Guid?>>, Guid?, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, int>>, int, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, long>>, long, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, decimal>>, decimal, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, double>>, double, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, float>>, float, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, short>>, short, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>>, IEnumerable<TItem>, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, DateTime>>, DateTime, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, DateTime?>>, DateTime?, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, bool>>, bool, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, bool?>>, bool?, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, byte>>, byte, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, sbyte>>, sbyte, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, uint>>, uint, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, ulong>>, ulong, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, char>>, char, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.RuleFor(Expression<Func<T, char?>>, char?, string) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.Unless(Func<Guid?, bool>) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.When(Func<Guid?, bool>) PropertyValidator<T, Guid?, GuidPropertyValidator<T>>.WithMessage(string) Examples ValidationBuilder<Entity> builder = new(); builder.RuleFor(x => x.Id, request.Id) .NotEmpty() .NotEqual(Guid.Empty) .Version4() .WithMessage(\"Please provide a valid entity ID\"); builder.RuleFor(x => x.ParentId, request.ParentId) .NotNull() .ValidFormat() .WithMessage(\"Parent ID must be a valid GUID\"); Methods NonZeroTimestamp() Validates that the GUID has non-zero timestamp bits, indicating it was not created at epoch time. This can help identify potentially invalid or placeholder GUIDs. public GuidPropertyValidator<T> NonZeroTimestamp() Returns GuidPropertyValidator<T> The GuidPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.CreatedId, request.CreatedId) .NonZeroTimestamp() .WithMessage(\"GUID must have a valid timestamp component\"); NotEmptyGuid() Validates that the GUID is not the sequential empty GUID (00000000-0000-0000-0000-000000000000). This is equivalent to NotEqual(Guid.Empty) but provides a more semantic method name. public GuidPropertyValidator<T> NotEmptyGuid() Returns GuidPropertyValidator<T> The GuidPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.EntityId, request.EntityId) .NotEmptyGuid() .WithMessage(\"Entity ID cannot be empty\"); // Valid: Any non-empty GUID // Invalid: Guid.Empty (00000000-0000-0000-0000-000000000000) ValidFormat() Validates that the GUID follows the standard hyphenated format (8-4-4-4-12 characters). This ensures the GUID string representation is properly formatted. public GuidPropertyValidator<T> ValidFormat() Returns GuidPropertyValidator<T> The GuidPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.Id, request.Id) .ValidFormat() .WithMessage(\"ID must be in valid GUID format\"); // Valid: \"f47ac10b-58cc-4372-a567-0e02b2c3d479\" // Invalid: Malformed or non-hyphenated formats"
  },
  "api/FlowRight.Validation.Validators.NumericPropertyValidator-2.html": {
    "href": "api/FlowRight.Validation.Validators.NumericPropertyValidator-2.html",
    "title": "Class NumericPropertyValidator<T, TNumeric> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class NumericPropertyValidator<T, TNumeric> Namespace FlowRight.Validation.Validators Assembly FlowRight.Validation.dll Provides fluent validation rules specifically designed for numeric properties, offering comprehensive numeric comparison and range validation capabilities for any type implementing INumber<T>. public sealed class NumericPropertyValidator<T, TNumeric> : PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>> where TNumeric : struct, INumber<TNumeric> Type Parameters T The type of object being validated. TNumeric The numeric type being validated (int, long, decimal, double, float, short, etc.). Inheritance object PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>> NumericPropertyValidator<T, TNumeric> Inherited Members PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.Build(Func<T>) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.Empty() PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.Equal(TNumeric, IEqualityComparer<TNumeric>) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.Must(Func<TNumeric, bool>, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.NotEmpty() PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.NotEqual(TNumeric, IEqualityComparer<TNumeric>) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.NotNull() PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.Null() PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor<TDifferentProp>(Expression<Func<T, TDifferentProp>>, Result<TDifferentProp>, out TDifferentProp) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, string>>, string, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, Guid?>>, Guid?, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, int>>, int, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, long>>, long, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, decimal>>, decimal, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, double>>, double, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, float>>, float, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, short>>, short, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>>, IEnumerable<TItem>, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, DateTime>>, DateTime, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, DateTime?>>, DateTime?, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, bool>>, bool, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, bool?>>, bool?, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, byte>>, byte, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, sbyte>>, sbyte, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, uint>>, uint, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, ulong>>, ulong, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, char>>, char, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.RuleFor(Expression<Func<T, char?>>, char?, string) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.Unless(Func<TNumeric, bool>) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.When(Func<TNumeric, bool>) PropertyValidator<T, TNumeric, NumericPropertyValidator<T, TNumeric>>.WithMessage(string) Examples // Integer validation ValidationBuilder<Character> builder = new(); builder.RuleFor(x => x.Age, request.Age) .GreaterThan(0) .LessThanOrEqualTo(1000) .WithMessage(\"Character age must be between 1 and 1000\"); // Decimal validation with precision builder.RuleFor(x => x.Price, request.Price) .GreaterThanOrEqualTo(0.01m) .LessThan(1000000m) .PrecisionScale(10, 2) .WithMessage(\"Price must be positive with up to 2 decimal places\"); // Range validation builder.RuleFor(x => x.DiceCount, dicePool.TotalDice) .InclusiveBetween(1, 100) .WithMessage(\"Dice pool must contain 1-100 dice\"); Methods ExclusiveBetween(TNumeric, TNumeric) Validates that the numeric value is strictly between the specified bounds (exclusive). public NumericPropertyValidator<T, TNumeric> ExclusiveBetween(TNumeric from, TNumeric to) Parameters from TNumeric The lower bound (exclusive). to TNumeric The upper bound (exclusive). Returns NumericPropertyValidator<T, TNumeric> The NumericPropertyValidator<T, TNumeric> for method chaining. Examples builder.RuleFor(x => x.Percentage, request.Percentage) .ExclusiveBetween(0, 100) .WithMessage(\"Percentage must be between 0 and 100 (exclusive)\"); // Valid: 0.1, 50, 99.9 // Invalid: 0, 100, -1, 101 GreaterThan(TNumeric) Validates that the numeric value is greater than the specified comparison value. public NumericPropertyValidator<T, TNumeric> GreaterThan(TNumeric valueToCompare) Parameters valueToCompare TNumeric The value to compare against. Returns NumericPropertyValidator<T, TNumeric> The NumericPropertyValidator<T, TNumeric> for method chaining. Examples builder.RuleFor(x => x.Price, request.Price) .GreaterThan(0) .WithMessage(\"Price must be positive\"); builder.RuleFor(x => x.Rating, request.Rating) .GreaterThan(0.0) .WithMessage(\"Rating must be above zero\"); GreaterThanOrEqualTo(TNumeric) Validates that the numeric value is greater than or equal to the specified comparison value. public NumericPropertyValidator<T, TNumeric> GreaterThanOrEqualTo(TNumeric valueToCompare) Parameters valueToCompare TNumeric The value to compare against. Returns NumericPropertyValidator<T, TNumeric> The NumericPropertyValidator<T, TNumeric> for method chaining. Examples builder.RuleFor(x => x.MinimumAge, request.MinimumAge) .GreaterThanOrEqualTo(18) .WithMessage(\"Minimum age must be 18 or older\"); builder.RuleFor(x => x.Balance, account.Balance) .GreaterThanOrEqualTo(0.00m) .WithMessage(\"Account balance cannot be negative\"); InclusiveBetween(TNumeric, TNumeric) Validates that the numeric value is between the specified bounds (inclusive). public NumericPropertyValidator<T, TNumeric> InclusiveBetween(TNumeric from, TNumeric to) Parameters from TNumeric The lower bound (inclusive). to TNumeric The upper bound (inclusive). Returns NumericPropertyValidator<T, TNumeric> The NumericPropertyValidator<T, TNumeric> for method chaining. Examples builder.RuleFor(x => x.DiceRoll, roll.Value) .InclusiveBetween(1, 6) .WithMessage(\"Dice roll must be between 1 and 6\"); builder.RuleFor(x => x.Attribute, character.Strength) .InclusiveBetween(1, 12) .WithMessage(\"Shadowrun attributes range from 1 to 12\"); LessThan(TNumeric) Validates that the numeric value is less than the specified comparison value. public NumericPropertyValidator<T, TNumeric> LessThan(TNumeric valueToCompare) Parameters valueToCompare TNumeric The value to compare against. Returns NumericPropertyValidator<T, TNumeric> The NumericPropertyValidator<T, TNumeric> for method chaining. Examples builder.RuleFor(x => x.MaxUsers, request.MaxUsers) .LessThan(10000) .WithMessage(\"Maximum users must be under 10,000\"); builder.RuleFor(x => x.Discount, request.Discount) .LessThan(1.0) .WithMessage(\"Discount must be less than 100%\"); LessThanOrEqualTo(TNumeric) Validates that the numeric value is less than or equal to the specified comparison value. public NumericPropertyValidator<T, TNumeric> LessThanOrEqualTo(TNumeric valueToCompare) Parameters valueToCompare TNumeric The value to compare against. Returns NumericPropertyValidator<T, TNumeric> The NumericPropertyValidator<T, TNumeric> for method chaining. Examples builder.RuleFor(x => x.MaxRetries, request.MaxRetries) .LessThanOrEqualTo(5) .WithMessage(\"Maximum retries cannot exceed 5\"); builder.RuleFor(x => x.CompletionRate, task.CompletionRate) .LessThanOrEqualTo(1.0) .WithMessage(\"Completion rate cannot exceed 100%\"); PrecisionScale(int, int) Validates that the numeric value conforms to the specified precision and scale requirements, typically used for decimal types to ensure database compatibility. public NumericPropertyValidator<T, TNumeric> PrecisionScale(int precision, int scale) Parameters precision int The maximum number of digits (total digits). scale int The maximum number of decimal places. Returns NumericPropertyValidator<T, TNumeric> The NumericPropertyValidator<T, TNumeric> for method chaining. Examples // Currency validation: up to 10 digits total, 2 decimal places builder.RuleFor(x => x.Price, request.Price) .PrecisionScale(10, 2) .WithMessage(\"Price must have at most 8 whole digits and 2 decimal places\"); // Percentage with high precision: up to 5 digits total, 3 decimal places builder.RuleFor(x => x.InterestRate, request.InterestRate) .PrecisionScale(5, 3) .WithMessage(\"Interest rate precision is too high\"); // Valid examples for PrecisionScale(10, 2): // 12345678.90, 0.01, 99999999.99 // Invalid: 123456789.123 (too many decimal places), 12345678901 (too many total digits)"
  },
  "api/FlowRight.Validation.Validators.PropertyValidator-3.html": {
    "href": "api/FlowRight.Validation.Validators.PropertyValidator-3.html",
    "title": "Class PropertyValidator<T, TProp, TRule> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class PropertyValidator<T, TProp, TRule> Namespace FlowRight.Validation.Validators Assembly FlowRight.Validation.dll Abstract base class for all property validators, providing core validation functionality and fluent interface patterns for building complex validation rules. This class enables type-safe validation chaining and integration with the ValidationBuilder<T> framework. public abstract class PropertyValidator<T, TProp, TRule> where TRule : PropertyValidator<T, TProp, TRule> Type Parameters T The type of object being validated. TProp The type of property being validated. TRule The concrete validator type (used for fluent interface return types). Inheritance object PropertyValidator<T, TProp, TRule> Derived EnumerablePropertyValidator<T, TItem> GenericPropertyValidator<T, TProp> GuidPropertyValidator<T> NumericPropertyValidator<T, TNumeric> StringPropertyValidator<T> Remarks This class implements the Fluent Interface pattern to enable method chaining and provides a bridge between property-specific validators and the main ValidationBuilder. It manages pending validation rules and applies them when transitioning between properties or building the final result. Methods AddRule(IRule<TProp>?) Adds a validation rule and executes it immediately. protected TRule AddRule(IRule<TProp>? rule) Parameters rule IRule<TProp> The validation rule to add. Returns TRule The concrete validator type for method chaining. Build(Func<T>) Applies all pending validation rules for this property and builds the final Result<T>. public Result<T> Build(Func<T> factory) Parameters factory Func<T> A factory function to create the validated object when all validations pass. Returns Result<T> A Result<T> containing either the successfully created object or validation errors. Remarks This method is a convenience shortcut that applies pending rules for the current property and immediately builds the final result. It's equivalent to calling the ValidationBuilder's Build method after all property validations are complete. Empty() Validates that the property value is considered \"empty\" according to type-specific rules. public TRule Empty() Returns TRule The concrete validator type for method chaining. Remarks Empty validation varies by type: Strings: null or empty string Collections: null or empty collection Nullable types: null value Value types: default value Equal(TProp, IEqualityComparer<TProp>?) Validates that the property value equals the specified comparison value. public TRule Equal(TProp comparisonValue, IEqualityComparer<TProp>? comparer = null) Parameters comparisonValue TProp The value to compare against. comparer IEqualityComparer<TProp> Optional equality comparer for comparison. Returns TRule The concrete validator type for method chaining. Must(Func<TProp, bool>, string) Validates the property using a custom condition function with a specified error message. public TRule Must(Func<TProp, bool> condition, string errorMessage) Parameters condition Func<TProp, bool> A function that returns true if the value is valid. errorMessage string The error message to use if validation fails. Returns TRule The concrete validator type for method chaining. Examples builder.RuleFor(x => x.Username, request.Username) .Must(username => !ReservedUsernames.Contains(username), \"Username is reserved\") .Must(username => IsUniqueUsername(username), \"Username already exists\"); NotEmpty() Validates that the property value is not empty (handles strings, collections, GUIDs, etc.). public TRule NotEmpty() Returns TRule The concrete validator type for method chaining. NotEqual(TProp, IEqualityComparer<TProp>?) Validates that the property value does not equal the specified comparison value. public TRule NotEqual(TProp comparisonValue, IEqualityComparer<TProp>? comparer = null) Parameters comparisonValue TProp The value to compare against. comparer IEqualityComparer<TProp> Optional equality comparer for comparison. Returns TRule The concrete validator type for method chaining. NotNull() Validates that the property value is not null. public TRule NotNull() Returns TRule The concrete validator type for method chaining. Null() Validates that the property value is null. public TRule Null() Returns TRule The concrete validator type for method chaining. RuleFor(Expression<Func<T, bool>>, bool, string?) Creates validation rules for a boolean property using a fluent interface. public GenericPropertyValidator<T, bool> RuleFor(Expression<Func<T, bool>> propertySelector, bool value, string? displayName = null) Parameters propertySelector Expression<Func<T, bool>> Expression selecting the property to validate. value bool The boolean value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, bool> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, byte>>, byte, string?) Creates validation rules for a byte numeric property using a fluent interface. public NumericPropertyValidator<T, byte> RuleFor(Expression<Func<T, byte>> propertySelector, byte value, string? displayName = null) Parameters propertySelector Expression<Func<T, byte>> Expression selecting the property to validate. value byte The byte value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, byte> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, char>>, char, string?) Creates validation rules for a character property using a fluent interface. public GenericPropertyValidator<T, char> RuleFor(Expression<Func<T, char>> propertySelector, char value, string? displayName = null) Parameters propertySelector Expression<Func<T, char>> Expression selecting the property to validate. value char The character value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, char> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, DateTime>>, DateTime, string?) Creates validation rules for a DateTime property using a fluent interface. public GenericPropertyValidator<T, DateTime> RuleFor(Expression<Func<T, DateTime>> propertySelector, DateTime value, string? displayName = null) Parameters propertySelector Expression<Func<T, DateTime>> Expression selecting the property to validate. value DateTime The DateTime value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, DateTime> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, decimal>>, decimal, string?) Creates validation rules for a decimal numeric property using a fluent interface. public NumericPropertyValidator<T, decimal> RuleFor(Expression<Func<T, decimal>> propertySelector, decimal value, string? displayName = null) Parameters propertySelector Expression<Func<T, decimal>> Expression selecting the property to validate. value decimal The decimal value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, decimal> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, double>>, double, string?) Creates validation rules for a double numeric property using a fluent interface. public NumericPropertyValidator<T, double> RuleFor(Expression<Func<T, double>> propertySelector, double value, string? displayName = null) Parameters propertySelector Expression<Func<T, double>> Expression selecting the property to validate. value double The double value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, double> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, short>>, short, string?) Creates validation rules for a short numeric property using a fluent interface. public NumericPropertyValidator<T, short> RuleFor(Expression<Func<T, short>> propertySelector, short value, string? displayName = null) Parameters propertySelector Expression<Func<T, short>> Expression selecting the property to validate. value short The short value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, short> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, int>>, int, string?) Creates validation rules for an integer numeric property using a fluent interface. public NumericPropertyValidator<T, int> RuleFor(Expression<Func<T, int>> propertySelector, int value, string? displayName = null) Parameters propertySelector Expression<Func<T, int>> Expression selecting the property to validate. value int The integer value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, int> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, long>>, long, string?) Creates validation rules for a long numeric property using a fluent interface. public NumericPropertyValidator<T, long> RuleFor(Expression<Func<T, long>> propertySelector, long value, string? displayName = null) Parameters propertySelector Expression<Func<T, long>> Expression selecting the property to validate. value long The long value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, long> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, bool?>>, bool?, string?) Creates validation rules for a nullable boolean property using a fluent interface. public GenericPropertyValidator<T, bool?> RuleFor(Expression<Func<T, bool?>> propertySelector, bool? value, string? displayName = null) Parameters propertySelector Expression<Func<T, bool?>> Expression selecting the property to validate. value bool? The nullable boolean value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, bool?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, char?>>, char?, string?) Creates validation rules for a nullable character property using a fluent interface. public GenericPropertyValidator<T, char?> RuleFor(Expression<Func<T, char?>> propertySelector, char? value, string? displayName = null) Parameters propertySelector Expression<Func<T, char?>> Expression selecting the property to validate. value char? The nullable character value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, char?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, DateTime?>>, DateTime?, string?) Creates validation rules for a nullable DateTime property using a fluent interface. public GenericPropertyValidator<T, DateTime?> RuleFor(Expression<Func<T, DateTime?>> propertySelector, DateTime? value, string? displayName = null) Parameters propertySelector Expression<Func<T, DateTime?>> Expression selecting the property to validate. value DateTime? The nullable DateTime value for the property. displayName string Optional display name for validation messages. Returns GenericPropertyValidator<T, DateTime?> A generic property validator for further rule configuration. RuleFor(Expression<Func<T, Guid?>>, Guid?, string?) Creates validation rules for a GUID property using a fluent interface. public GuidPropertyValidator<T> RuleFor(Expression<Func<T, Guid?>> propertySelector, Guid? value, string? displayName = null) Parameters propertySelector Expression<Func<T, Guid?>> Expression selecting the property to validate. value Guid? The GUID value for the property. displayName string Optional display name for validation messages. Returns GuidPropertyValidator<T> A GUID property validator for further rule configuration. RuleFor(Expression<Func<T, sbyte>>, sbyte, string?) Creates validation rules for a signed byte numeric property using a fluent interface. public NumericPropertyValidator<T, sbyte> RuleFor(Expression<Func<T, sbyte>> propertySelector, sbyte value, string? displayName = null) Parameters propertySelector Expression<Func<T, sbyte>> Expression selecting the property to validate. value sbyte The sbyte value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, sbyte> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, float>>, float, string?) Creates validation rules for a float numeric property using a fluent interface. public NumericPropertyValidator<T, float> RuleFor(Expression<Func<T, float>> propertySelector, float value, string? displayName = null) Parameters propertySelector Expression<Func<T, float>> Expression selecting the property to validate. value float The float value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, float> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, string>>, string, string?) Creates validation rules for a string property using a fluent interface. public StringPropertyValidator<T> RuleFor(Expression<Func<T, string>> propertySelector, string value, string? displayName = null) Parameters propertySelector Expression<Func<T, string>> Expression selecting the property to validate. value string The string value for the property. displayName string Optional display name for validation messages. Returns StringPropertyValidator<T> A string property validator for further rule configuration. RuleFor(Expression<Func<T, uint>>, uint, string?) Creates validation rules for an unsigned integer numeric property using a fluent interface. public NumericPropertyValidator<T, uint> RuleFor(Expression<Func<T, uint>> propertySelector, uint value, string? displayName = null) Parameters propertySelector Expression<Func<T, uint>> Expression selecting the property to validate. value uint The uint value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, uint> A numeric property validator for further rule configuration. RuleFor(Expression<Func<T, ulong>>, ulong, string?) Creates validation rules for an unsigned long numeric property using a fluent interface. public NumericPropertyValidator<T, ulong> RuleFor(Expression<Func<T, ulong>> propertySelector, ulong value, string? displayName = null) Parameters propertySelector Expression<Func<T, ulong>> Expression selecting the property to validate. value ulong The ulong value for the property. displayName string Optional display name for validation messages. Returns NumericPropertyValidator<T, ulong> A numeric property validator for further rule configuration. RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>>, IEnumerable<TItem>, string?) Creates validation rules for an enumerable/collection property using a fluent interface. public EnumerablePropertyValidator<T, TItem> RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>> propertySelector, IEnumerable<TItem> value, string? displayName = null) Parameters propertySelector Expression<Func<T, IEnumerable<TItem>>> Expression selecting the property to validate. value IEnumerable<TItem> The collection value for the property. displayName string Optional display name for validation messages. Returns EnumerablePropertyValidator<T, TItem> An enumerable property validator for further rule configuration. Type Parameters TItem The type of items in the collection. RuleFor<TDifferentProp>(Expression<Func<T, TDifferentProp>>, Result<TDifferentProp>, out TDifferentProp?) Creates validation rules for a different property using a Result composition pattern. public ValidationBuilder<T> RuleFor<TDifferentProp>(Expression<Func<T, TDifferentProp>> propertySelector, Result<TDifferentProp> result, out TDifferentProp? value) Parameters propertySelector Expression<Func<T, TDifferentProp>> Expression selecting the property to validate. result Result<TDifferentProp> The Result containing the property value or errors. value TDifferentProp Out parameter for the validated value if successful. Returns ValidationBuilder<T> The validation builder for method chaining. Type Parameters TDifferentProp The type of the different property. Unless(Func<TProp, bool>) Applies a conditional check to the last validation rule, only executing it when the condition is false. This is the inverse of When(). public TRule Unless(Func<TProp, bool> condition) Parameters condition Func<TProp, bool> A function that determines when NOT to apply the previous validation rule. Returns TRule The concrete validator type for method chaining. UpdateLastRuleCondition(Func<TProp, bool>?) Updates the condition function for the last added validation rule. protected void UpdateLastRuleCondition(Func<TProp, bool>? condition) Parameters condition Func<TProp, bool> The condition function to apply to the last rule. UpdateLastValidationMessage(string?) Updates the custom error message for the last added validation rule. protected void UpdateLastValidationMessage(string? customMessage) Parameters customMessage string The custom error message to use. When(Func<TProp, bool>) Applies a conditional check to the last validation rule, only executing it when the condition is true. public TRule When(Func<TProp, bool> condition) Parameters condition Func<TProp, bool> A function that determines whether to apply the previous validation rule. Returns TRule The concrete validator type for method chaining. Examples builder.RuleFor(x => x.ConfirmPassword, request.ConfirmPassword) .Equal(request.Password) .When(value => !string.IsNullOrEmpty(request.Password)) .WithMessage(\"Passwords must match when password is provided\"); WithMessage(string) Overrides the default error message for the last validation rule with a custom message. public TRule WithMessage(string customMessage) Parameters customMessage string The custom error message to use instead of the default. Returns TRule The concrete validator type for method chaining. Examples builder.RuleFor(x => x.Age, request.Age) .GreaterThan(0) .WithMessage(\"Character age must be positive - negative ages are not allowed in Shadowrun\");"
  },
  "api/FlowRight.Validation.Validators.StringPropertyValidator-1.html": {
    "href": "api/FlowRight.Validation.Validators.StringPropertyValidator-1.html",
    "title": "Class StringPropertyValidator<T> | FlowRight - Result Pattern Library for .NET",
    "summary": "Class StringPropertyValidator<T> Namespace FlowRight.Validation.Validators Assembly FlowRight.Validation.dll Provides fluent validation rules specifically designed for string properties, offering comprehensive string-specific validation capabilities including length checks, pattern matching, and email validation. public sealed class StringPropertyValidator<T> : PropertyValidator<T, string, StringPropertyValidator<T>> Type Parameters T The type of object being validated. Inheritance object PropertyValidator<T, string, StringPropertyValidator<T>> StringPropertyValidator<T> Inherited Members PropertyValidator<T, string, StringPropertyValidator<T>>.Build(Func<T>) PropertyValidator<T, string, StringPropertyValidator<T>>.Empty() PropertyValidator<T, string, StringPropertyValidator<T>>.Equal(string, IEqualityComparer<string>) PropertyValidator<T, string, StringPropertyValidator<T>>.Must(Func<string, bool>, string) PropertyValidator<T, string, StringPropertyValidator<T>>.NotEmpty() PropertyValidator<T, string, StringPropertyValidator<T>>.NotEqual(string, IEqualityComparer<string>) PropertyValidator<T, string, StringPropertyValidator<T>>.NotNull() PropertyValidator<T, string, StringPropertyValidator<T>>.Null() PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor<TDifferentProp>(Expression<Func<T, TDifferentProp>>, Result<TDifferentProp>, out TDifferentProp) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, string>>, string, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, Guid?>>, Guid?, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, int>>, int, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, long>>, long, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, decimal>>, decimal, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, double>>, double, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, float>>, float, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, short>>, short, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor<TItem>(Expression<Func<T, IEnumerable<TItem>>>, IEnumerable<TItem>, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, DateTime>>, DateTime, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, DateTime?>>, DateTime?, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, bool>>, bool, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, bool?>>, bool?, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, byte>>, byte, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, sbyte>>, sbyte, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, uint>>, uint, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, ulong>>, ulong, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, char>>, char, string) PropertyValidator<T, string, StringPropertyValidator<T>>.RuleFor(Expression<Func<T, char?>>, char?, string) PropertyValidator<T, string, StringPropertyValidator<T>>.Unless(Func<string, bool>) PropertyValidator<T, string, StringPropertyValidator<T>>.When(Func<string, bool>) PropertyValidator<T, string, StringPropertyValidator<T>>.WithMessage(string) Examples ValidationBuilder<User> builder = new(); builder.RuleFor(x => x.Email, request.Email) .NotEmpty() .EmailAddress() .MaximumLength(255) .WithMessage(\"Please provide a valid email address\"); builder.RuleFor(x => x.Password, request.Password) .NotEmpty() .MinimumLength(8) .Matches(@\"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).*$\") .WithMessage(\"Password must contain at least one lowercase, uppercase, and digit\"); Methods Alpha() Validates that the string contains only alphabetic characters (letters). public StringPropertyValidator<T> Alpha() Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.FirstName, request.FirstName) .Alpha() .WithMessage(\"First name must contain only letters\"); // Valid: \"John\", \"María\", \"José\" // Invalid: \"John123\", \"John-Doe\", \"John Smith\" AlphaNumeric() Validates that the string contains only alphanumeric characters (letters and digits). public StringPropertyValidator<T> AlphaNumeric() Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.Username, request.Username) .AlphaNumeric() .WithMessage(\"Username must contain only letters and numbers\"); // Valid: \"User123\", \"JohnDoe\", \"admin\" // Invalid: \"user-123\", \"john_doe\", \"admin@\" Contains(string, StringComparison) Validates that the string contains the specified substring. public StringPropertyValidator<T> Contains(string substring, StringComparison comparison = StringComparison.Ordinal) Parameters substring string The substring that must be contained in the value. comparison StringComparison The string comparison type to use. Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.Description, request.Description) .Contains(\"important\") .WithMessage(\"Description must contain the word 'important'\"); // Case-insensitive search builder.RuleFor(x => x.Title, request.Title) .Contains(\"urgent\", StringComparison.OrdinalIgnoreCase) .WithMessage(\"Title must contain 'urgent' (case insensitive)\"); EmailAddress() Validates that the string is a properly formatted email address according to standard email format rules. public StringPropertyValidator<T> EmailAddress() Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.Email, request.Email) .EmailAddress() .WithMessage(\"Please enter a valid email address\"); // Valid: \"user@example.com\", \"test.email+tag@domain.co.uk\" // Invalid: \"invalid-email\", \"@domain.com\", \"user@\" EndsWith(string, StringComparison) Validates that the string ends with the specified suffix. public StringPropertyValidator<T> EndsWith(string suffix, StringComparison comparison = StringComparison.Ordinal) Parameters suffix string The suffix that the value must end with. comparison StringComparison The string comparison type to use. Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.FileName, request.FileName) .EndsWith(\".txt\") .WithMessage(\"File must be a text file (.txt)\"); // Case-insensitive suffix check builder.RuleFor(x => x.ImagePath, request.ImagePath) .EndsWith(\".jpg\", StringComparison.OrdinalIgnoreCase) .WithMessage(\"Image must be a JPEG file\"); ExactLength(int) Validates that the string has exactly the specified length. public StringPropertyValidator<T> ExactLength(int length) Parameters length int The exact length the string must have. Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.CountryCode, request.CountryCode) .ExactLength(2) .WithMessage(\"Country code must be exactly 2 characters\"); // Valid: \"US\", \"CA\", \"GB\" // Invalid: \"USA\", \"C\", \"\" Length(int, int) Validates that the string length is between the specified minimum and maximum values (inclusive). public StringPropertyValidator<T> Length(int minLength, int maxLength) Parameters minLength int The minimum allowed length (inclusive). maxLength int The maximum allowed length (inclusive). Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.Username, request.Username) .Length(3, 20) .WithMessage(\"Username must be between 3 and 20 characters\"); // Valid: \"abc\", \"username123\", \"abcdefghijklmnopqrst\" // Invalid: \"ab\", \"verylongusernamethatexceedslimit\" LowerCase() Validates that the string is in lowercase. public StringPropertyValidator<T> LowerCase() Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.Username, request.Username) .LowerCase() .WithMessage(\"Username must be in lowercase\"); // Valid: \"user\", \"admin\", \"john.doe\" // Invalid: \"User\", \"ADMIN\", \"John.Doe\" Matches(string, RegexOptions) Validates that the string matches the specified regular expression pattern. public StringPropertyValidator<T> Matches(string pattern, RegexOptions options = RegexOptions.None) Parameters pattern string The regular expression pattern to match against. options RegexOptions Optional regex options to modify pattern matching behavior. Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples // Phone number validation builder.RuleFor(x => x.PhoneNumber, request.PhoneNumber) .Matches(@\"^\\+?[1-9]\\d{1,14}$\") .WithMessage(\"Please enter a valid phone number\"); // Case-insensitive pattern matching builder.RuleFor(x => x.ProductCode, request.ProductCode) .Matches(@\"^[A-Z]{2}\\d{4}$\", RegexOptions.IgnoreCase) .WithMessage(\"Product code must be 2 letters followed by 4 digits\"); MaximumLength(int) Validates that the string length does not exceed the specified maximum. public StringPropertyValidator<T> MaximumLength(int max) Parameters max int The maximum allowed length (inclusive). Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.Description, request.Description) .MaximumLength(500) .WithMessage(\"Description cannot exceed 500 characters\"); // Database field length constraints builder.RuleFor(x => x.Title, request.Title) .MaximumLength(100) .WithMessage(\"Title is too long for database storage\"); MinimumLength(int) Validates that the string length meets or exceeds the specified minimum. public StringPropertyValidator<T> MinimumLength(int min) Parameters min int The minimum required length (inclusive). Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.Password, request.Password) .MinimumLength(8) .WithMessage(\"Password must be at least 8 characters long\"); // Security requirements builder.RuleFor(x => x.ApiKey, request.ApiKey) .MinimumLength(32) .WithMessage(\"API key is too short to be secure\"); StartsWith(string, StringComparison) Validates that the string starts with the specified prefix. public StringPropertyValidator<T> StartsWith(string prefix, StringComparison comparison = StringComparison.Ordinal) Parameters prefix string The prefix that the value must start with. comparison StringComparison The string comparison type to use. Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.ProductCode, request.ProductCode) .StartsWith(\"PRD-\") .WithMessage(\"Product code must start with 'PRD-'\"); // Case-insensitive prefix check builder.RuleFor(x => x.Command, request.Command) .StartsWith(\"exec\", StringComparison.OrdinalIgnoreCase) .WithMessage(\"Command must start with 'exec'\"); UpperCase() Validates that the string is in uppercase. public StringPropertyValidator<T> UpperCase() Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.CountryCode, request.CountryCode) .UpperCase() .WithMessage(\"Country code must be in uppercase\"); // Valid: \"US\", \"CANADA\", \"UNITED KINGDOM\" // Invalid: \"us\", \"canada\", \"United Kingdom\" Url() Validates that the string is a properly formatted URL according to standard URL format rules. public StringPropertyValidator<T> Url() Returns StringPropertyValidator<T> The StringPropertyValidator<T> for method chaining. Examples builder.RuleFor(x => x.Website, request.Website) .Url() .WithMessage(\"Please enter a valid URL\"); // Valid: \"https://example.com\", \"http://www.test.org/path?query=1\" // Invalid: \"not-a-url\", \"ftp://example.com\", \"example.com\""
  },
  "api/FlowRight.Validation.Validators.html": {
    "href": "api/FlowRight.Validation.Validators.html",
    "title": "Namespace FlowRight.Validation.Validators | FlowRight - Result Pattern Library for .NET",
    "summary": "Namespace FlowRight.Validation.Validators Classes EnumerablePropertyValidator<T, TItem> Provides validation rules for enumerable/collection properties with fluent configuration. GenericPropertyValidator<T, TProp> Property validator for generic types that provides basic validation operations. GuidPropertyValidator<T> Provides fluent validation rules specifically designed for GUID properties, offering comprehensive GUID-specific validation capabilities including empty GUID checks, version validation, and format validation. NumericPropertyValidator<T, TNumeric> Provides fluent validation rules specifically designed for numeric properties, offering comprehensive numeric comparison and range validation capabilities for any type implementing INumber<T>. PropertyValidator<T, TProp, TRule> Abstract base class for all property validators, providing core validation functionality and fluent interface patterns for building complex validation rules. This class enables type-safe validation chaining and integration with the ValidationBuilder<T> framework. StringPropertyValidator<T> Provides fluent validation rules specifically designed for string properties, offering comprehensive string-specific validation capabilities including length checks, pattern matching, and email validation."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "FlowRight API Reference | FlowRight - Result Pattern Library for .NET",
    "summary": "FlowRight API Reference This section contains the complete API reference for all FlowRight libraries. Libraries FlowRight.Core The foundational Result pattern implementation with core types, extensions, and serialization support. Key Namespaces: FlowRight.Core.Results - Core Result types and patterns FlowRight.Core.Extensions - Extension methods for Result composition FlowRight.Core.Serialization - JSON serialization support Primary Types: Result<T> - Generic result type with value Result - Non-generic result type IResult<T> - Generic result interface IResult - Non-generic result interface ResultFailureType - Enumeration of failure types FlowRight.Validation Fluent validation builders that integrate seamlessly with the Result pattern. Key Namespaces: FlowRight.Validation.Builders - Fluent validation builders FlowRight.Validation.Rules - Comprehensive validation rules FlowRight.Validation.Validators - Property-specific validators FlowRight.Validation.Context - Validation context and metadata Primary Types: ValidationBuilder<T> - Main fluent validation API IRule<T> - Base validation rule interface IValidationContext - Validation execution context FlowRight.Http HTTP response to Result pattern conversion utilities for web applications. Key Namespaces: FlowRight.Http.Extensions - HTTP response extension methods FlowRight.Http.Models - HTTP-specific models and utilities Primary Types: HttpResponseMessageExtensions - Extension methods for HttpResponseMessage ValidationProblemResponse - Structured validation error responses ContentTypeInfo - Content type detection utilities Quick Start Basic Result Usage using FlowRight.Core.Results; // Create success result Result<string> success = Result.Success(\"Hello World\"); // Create failure result Result<string> failure = Result.Failure<string>(\"Something went wrong\"); // Handle results with pattern matching string output = result.Match( success: value => $\"Success: {value}\", failure: error => $\"Error: {error}\" ); Validation Example using FlowRight.Validation.Builders; // Build fluent validation ValidationBuilder<User> validator = new ValidationBuilder<User>() .RuleFor(x => x.Email, user.Email) .NotEmpty() .Email() .RuleFor(x => x.Age, user.Age) .GreaterThan(0) .LessThan(150); // Validate and get result Result<User> result = validator.Build(() => user); HTTP Integration using FlowRight.Http.Extensions; // Convert HTTP response to Result HttpResponseMessage response = await httpClient.GetAsync(\"/api/data\"); Result<ApiData> result = await response.ToResultFromJsonAsync<ApiData>(); Browse by Category Core Functionality Result Types and Interfaces Async Extensions and Composition JSON Serialization Validation Rules String Validation Numeric Validation Collection Validation Custom Validation HTTP Integration Response Conversion Error Response Models Generated API reference for FlowRight v1.0.0-preview.1"
  },
  "articles/best-practices.html": {
    "href": "articles/best-practices.html",
    "title": "FlowRight Best Practices Guide | FlowRight - Result Pattern Library for .NET",
    "summary": "FlowRight Best Practices Guide A comprehensive guide to using FlowRight effectively in production applications, covering advanced patterns, performance considerations, and architectural guidance. Table of Contents Core Result Pattern Best Practices Validation Composition Patterns Error Handling and Design Principles Async/Await Patterns HTTP Integration Best Practices Testing Strategies Performance Considerations Anti-Patterns and Common Pitfalls Architectural Guidance Decision Trees Core Result Pattern Best Practices When to Use Results vs Exceptions ✅ Use Results For: Business logic validation - Input validation, domain rule enforcement Expected failure scenarios - User not found, invalid credentials Recoverable errors - Network timeouts, temporary service unavailability Composed operations - Multiple validation steps that need aggregation API boundaries - Controller actions, service methods Integration points - External service calls, database operations // ✅ Good: Expected business scenario public Result<User> GetUser(int userId) { User? user = _repository.FindById(userId); return user is not null ? Result.Success(user) : Result.NotFound($\"User with ID {userId} not found\"); } // ✅ Good: Domain validation public Result<Order> PlaceOrder(PlaceOrderRequest request) { return new ValidationBuilder<Order>() .RuleFor(x => x.CustomerId, request.CustomerId) .NotEmpty() .Must(CustomerExists, \"Customer must exist\") .RuleFor(x => x.Items, request.Items) .NotEmpty(\"Order must contain at least one item\") .Must(AllItemsInStock, \"All items must be in stock\") .Build(() => new Order(request.CustomerId, request.Items)); } ❌ Use Exceptions For: Programming errors - Null reference exceptions, argument out of range System-level failures - Out of memory, stack overflow Unrecoverable errors - Database connection failure, configuration errors Framework integration - ASP.NET Core model binding, dependency injection // ❌ Bad: Programming error should use exception public Result<string> GetSubstring(string input, int start, int length) { if (start < 0) return Result.Failure<string>(\"Start cannot be negative\"); // Should use ArgumentOutOfRangeException instead } // ✅ Good: Programming error uses exception public string GetSubstring(string input, int start, int length) { ArgumentOutOfRangeException.ThrowIfNegative(start); ArgumentOutOfRangeException.ThrowIfNegative(length); if (start + length > input.Length) return input[start..]; return input.Substring(start, length); } Result Composition Patterns Sequential Validation with Early Exit // ✅ Good: Early exit pattern public async Task<Result<ProcessedOrder>> ProcessOrderAsync(CreateOrderRequest request) { Result<Customer> customerResult = await ValidateCustomerAsync(request.CustomerId); if (customerResult.IsFailure) return customerResult.ToResult<ProcessedOrder>(); Result<Inventory> inventoryResult = await ValidateInventoryAsync(request.Items); if (inventoryResult.IsFailure) return inventoryResult.ToResult<ProcessedOrder>(); Result<Payment> paymentResult = await ProcessPaymentAsync(request.Payment); if (paymentResult.IsFailure) return paymentResult.ToResult<ProcessedOrder>(); return Result.Success(new ProcessedOrder(customerResult.Value!, request.Items, paymentResult.Value!)); } Parallel Validation with Error Aggregation // ✅ Good: Parallel validation with aggregation public async Task<Result<User>> CreateUserAsync(CreateUserRequest request) { // Run validations in parallel Task<Result> emailValidation = ValidateEmailAsync(request.Email); Task<Result> usernameValidation = ValidateUsernameAsync(request.Username); Task<Result> passwordValidation = ValidatePasswordAsync(request.Password); Result[] results = await Task.WhenAll(emailValidation, usernameValidation, passwordValidation); // Combine all results - will aggregate all failures Result combinedResult = Result.Combine(results); return combinedResult.IsSuccess ? Result.Success(new User(request.Email, request.Username)) : Result.Failure<User>(combinedResult.Error, combinedResult.FailureType); } Functional Composition with Map and Bind // ✅ Good: Functional composition public async Task<Result<string>> ProcessUserDataAsync(int userId) { return await GetUserAsync(userId) .MapAsync(async user => await EnrichUserDataAsync(user)) .ThenAsync(async enrichedUser => await FormatUserDisplayAsync(enrichedUser)) .ThenAsync(async displayData => await LocalizeDisplayAsync(displayData)); } Validation Composition Patterns Basic ValidationBuilder Usage // ✅ Good: Clear, readable validation public Result<Product> CreateProduct(CreateProductRequest request) { return new ValidationBuilder<Product>() .RuleFor(x => x.Name, request.Name) .NotEmpty() .MaximumLength(100) .Must(BeUniqueProductName, \"Product name must be unique\") .RuleFor(x => x.Price, request.Price) .GreaterThan(0) .Precision(2, 2) .RuleFor(x => x.Category, request.CategoryId) .NotEmpty() .Must(CategoryExists, \"Category must exist\") .Build(() => new Product(request.Name, request.Price, request.CategoryId)); } Complex Validation with Result Composition // ✅ Good: Compose validated sub-objects public Result<Order> CreateComplexOrder(CreateOrderRequest request) { return new ValidationBuilder<Order>() .RuleFor(x => x.Customer, Customer.Create(request.Customer), out Customer? validatedCustomer) .RuleFor(x => x.ShippingAddress, Address.Create(request.ShippingAddress), out Address? validatedAddress) .RuleFor(x => x.Items, OrderItems.Create(request.Items), out OrderItems? validatedItems) .Build(() => new Order(validatedCustomer!, validatedAddress!, validatedItems!)); } Conditional Validation // ✅ Good: Context-aware conditional validation public Result<UserProfile> UpdateProfile(UpdateProfileRequest request, User currentUser) { ValidationBuilder<UserProfile> builder = new(); return builder .RuleFor(x => x.Email, request.Email) .NotEmpty() .EmailAddress() .When(value => value != currentUser.Email) // Only validate if changing .Must(BeUniqueEmail, \"Email must be unique\") .RuleFor(x => x.Phone, request.Phone) .NotEmpty() .When(value => request.RequirePhoneVerification) .Must(BeValidPhoneNumber, \"Phone number format is invalid\") .RuleFor(x => x.TwoFactorEnabled, request.EnableTwoFactor) .Must(value => !value || !string.IsNullOrEmpty(request.Phone), \"Phone number required when enabling two-factor authentication\") .Build(() => new UserProfile(request.Email, request.Phone, request.EnableTwoFactor)); } Custom Validation Rules // ✅ Good: Reusable custom validation public class BusinessRules { public static IRule<decimal> ValidBusinessExpense(decimal yearlyBudget) => new MustRule<decimal>( value => value > 0 && value <= yearlyBudget, $\"Expense must be between 0 and {yearlyBudget:C}\" ); public static IRule<DateTime> ValidFutureDate() => new MustRule<DateTime>( value => value > DateTime.UtcNow, \"Date must be in the future\" ); public static IRule<string> ValidProjectCode() => new MustRule<string>( value => value?.Length == 6 && value.All(char.IsLetterOrDigit), \"Project code must be 6 alphanumeric characters\" ); } // Usage public Result<Project> CreateProject(CreateProjectRequest request) { return new ValidationBuilder<Project>() .RuleFor(x => x.Code, request.Code) .Custom(BusinessRules.ValidProjectCode()) .RuleFor(x => x.Budget, request.Budget) .Custom(BusinessRules.ValidBusinessExpense(request.YearlyBudget)) .RuleFor(x => x.StartDate, request.StartDate) .Custom(BusinessRules.ValidFutureDate()) .Build(() => new Project(request.Code, request.Budget, request.StartDate)); } Error Handling and Design Principles Error Message Design Principles User-Friendly Messages // ✅ Good: Clear, actionable error messages public Result<Account> CreateAccount(string email, string password) { return new ValidationBuilder<Account>() .RuleFor(x => x.Email, email) .NotEmpty(\"Please enter your email address\") .EmailAddress(\"Please enter a valid email address\") .Must(BeUniqueEmail, \"An account with this email already exists. Please use a different email or try signing in.\") .RuleFor(x => x.Password, password) .NotEmpty(\"Please create a password\") .MinimumLength(8, \"Password must be at least 8 characters long\") .Must(ContainSpecialCharacter, \"Password must contain at least one special character (!@#$%^&*)\") .Must(ContainUppercase, \"Password must contain at least one uppercase letter\") .Build(() => new Account(email, password)); } Technical vs Business Error Context // ✅ Good: Appropriate error context for audience public async Task<Result<PaymentResult>> ProcessPaymentAsync(PaymentRequest request) { try { PaymentResponse response = await _paymentGateway.ProcessAsync(request); return response.Status switch { PaymentStatus.Approved => Result.Success(new PaymentResult(response.TransactionId)), PaymentStatus.Declined => Result.Failure(\"Payment was declined. Please check your card details and try again.\"), PaymentStatus.InsufficientFunds => Result.Failure(\"Payment failed due to insufficient funds.\"), PaymentStatus.ExpiredCard => Result.Failure(\"Payment failed because the card has expired.\"), _ => Result.Failure(\"Payment could not be processed at this time. Please try again later.\") }; } catch (PaymentGatewayException ex) { // Log technical details but return user-friendly message _logger.LogError(ex, \"Payment gateway error for request {RequestId}\", request.Id); return Result.Failure(\"Payment service is temporarily unavailable. Please try again later.\"); } } Structured Error Handling Error Categorization Strategy // ✅ Good: Consistent error categorization public class OrderService { public async Task<Result<Order>> CreateOrderAsync(CreateOrderRequest request) { // Validation errors - user input issues Result<Order> validationResult = ValidateOrderRequest(request); if (validationResult.IsFailure) return validationResult; // Business rule errors - domain logic violations Result businessRulesResult = await ValidateBusinessRulesAsync(request); if (businessRulesResult.IsFailure) return Result.Failure<Order>(businessRulesResult.Error); // System errors - infrastructure issues try { Order order = await _repository.CreateAsync(request); return Result.Success(order); } catch (DatabaseException ex) { _logger.LogError(ex, \"Database error creating order\"); return Result.ServerError<Order>(\"Unable to create order due to system error\"); } catch (OperationCanceledException) { return Result.Failure<Order>(\"Order creation was cancelled\", ResultFailureType.OperationCanceled); } } } Error Recovery Strategies // ✅ Good: Graceful degradation and retry logic public class UserService { public async Task<Result<UserProfile>> GetEnrichedUserProfileAsync(int userId) { // Core user data is required Result<User> userResult = await GetUserAsync(userId); if (userResult.IsFailure) return userResult.ToResult<UserProfile>(); User user = userResult.Value!; // Optional enrichment data - degrade gracefully Result<Preferences> preferencesResult = await GetUserPreferencesAsync(userId); Result<Statistics> statisticsResult = await GetUserStatisticsAsync(userId); UserProfile profile = new( user, preferencesResult.IsSuccess ? preferencesResult.Value : UserPreferences.Default, statisticsResult.IsSuccess ? statisticsResult.Value : UserStatistics.Empty ); return Result.Success(profile); } public async Task<Result<T>> WithRetryAsync<T>(Func<Task<Result<T>>> operation, int maxRetries = 3) { for (int attempt = 1; attempt <= maxRetries; attempt++) { Result<T> result = await operation(); if (result.IsSuccess || result.FailureType != ResultFailureType.ServerError) return result; if (attempt < maxRetries) await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, attempt))); // Exponential backoff } return Result.ServerError<T>(\"Operation failed after multiple retries\"); } } Async/Await Patterns Async Result Composition // ✅ Good: Clean async composition public async Task<Result<ProcessedDocument>> ProcessDocumentAsync(Document document) { return await ValidateDocumentAsync(document) .ThenAsync(async validDoc => await ExtractMetadataAsync(validDoc)) .ThenAsync(async docWithMeta => await ApplyTransformationsAsync(docWithMeta)) .ThenAsync(async transformedDoc => await SaveProcessedDocumentAsync(transformedDoc)); } // Supporting extension method pattern public static class AsyncResultExtensions { public static async Task<Result<TOut>> ThenAsync<TIn, TOut>( this Task<Result<TIn>> resultTask, Func<TIn, Task<Result<TOut>>> nextOperation) { Result<TIn> result = await resultTask.ConfigureAwait(false); return result.IsSuccess ? await nextOperation(result.Value!).ConfigureAwait(false) : Result.Failure<TOut>(result.Error, result.FailureType); } } Async Pattern Matching // ✅ Good: Async pattern matching with proper resource management public async Task<IActionResult> ProcessOrderAsync(CreateOrderRequest request) { Result<Order> orderResult = await _orderService.CreateOrderAsync(request); return await orderResult.MatchAsync( onSuccess: async order => { await _eventPublisher.PublishAsync(new OrderCreatedEvent(order.Id)); await _emailService.SendOrderConfirmationAsync(order); return Ok(new OrderResponse(order)); }, onFailure: async error => { await _auditService.LogFailureAsync(\"OrderCreation\", error, request); return BadRequest(error); } ); } Cancellation Token Handling // ✅ Good: Proper cancellation support throughout the chain public async Task<Result<Report>> GenerateReportAsync( ReportRequest request, CancellationToken cancellationToken = default) { try { Result<ReportData> dataResult = await GatherReportDataAsync(request, cancellationToken); if (dataResult.IsFailure) return dataResult.ToResult<Report>(); Result<ProcessedData> processedResult = await ProcessDataAsync(dataResult.Value!, cancellationToken); if (processedResult.IsFailure) return processedResult.ToResult<Report>(); Result<Report> reportResult = await FormatReportAsync(processedResult.Value!, cancellationToken); return reportResult; } catch (OperationCanceledException) { return Result.Failure<Report>(\"Report generation was cancelled\", ResultFailureType.OperationCanceled); } } // Async validation with cancellation public async Task<Result<User>> ValidateAndCreateUserAsync( CreateUserRequest request, CancellationToken cancellationToken = default) { ValidationBuilder<User> builder = new(); return await builder .RuleForAsync(x => x.Email, request.Email) .NotEmpty() .EmailAddress() .MustAsync(async (email, ct) => await IsUniqueEmailAsync(email, ct), \"Email must be unique\", cancellationToken) .RuleForAsync(x => x.Username, request.Username) .NotEmpty() .MustAsync(async (username, ct) => await IsUniqueUsernameAsync(username, ct), \"Username must be unique\", cancellationToken) .BuildAsync(() => new User(request.Email, request.Username), cancellationToken); } HTTP Integration Best Practices Controller Action Patterns // ✅ Good: Consistent controller pattern [ApiController] [Route(\"api/[controller]\")] public class UsersController : ControllerBase { private readonly IUserService _userService; public UsersController(IUserService userService) => _userService = userService; [HttpPost] public async Task<IActionResult> CreateUserAsync(CreateUserRequest request) { Result<User> result = await _userService.CreateUserAsync(request); return result.Match( onSuccess: user => CreatedAtAction(nameof(GetUser), new { id = user.Id }, new UserResponse(user)), onError: error => Problem(detail: error, statusCode: 500), onSecurityException: error => Problem(detail: \"Access denied\", statusCode: 403), onValidationException: errors => ValidationProblem(errors.ToDictionary( kvp => kvp.Key, kvp => kvp.Value)), onOperationCanceledException: error => Problem(detail: \"Request cancelled\", statusCode: 408) ); } [HttpGet(\"{id}\")] public async Task<IActionResult> GetUserAsync(int id) { Result<User> result = await _userService.GetUserAsync(id); return result.Match( onSuccess: user => Ok(new UserResponse(user)), onFailure: error => result.FailureType switch { ResultFailureType.NotFound => NotFound(error), ResultFailureType.Security => Forbid(error), _ => Problem(detail: error) } ); } } HTTP Client Integration // ✅ Good: HTTP client with Result pattern public class ExternalApiClient { private readonly HttpClient _httpClient; private readonly ILogger<ExternalApiClient> _logger; public async Task<Result<ApiResponse<T>>> GetAsync<T>(string endpoint, CancellationToken cancellationToken = default) { try { HttpResponseMessage response = await _httpClient.GetAsync(endpoint, cancellationToken); return await response.ToResultFromJsonAsync<ApiResponse<T>>(cancellationToken: cancellationToken); } catch (HttpRequestException ex) { _logger.LogWarning(ex, \"HTTP request failed for endpoint {Endpoint}\", endpoint); return Result.Failure<ApiResponse<T>>($\"Failed to communicate with external service: {ex.Message}\"); } catch (TaskCanceledException) when (cancellationToken.IsCancellationRequested) { return Result.Failure<ApiResponse<T>>(\"Request was cancelled\", ResultFailureType.OperationCanceled); } catch (TaskCanceledException) { _logger.LogWarning(\"HTTP request timed out for endpoint {Endpoint}\", endpoint); return Result.Failure<ApiResponse<T>>(\"Request timed out\", ResultFailureType.ServerError); } } public async Task<Result<T>> PostAsync<T>(string endpoint, object data, CancellationToken cancellationToken = default) { try { string json = JsonSerializer.Serialize(data); StringContent content = new(json, Encoding.UTF8, \"application/json\"); HttpResponseMessage response = await _httpClient.PostAsync(endpoint, content, cancellationToken); return await response.MatchAsync( onSuccess: async () => { T? result = await response.Content.ReadFromJsonAsync<T>(cancellationToken: cancellationToken); return result is not null ? Result.Success(result) : Result.Failure<T>(\"Empty response from server\"); }, onFailure: async error => { string responseBody = await response.Content.ReadAsStringAsync(cancellationToken); _logger.LogWarning(\"API request failed: {Error}. Response: {Response}\", error, responseBody); return Result.Failure<T>(error); } ); } catch (Exception ex) when (ex is not OperationCanceledException) { _logger.LogError(ex, \"Unexpected error during API request to {Endpoint}\", endpoint); return Result.Failure<T>($\"Unexpected error: {ex.Message}\"); } } } API Response Standardization // ✅ Good: Consistent API response structure public static class ApiResponseExtensions { public static IActionResult ToApiResponse<T>(this Result<T> result) => result.Match( onSuccess: value => new OkObjectResult(new ApiResponse<T> { Success = true, Data = value, Message = \"Operation completed successfully\" }), onError: error => new ObjectResult(new ApiResponse<T> { Success = false, Message = error, Errors = null }) { StatusCode = 500 }, onSecurityException: error => new ObjectResult(new ApiResponse<T> { Success = false, Message = \"Access denied\", Errors = null }) { StatusCode = 403 }, onValidationException: errors => new BadRequestObjectResult(new ApiResponse<T> { Success = false, Message = \"Validation failed\", Errors = errors }), onOperationCanceledException: error => new ObjectResult(new ApiResponse<T> { Success = false, Message = \"Operation was cancelled\", Errors = null }) { StatusCode = 408 } ); public static IActionResult ToApiResponse(this Result result) => result.Match( onSuccess: () => new OkObjectResult(new ApiResponse { Success = true, Message = \"Operation completed successfully\" }), onFailure: error => new ObjectResult(new ApiResponse { Success = false, Message = error }) { StatusCode = GetStatusCodeForFailureType(result.FailureType) } ); private static int GetStatusCodeForFailureType(ResultFailureType failureType) => failureType switch { ResultFailureType.Validation => 400, ResultFailureType.NotFound => 404, ResultFailureType.Security => 403, ResultFailureType.OperationCanceled => 408, _ => 500 }; } public class ApiResponse<T> : ApiResponse { public T? Data { get; set; } } public class ApiResponse { public bool Success { get; set; } public string Message { get; set; } = string.Empty; public IDictionary<string, string[]>? Errors { get; set; } } Testing Strategies Unit Testing Result-Based Code // ✅ Good: Comprehensive Result testing patterns public class UserServiceTests { private readonly Mock<IUserRepository> _mockRepository = new(); private readonly UserService _service; public UserServiceTests() { _service = new UserService(_mockRepository.Object); } [Fact] public async Task CreateUserAsync_WithValidData_ReturnsSuccessResult() { // Arrange CreateUserRequest request = new(\"test@example.com\", \"validpassword\"); User expectedUser = new(request.Email, request.Password); _mockRepository.Setup(x => x.EmailExistsAsync(request.Email)) .ReturnsAsync(false); _mockRepository.Setup(x => x.CreateAsync(It.IsAny<User>())) .ReturnsAsync(expectedUser); // Act Result<User> result = await _service.CreateUserAsync(request); // Assert result.IsSuccess.ShouldBeTrue(); result.Value.ShouldNotBeNull(); result.Value.Email.ShouldBe(request.Email); } [Fact] public async Task CreateUserAsync_WithDuplicateEmail_ReturnsValidationFailure() { // Arrange CreateUserRequest request = new(\"duplicate@example.com\", \"validpassword\"); _mockRepository.Setup(x => x.EmailExistsAsync(request.Email)) .ReturnsAsync(true); // Act Result<User> result = await _service.CreateUserAsync(request); // Assert result.IsFailure.ShouldBeTrue(); result.FailureType.ShouldBe(ResultFailureType.Validation); result.Failures.ShouldContainKey(\"Email\"); result.Failures[\"Email\"].ShouldContain(error => error.Contains(\"already exists\")); } [Theory] [InlineData(\"\", \"Password required\")] [InlineData(\"short\", \"Password must be at least 8 characters\")] [InlineData(\"nouppercase\", \"Password must contain uppercase\")] public async Task CreateUserAsync_WithInvalidPassword_ReturnsValidationError( string password, string expectedError) { // Arrange CreateUserRequest request = new(\"test@example.com\", password); _mockRepository.Setup(x => x.EmailExistsAsync(request.Email)) .ReturnsAsync(false); // Act Result<User> result = await _service.CreateUserAsync(request); // Assert result.IsFailure.ShouldBeTrue(); result.FailureType.ShouldBe(ResultFailureType.Validation); result.Error.ShouldContain(expectedError); } } Integration Testing with Results // ✅ Good: Integration test patterns public class UserControllerIntegrationTests : IClassFixture<WebApplicationFactory<Program>> { private readonly WebApplicationFactory<Program> _factory; private readonly HttpClient _client; public UserControllerIntegrationTests(WebApplicationFactory<Program> factory) { _factory = factory; _client = factory.CreateClient(); } [Fact] public async Task CreateUser_WithValidData_ReturnsCreatedResult() { // Arrange CreateUserRequest request = new(\"integration@example.com\", \"ValidPassword123!\"); StringContent content = new( JsonSerializer.Serialize(request), Encoding.UTF8, \"application/json\" ); // Act HttpResponseMessage response = await _client.PostAsync(\"/api/users\", content); // Assert response.StatusCode.ShouldBe(HttpStatusCode.Created); string responseContent = await response.Content.ReadAsStringAsync(); UserResponse? userResponse = JsonSerializer.Deserialize<UserResponse>(responseContent); userResponse.ShouldNotBeNull(); userResponse.Email.ShouldBe(request.Email); } [Fact] public async Task CreateUser_WithInvalidData_ReturnsValidationProblem() { // Arrange CreateUserRequest request = new(\"invalid-email\", \"\"); StringContent content = new( JsonSerializer.Serialize(request), Encoding.UTF8, \"application/json\" ); // Act HttpResponseMessage response = await _client.PostAsync(\"/api/users\", content); // Assert response.StatusCode.ShouldBe(HttpStatusCode.BadRequest); string responseContent = await response.Content.ReadAsStringAsync(); ValidationProblemDetails? problem = JsonSerializer.Deserialize<ValidationProblemDetails>(responseContent); problem.ShouldNotBeNull(); problem.Errors.ShouldContainKey(\"Email\"); problem.Errors.ShouldContainKey(\"Password\"); } } Testing Custom Validators // ✅ Good: Custom validator testing public class BusinessRuleValidatorTests { [Fact] public void ValidBusinessExpense_WithValidAmount_ReturnsNull() { // Arrange decimal yearlyBudget = 100000m; decimal expense = 5000m; IRule<decimal> rule = BusinessRules.ValidBusinessExpense(yearlyBudget); // Act string? error = rule.Validate(expense, \"Expense\"); // Assert error.ShouldBeNull(); } [Theory] [InlineData(0, \"Expense must be between 0 and\")] [InlineData(-100, \"Expense must be between 0 and\")] [InlineData(200000, \"Expense must be between 0 and\")] public void ValidBusinessExpense_WithInvalidAmount_ReturnsError( decimal expense, string expectedErrorPart) { // Arrange decimal yearlyBudget = 100000m; IRule<decimal> rule = BusinessRules.ValidBusinessExpense(yearlyBudget); // Act string? error = rule.Validate(expense, \"Expense\"); // Assert error.ShouldNotBeNull(); error.ShouldContain(expectedErrorPart); } } Performance Considerations Memory Allocation Optimization // ✅ Good: Minimize allocations on success path public static class OptimizedResultFactories { // Pre-allocated common success results private static readonly Result SuccessResult = Result.Success(); private static readonly Result<bool> TrueResult = Result.Success(true); private static readonly Result<bool> FalseResult = Result.Success(false); public static Result GetCachedSuccess() => SuccessResult; public static Result<bool> GetCachedBoolResult(bool value) => value ? TrueResult : FalseResult; // String interning for common error messages private static readonly string RequiredFieldError = string.Intern(\"This field is required\"); private static readonly string InvalidFormatError = string.Intern(\"Invalid format\"); public static Result<T> RequiredFieldFailure<T>() => Result.Failure<T>(RequiredFieldError, ResultFailureType.Validation); } // ✅ Good: Efficient validation with minimal allocations public class PerformantValidator<T> { private readonly List<string> _reusableErrorList = new(8); // Pre-allocated private readonly Dictionary<string, string[]> _reusableErrorDict = new(8); public Result<T> ValidateFast(T value, Func<T, T> factory) { _reusableErrorList.Clear(); _reusableErrorDict.Clear(); // Perform validations, adding to reusable collections ValidateRequired(value, _reusableErrorList); ValidateFormat(value, _reusableErrorList); if (_reusableErrorList.Count > 0) { _reusableErrorDict[\"Value\"] = _reusableErrorList.ToArray(); return Result.Failure<T>(_reusableErrorDict); } return Result.Success(factory(value)); } } Async Performance Patterns // ✅ Good: Efficient async patterns with Results public class PerformantAsyncService { // Use ValueTask for potentially synchronous operations public async ValueTask<Result<User>> GetUserFromCacheAsync(int userId) { if (_cache.TryGetValue(userId, out User? cachedUser)) { return Result.Success(cachedUser); // Synchronous completion } User user = await _database.GetUserAsync(userId); _cache.Set(userId, user); return Result.Success(user); } // Batch operations for efficiency public async Task<Result<IEnumerable<ProcessedItem>>> ProcessItemsBatchAsync( IEnumerable<Item> items, int batchSize = 100) { List<ProcessedItem> results = new(); List<string> errors = new(); await foreach (Item[] batch in items.Chunk(batchSize)) { Task<Result<ProcessedItem>>[] tasks = batch .Select(ProcessSingleItemAsync) .ToArray(); Result<ProcessedItem>[] batchResults = await Task.WhenAll(tasks); foreach (Result<ProcessedItem> result in batchResults) { if (result.IsSuccess) { results.Add(result.Value!); } else { errors.Add(result.Error); } } } return errors.Count > 0 ? Result.Failure<IEnumerable<ProcessedItem>>(string.Join(\"; \", errors)) : Result.Success<IEnumerable<ProcessedItem>>(results); } // ConfigureAwait(false) for library code public async Task<Result<Data>> GetDataAsync() { try { HttpResponseMessage response = await _httpClient.GetAsync(\"/api/data\").ConfigureAwait(false); Result<Data> result = await response.ToResultFromJsonAsync<Data>().ConfigureAwait(false); return result; } catch (Exception ex) { return Result.Failure<Data>($\"Failed to get data: {ex.Message}\"); } } } Validation Performance Optimization // ✅ Good: Optimized validation pipeline public class FastValidationBuilder<T> { private readonly List<Func<T, ValidationResult>> _validators = new(); private readonly bool _shortCircuit; public FastValidationBuilder(bool shortCircuit = false) { _shortCircuit = shortCircuit; } public FastValidationBuilder<T> AddValidator(Func<T, ValidationResult> validator) { _validators.Add(validator); return this; } public Result<T> Validate(T value) { if (_shortCircuit) { // Fast-fail on first error foreach (Func<T, ValidationResult> validator in _validators) { ValidationResult result = validator(value); if (!result.IsValid) return Result.Failure<T>(result.Error); } } else { // Collect all errors (more allocations but complete feedback) List<string>? errors = null; foreach (Func<T, ValidationResult> validator in _validators) { ValidationResult result = validator(value); if (!result.IsValid) { errors ??= new List<string>(); errors.Add(result.Error); } } if (errors?.Count > 0) return Result.Failure<T>(string.Join(\"; \", errors)); } return Result.Success(value); } } Anti-Patterns and Common Pitfalls ❌ Anti-Pattern: Result Exception Anti-Pattern // ❌ Bad: Throwing exceptions from Results defeats the purpose public Result<User> GetUser(int id) { if (id <= 0) throw new ArgumentException(\"ID must be positive\"); // Don't do this! User? user = _repository.Find(id); return user is not null ? Result.Success(user) : Result.NotFound(\"User not found\"); } // ✅ Good: Keep it consistent with Result pattern public Result<User> GetUser(int id) { if (id <= 0) return Result.Failure<User>(\"User ID must be a positive number\"); User? user = _repository.Find(id); return user is not null ? Result.Success(user) : Result.NotFound(\"User not found\"); } ❌ Anti-Pattern: Ignored Result Values // ❌ Bad: Ignoring Result values public async Task ProcessUserAsync(CreateUserRequest request) { _userService.CreateUserAsync(request); // Result ignored! // User might not have been created, but we don't know await SendWelcomeEmailAsync(request.Email); // This might fail } // ✅ Good: Always handle Results public async Task<Result> ProcessUserAsync(CreateUserRequest request) { Result<User> userResult = await _userService.CreateUserAsync(request); if (userResult.IsFailure) return userResult.ToResult(); Result emailResult = await SendWelcomeEmailAsync(userResult.Value!.Email); return emailResult; } ❌ Anti-Pattern: Swallowing Failures // ❌ Bad: Converting failures to success public Result<User> GetUserOrDefault(int id) { Result<User> result = GetUser(id); return result.IsSuccess ? result : Result.Success(User.Default); // Lost failure information! } // ✅ Good: Explicit default handling with context public Result<User> GetUserOrDefault(int id, User defaultUser) { Result<User> result = GetUser(id); // Only use default for NotFound, preserve other failures return result.FailureType switch { ResultFailureType.NotFound => Result.Success(defaultUser), _ => result }; } ❌ Anti-Pattern: Mixing Result and Exception Patterns // ❌ Bad: Inconsistent error handling patterns public class MixedPatternService { public Result<User> GetUser(int id) { if (id <= 0) return Result.Failure<User>(\"Invalid ID\"); try { return Result.Success(_repository.GetById(id)); } catch (NotFoundException) { return Result.NotFound<User>(\"User not found\"); } catch (Exception ex) { throw; // Inconsistent - sometimes Result, sometimes Exception } } } // ✅ Good: Consistent Result pattern throughout public class ConsistentPatternService { public Result<User> GetUser(int id) { if (id <= 0) return Result.Failure<User>(\"Invalid ID\"); try { User user = _repository.GetById(id); return Result.Success(user); } catch (NotFoundException) { return Result.NotFound<User>(\"User not found\"); } catch (Exception ex) { _logger.LogError(ex, \"Unexpected error getting user {UserId}\", id); return Result.ServerError<User>(\"Unable to retrieve user\"); } } } ❌ Anti-Pattern: Inefficient Result Chaining // ❌ Bad: Inefficient nested Result handling public async Task<Result<ProcessedOrder>> ProcessOrderAsync(Order order) { Result<ValidatedOrder> validationResult = await ValidateOrderAsync(order); if (validationResult.IsFailure) { return Result.Failure<ProcessedOrder>(validationResult.Error); // Manual conversion } Result<EnrichedOrder> enrichmentResult = await EnrichOrderAsync(validationResult.Value!); if (enrichmentResult.IsFailure) { return Result.Failure<ProcessedOrder>(enrichmentResult.Error); // More manual conversion } Result<ProcessedOrder> finalResult = await FinalizeOrderAsync(enrichmentResult.Value!); return finalResult; } // ✅ Good: Efficient functional composition public async Task<Result<ProcessedOrder>> ProcessOrderAsync(Order order) { return await ValidateOrderAsync(order) .ThenAsync(validOrder => EnrichOrderAsync(validOrder)) .ThenAsync(enrichedOrder => FinalizeOrderAsync(enrichedOrder)); } ❌ Anti-Pattern: Poor Error Context // ❌ Bad: Generic, unhelpful error messages public Result<Account> CreateAccount(CreateAccountRequest request) { return new ValidationBuilder<Account>() .RuleFor(x => x.Email, request.Email) .NotEmpty(\"Required\") // Too generic .EmailAddress(\"Invalid\") // No context .RuleFor(x => x.Password, request.Password) .MinimumLength(8, \"Too short\") // Not actionable .Build(() => new Account(request.Email, request.Password)); } // ✅ Good: Clear, actionable error messages public Result<Account> CreateAccount(CreateAccountRequest request) { return new ValidationBuilder<Account>() .RuleFor(x => x.Email, request.Email) .NotEmpty(\"Please enter your email address\") .EmailAddress(\"Please enter a valid email address (example: user@domain.com)\") .RuleFor(x => x.Password, request.Password) .MinimumLength(8, \"Password must be at least 8 characters long\") .Build(() => new Account(request.Email, request.Password)); } Architectural Guidance Domain Layer Patterns // ✅ Good: Domain services with Result pattern public class OrderDomainService { public Result<Order> CreateOrder(Customer customer, IEnumerable<OrderItem> items, ShippingAddress address) { return new ValidationBuilder<Order>() .RuleFor(x => x.Customer, customer) .NotNull(\"Customer is required\") .Must(c => c.IsActive, \"Customer account must be active\") .RuleFor(x => x.Items, items) .NotEmpty(\"Order must contain at least one item\") .Must(ValidateItemsInStock, \"All items must be in stock\") .Must(ValidateOrderLimits, \"Order exceeds customer limits\") .RuleFor(x => x.ShippingAddress, address) .NotNull(\"Shipping address is required\") .Must(ValidateShippingRegion, \"We don't ship to this region\") .Build(() => Order.Create(customer, items, address)); } public Result ApplyDiscount(Order order, Discount discount) { return new ValidationBuilder<Order>() .RuleFor(x => x.Discount, discount) .Must(d => d.IsValid, \"Discount is not valid\") .Must(d => d.IsApplicableToOrder(order), \"Discount cannot be applied to this order\") .Must(d => !order.HasDiscount, \"Order already has a discount applied\") .Build(() => { order.ApplyDiscount(discount); return order; }) .ToResult(); // Convert Result<Order> to Result since we're modifying existing order } } Application Layer Integration // ✅ Good: Application service orchestration public class OrderApplicationService { private readonly OrderDomainService _domainService; private readonly IOrderRepository _repository; private readonly IEventPublisher _eventPublisher; public async Task<Result<OrderCreatedResponse>> CreateOrderAsync(CreateOrderCommand command) { // Validate command Result<CreateOrderCommand> validationResult = ValidateCommand(command); if (validationResult.IsFailure) return validationResult.ToResult<OrderCreatedResponse>(); // Get domain entities Result<Customer> customerResult = await GetCustomerAsync(command.CustomerId); if (customerResult.IsFailure) return customerResult.ToResult<OrderCreatedResponse>(); Result<IEnumerable<OrderItem>> itemsResult = await BuildOrderItemsAsync(command.Items); if (itemsResult.IsFailure) return itemsResult.ToResult<OrderCreatedResponse>(); // Create domain object Result<Order> orderResult = _domainService.CreateOrder( customerResult.Value!, itemsResult.Value!, command.ShippingAddress); if (orderResult.IsFailure) return orderResult.ToResult<OrderCreatedResponse>(); // Persist and publish events try { Order savedOrder = await _repository.SaveAsync(orderResult.Value!); await _eventPublisher.PublishAsync(new OrderCreatedEvent(savedOrder)); return Result.Success(new OrderCreatedResponse(savedOrder.Id, savedOrder.OrderNumber)); } catch (Exception ex) { return Result.ServerError<OrderCreatedResponse>($\"Failed to save order: {ex.Message}\"); } } } Infrastructure Layer Patterns // ✅ Good: Repository with Result pattern public class SqlOrderRepository : IOrderRepository { private readonly DbContext _context; private readonly ILogger<SqlOrderRepository> _logger; public async Task<Result<Order>> GetByIdAsync(int id) { try { Order? order = await _context.Orders .Include(o => o.Items) .Include(o => o.Customer) .FirstOrDefaultAsync(o => o.Id == id); return order is not null ? Result.Success(order) : Result.NotFound<Order>($\"Order with ID {id} not found\"); } catch (Exception ex) { _logger.LogError(ex, \"Error retrieving order {OrderId}\", id); return Result.ServerError<Order>(\"Unable to retrieve order\"); } } public async Task<Result<Order>> SaveAsync(Order order) { using IDbContextTransaction transaction = await _context.Database.BeginTransactionAsync(); try { if (order.Id == 0) { _context.Orders.Add(order); } else { _context.Orders.Update(order); } await _context.SaveChangesAsync(); await transaction.CommitAsync(); return Result.Success(order); } catch (DbUpdateConcurrencyException) { await transaction.RollbackAsync(); return Result.Failure<Order>(\"Order has been modified by another user\"); } catch (Exception ex) { await transaction.RollbackAsync(); _logger.LogError(ex, \"Error saving order {OrderId}\", order.Id); return Result.ServerError<Order>(\"Unable to save order\"); } } } Dependency Injection Integration // ✅ Good: Service registration patterns public static class ServiceRegistration { public static IServiceCollection AddOrderServices(this IServiceCollection services) { // Register domain services services.AddScoped<OrderDomainService>(); services.AddScoped<PricingDomainService>(); // Register application services services.AddScoped<IOrderApplicationService, OrderApplicationService>(); services.AddScoped<IOrderQueryService, OrderQueryService>(); // Register repositories services.AddScoped<IOrderRepository, SqlOrderRepository>(); services.AddScoped<ICustomerRepository, SqlCustomerRepository>(); // Register validation services services.AddScoped<IValidator<CreateOrderCommand>, CreateOrderCommandValidator>(); services.AddTransient<ValidationContext>(); return services; } } // Service implementation using DI public class OrderApplicationService : IOrderApplicationService { private readonly OrderDomainService _domainService; private readonly IOrderRepository _orderRepository; private readonly ICustomerRepository _customerRepository; private readonly IValidator<CreateOrderCommand> _validator; public OrderApplicationService( OrderDomainService domainService, IOrderRepository orderRepository, ICustomerRepository customerRepository, IValidator<CreateOrderCommand> validator) { _domainService = domainService; _orderRepository = orderRepository; _customerRepository = customerRepository; _validator = validator; } public async Task<Result<OrderResponse>> CreateOrderAsync(CreateOrderCommand command) { // Use injected validator Result<CreateOrderCommand> validationResult = await _validator.ValidateAsync(command); if (validationResult.IsFailure) return validationResult.ToResult<OrderResponse>(); // Implementation continues... } } Decision Trees When to Use Result vs Exception Is this a programming error (null reference, index out of range)? ├─ YES → Use Exception └─ NO → Is this an expected business scenario? ├─ YES → Is this recoverable by the caller? │ ├─ YES → Use Result │ └─ NO → Is this critical system failure? │ ├─ YES → Use Exception │ └─ NO → Use Result with appropriate failure type └─ NO → Is this a system-level failure? ├─ YES → Use Exception (infrastructure issues) └─ NO → Use Result (validation, business rules) Result Type Selection What type of operation is this? ├─ Returns a value → Use Result<T> ├─ Performs action only → Use Result ├─ Multiple possible failures → Use Result with specific ResultFailureType ├─ Validation-heavy → Use ValidationBuilder<T> └─ HTTP integration → Use HttpResponseMessage extensions Error Handling Strategy What's the failure context? ├─ User input validation → ResultFailureType.Validation ├─ Resource not found → ResultFailureType.NotFound ├─ Permission denied → ResultFailureType.Security ├─ Operation cancelled → ResultFailureType.OperationCanceled ├─ System unavailable → ResultFailureType.ServerError └─ General business rule → ResultFailureType.Error Async Pattern Selection What's the async scenario? ├─ Single async operation → Use Task<Result<T>> ├─ Multiple sequential operations → Use ThenAsync chaining ├─ Multiple parallel operations → Use Task.WhenAll + Result.Combine ├─ Optional operations → Use graceful degradation pattern └─ Stream processing → Use async enumerable with Result<T> Summary This guide covers the essential patterns and practices for using FlowRight effectively: Result Pattern Fundamentals: When and how to use Results vs exceptions Validation Composition: Building complex validation logic with clear error messages Error Handling: Designing user-friendly errors and proper categorization Async Integration: Clean patterns for async/await with Results HTTP Integration: Controller patterns and HTTP client integration Testing: Comprehensive testing strategies for Result-based code Performance: Optimization techniques for production usage Anti-Patterns: Common mistakes and how to avoid them Architecture: Integration patterns across application layers By following these practices, you'll build maintainable, resilient applications that handle errors gracefully and provide excellent developer experience."
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started with FlowRight | FlowRight - Result Pattern Library for .NET",
    "summary": "Getting Started with FlowRight Welcome to FlowRight, a production-grade Result pattern library for .NET that provides explicit error handling without exceptions. This guide will help you get started with FlowRight and understand how to use its core features effectively. Table of Contents Installation Core Concepts Basic Result Usage Pattern Matching Validation with FlowRight HTTP Integration Error Handling Best Practices Common Patterns Quick Reference Next Steps Installation FlowRight is distributed as three NuGet packages. Install only what you need: # Core Result pattern (required) dotnet add package FlowRight.Core --prerelease # Validation support (optional) dotnet add package FlowRight.Validation --prerelease # HTTP integration (optional) dotnet add package FlowRight.Http --prerelease Note: FlowRight is currently in pre-release (alpha). The API is stable but may change before the v1.0 production release. Prerequisites .NET 8.0 or later Nullable reference types enabled (recommended) Core Concepts What is the Result Pattern? The Result pattern is a functional programming concept that makes success and failure explicit. Instead of throwing exceptions for expected failures, methods return a Result<T> that represents either: Success: Contains the expected value Failure: Contains error information Why Use the Result Pattern? ✅ Explicit Error Handling: Failures are part of the method signature ✅ Performance: No exception throwing overhead ✅ Composability: Results can be chained and combined ✅ Readability: Clear success/failure paths ✅ Type Safety: Compile-time error checking Basic Result Usage Creating Results using FlowRight.Core.Results; // Success results Result<int> successResult = Result.Success(42); Result operationResult = Result.Success(); // Failure results Result<int> failureResult = Result.Failure<int>(\"Something went wrong\"); Result operationFailure = Result.Failure(\"Operation failed\"); Checking Result Status Result<string> result = GetUserName(userId); if (result.IsSuccess) { string userName = result.Value; // Safe to access Console.WriteLine($\"Hello, {userName}!\"); } else { string error = result.Error; // Contains error message Console.WriteLine($\"Error: {error}\"); } Working with Non-Generic Results For operations that don't return a value (like void methods): public Result DeleteUser(int userId) { try { // Perform deletion logic _userRepository.Delete(userId); return Result.Success(); } catch (UserNotFoundException) { return Result.Failure(\"User not found\"); } catch (Exception ex) { return Result.Failure($\"Failed to delete user: {ex.Message}\"); } } // Usage Result deleteResult = DeleteUser(123); if (deleteResult.IsFailure) { Console.WriteLine($\"Delete failed: {deleteResult.Error}\"); } Pattern Matching FlowRight provides two approaches for handling Results: functional (Match) and imperative (Switch). Functional Approach with Match Use Match when you need to transform the result into another value: Result<User> userResult = GetUser(userId); string message = userResult.Match( onSuccess: user => $\"Welcome back, {user.Name}!\", onFailure: error => $\"Login failed: {error}\" ); Console.WriteLine(message); Imperative Approach with Switch Use Switch when you need to perform actions based on the result: Result<Order> orderResult = CreateOrder(request); orderResult.Switch( onSuccess: order => { Console.WriteLine($\"Order {order.Id} created successfully\"); SendConfirmationEmail(order); }, onFailure: error => { Console.WriteLine($\"Order creation failed: {error}\"); LogError(error); } ); Advanced Pattern Matching Handle different result types: Result<Product> productResult = GetProduct(productId); string response = productResult.Match( onSuccess: product => $\"Product: {product.Name} - ${product.Price}\", onFailure: error => productResult.ResultType switch { ResultType.NotFound => \"Product not found\", ResultType.SecurityFailure => \"Access denied\", ResultType.ValidationFailure => $\"Invalid request: {error}\", _ => $\"Error: {error}\" } ); Validation with FlowRight FlowRight includes a powerful fluent validation API that integrates seamlessly with the Result pattern. Basic Validation using FlowRight.Validation.Builders; public Result<User> CreateUser(string name, string email, int age) { return new ValidationBuilder<User>() .RuleFor(x => x.Name, name) .NotEmpty() .MinimumLength(2) .MaximumLength(50) .RuleFor(x => x.Email, email) .NotEmpty() .EmailAddress() .RuleFor(x => x.Age, age) .GreaterThan(0) .LessThan(120) .Build(() => new User(name, email, age)); } Handling Validation Results Result<User> userResult = CreateUser(\"\", \"invalid-email\", -5); userResult.Switch( onSuccess: user => Console.WriteLine($\"User created: {user.Email}\"), onFailure: error => Console.WriteLine($\"Validation failed: {error}\") ); // Output: \"Validation failed: Name cannot be empty. Email must be a valid email address. Age must be greater than 0.\" Complex Validation Scenarios public Result<Order> CreateOrder(OrderRequest request) { return new ValidationBuilder<Order>() .RuleFor(x => x.CustomerEmail, request.CustomerEmail) .NotEmpty() .EmailAddress() .RuleFor(x => x.Items, request.Items) .NotEmpty() .Must(items => items.Count <= 100) .WithMessage(\"Orders cannot contain more than 100 items\") .RuleFor(x => x.TotalAmount, request.TotalAmount) .GreaterThan(0) .LessThan(10000) .RuleFor(x => x.ShippingAddress, request.ShippingAddress) .NotEmpty() .When(request => request.RequiresShipping) .Build(() => new Order(request)); } Available Validation Rules FlowRight includes 35+ built-in validation rules: // String validation .NotEmpty() .MinimumLength(5) .MaximumLength(100) .Length(10, 20) .Matches(@\"^\\d{3}-\\d{2}-\\d{4}$\") .EmailAddress() .Url() .AlphaNumeric() // Numeric validation .GreaterThan(0) .GreaterThanOrEqualTo(1) .LessThan(100) .LessThanOrEqualTo(99) .Between(1, 100) .Positive() .NotZero() // Collection validation .NotEmpty() .MinCount(1) .MaxCount(10) .Unique() // Custom validation .Must(value => IsValidBusinessRule(value)) .WithMessage(\"Custom validation failed\") HTTP Integration FlowRight provides seamless integration with HTTP clients, automatically converting HTTP responses to Results. Basic HTTP Integration using FlowRight.Http.Extensions; public class WeatherService { private readonly HttpClient _httpClient; public async Task<Result<WeatherData>> GetWeatherAsync(string city) { HttpResponseMessage response = await _httpClient.GetAsync($\"/weather/{city}\"); return await response.ToResultFromJsonAsync<WeatherData>(); } } HTTP Status Code Mapping FlowRight automatically maps HTTP status codes to appropriate Result types: // 2xx Status Codes → Success Result<WeatherData> weather = await response.ToResultFromJsonAsync<WeatherData>(); // Returns: Success with deserialized WeatherData // 400 Bad Request → ValidationFailure Result<User> user = await response.ToResultFromJsonAsync<User>(); // Returns: ValidationFailure with parsed validation errors // 401/403 → SecurityFailure Result<SecretData> secret = await response.ToResultFromJsonAsync<SecretData>(); // Returns: SecurityFailure(\"Access denied\") // 404 Not Found → NotFound Result<Product> product = await response.ToResultFromJsonAsync<Product>(); // Returns: NotFound(\"Resource not found\") // 5xx Server Error → Failure Result<Data> data = await response.ToResultFromJsonAsync<Data>(); // Returns: Failure(\"Server error occurred\") Handling Different Response Types public async Task<Result<ApiResponse<T>>> CallApiAsync<T>(string endpoint) { HttpResponseMessage response = await _httpClient.GetAsync(endpoint); return response.StatusCode switch { HttpStatusCode.OK => await response.ToResultFromJsonAsync<ApiResponse<T>>(), HttpStatusCode.NotFound => Result.NotFound<ApiResponse<T>>(\"Resource not found\"), HttpStatusCode.Unauthorized => Result.SecurityFailure<ApiResponse<T>>(\"Access denied\"), _ => await response.ToResultAsync().ContinueWith<ApiResponse<T>>( r => Result.Failure<ApiResponse<T>>(r.Result.Error)) }; } Working with Problem Details FlowRight automatically handles ASP.NET Core Problem Details: // Server returns: {\"type\": \"validation\", \"errors\": {\"Name\": [\"Required\"], \"Email\": [\"Invalid format\"]}} Result<User> result = await response.ToResultFromJsonAsync<User>(); if (result.IsFailure && result.ResultType == ResultType.ValidationFailure) { // Parsed validation errors are included in the error message Console.WriteLine(result.Error); // Output: \"Name is required. Email must be in a valid format.\" } Error Handling Best Practices 1. Use Appropriate Result Types // Good: Specific result types public Result<User> GetUser(int id) => _users.ContainsKey(id) ? Result.Success(_users[id]) : Result.NotFound<User>(\"User not found\"); public Result<User> ValidateUser(UserRequest request) => string.IsNullOrEmpty(request.Name) ? Result.ValidationFailure<User>(\"Name is required\") : Result.Success(new User(request.Name)); // Avoid: Generic failures for specific scenarios public Result<User> GetUser(int id) => Result.Failure<User>(\"Something went wrong\"); // Too generic 2. Combine Multiple Results public Result<Order> CreateOrder(OrderRequest request) { Result<Customer> customerResult = GetCustomer(request.CustomerId); Result<Product> productResult = GetProduct(request.ProductId); Result<decimal> priceResult = CalculatePrice(request.Items); // Combine results - if any fail, return the first failure Result combined = Result.Combine(customerResult, productResult, priceResult); if (combined.IsFailure) return Result.Failure<Order>(combined.Error); // All successful - create the order return Result.Success(new Order( customerResult.Value, productResult.Value, priceResult.Value )); } 3. Chain Operations public Result<string> ProcessUserData(int userId) { return GetUser(userId) .Match( onSuccess: user => ValidateUser(user) .Match( onSuccess: validUser => FormatUserData(validUser), onFailure: error => Result.Failure<string>(error) ), onFailure: error => Result.Failure<string>(error) ); } 4. Handle Different Error Scenarios public async Task<IActionResult> GetUserAsync(int id) { Result<User> result = await _userService.GetUserAsync(id); return result.ResultType switch { ResultType.Success => Ok(result.Value), ResultType.NotFound => NotFound($\"User {id} not found\"), ResultType.SecurityFailure => Forbid(), ResultType.ValidationFailure => BadRequest(result.Error), _ => StatusCode(500, \"An error occurred\") }; } Common Patterns Repository Pattern with Results public interface IUserRepository { Task<Result<User>> GetByIdAsync(int id); Task<Result<User>> CreateAsync(User user); Task<Result> UpdateAsync(User user); Task<Result> DeleteAsync(int id); } public class UserRepository : IUserRepository { public async Task<Result<User>> GetByIdAsync(int id) { User? user = await _dbContext.Users.FindAsync(id); return user is not null ? Result.Success(user) : Result.NotFound<User>($\"User with ID {id} not found\"); } } Service Layer Pattern public class UserService { private readonly IUserRepository _repository; private readonly IEmailService _emailService; public async Task<Result<User>> CreateUserAsync(CreateUserRequest request) { // Validate input Result<User> validationResult = ValidateCreateUserRequest(request); if (validationResult.IsFailure) return validationResult; // Create user Result<User> createResult = await _repository.CreateAsync(validationResult.Value); if (createResult.IsFailure) return createResult; // Send welcome email (don't fail if this fails) Result emailResult = await _emailService.SendWelcomeEmailAsync(createResult.Value); if (emailResult.IsFailure) { // Log warning but continue _logger.LogWarning(\"Failed to send welcome email: {Error}\", emailResult.Error); } return createResult; } } API Controller Pattern [ApiController] [Route(\"api/[controller]\")] public class UsersController : ControllerBase { private readonly IUserService _userService; [HttpGet(\"{id}\")] public async Task<ActionResult<User>> GetUser(int id) { Result<User> result = await _userService.GetUserAsync(id); return result.Match<ActionResult<User>>( onSuccess: user => Ok(user), onFailure: error => result.ResultType switch { ResultType.NotFound => NotFound(error), ResultType.SecurityFailure => Forbid(), _ => BadRequest(error) } ); } [HttpPost] public async Task<ActionResult<User>> CreateUser(CreateUserRequest request) { Result<User> result = await _userService.CreateUserAsync(request); return result.Match<ActionResult<User>>( onSuccess: user => CreatedAtAction(nameof(GetUser), new { id = user.Id }, user), onFailure: error => BadRequest(error) ); } } Quick Reference Essential Result Methods // Creating Results Result.Success<T>(value) Result.Failure<T>(message) Result.NotFound<T>(message) Result.ValidationFailure<T>(message) Result.SecurityFailure<T>(message) // Checking Results result.IsSuccess result.IsFailure result.Value // Only safe when IsSuccess result.Error // Only meaningful when IsFailure result.ResultType // Pattern Matching result.Match(onSuccess, onFailure) result.Switch(onSuccess, onFailure) // Combining Results Result.Combine(result1, result2, result3) Essential Validation Rules // String Rules .NotEmpty() .MinimumLength(n) .MaximumLength(n) .EmailAddress() .Url() // Numeric Rules .GreaterThan(n) .LessThan(n) .Between(min, max) .Positive() // Collection Rules .NotEmpty() .MinCount(n) .MaxCount(n) // Custom Rules .Must(predicate) .WithMessage(message) .When(condition) HTTP Integration // Convert HTTP response to Result await response.ToResultAsync() await response.ToResultFromJsonAsync<T>() // Status code mappings // 2xx → Success // 400 → ValidationFailure // 401/403 → SecurityFailure // 404 → NotFound // 5xx → Failure Next Steps Now that you understand FlowRight basics, explore these advanced topics: Migration Guide - Moving from exception-based code to Results Best Practices - Advanced patterns and architectural guidance API Reference - Complete API documentation Performance Guide - Optimization tips and benchmarks Sample Projects Check out these example projects that demonstrate FlowRight in action: Web API: ASP.NET Core API using Results pattern Blazor App: Frontend application with validation Console App: Command-line tool with error handling Getting Help Issues: GitHub Issues Discussions: GitHub Discussions Stack Overflow: Tag questions with flowright Happy coding with FlowRight! \uD83D\uDE80"
  },
  "articles/index.html": {
    "href": "articles/index.html",
    "title": "FlowRight Articles | FlowRight - Result Pattern Library for .NET",
    "summary": "FlowRight Articles This section contains comprehensive guides, tutorials, and documentation for FlowRight. Available Articles Getting Started Learn the fundamentals of FlowRight and how to integrate it into your .NET applications. Migration Guide Step-by-step guide for migrating from exception-based error handling to the Result pattern. Best Practices Proven patterns and best practices for using FlowRight effectively in production applications. What You'll Learn How to implement explicit error handling without exceptions Best practices for Result pattern usage Integration patterns for web APIs Advanced validation techniques Performance optimization strategies Quick Navigation Topic Description Core Concepts Understanding Result , Success, and Failure types Validation Fluent validation builders and custom rules HTTP Integration Converting HTTP responses to Results Async Patterns Working with Results in async/await scenarios Testing Unit testing strategies for Result-based code Start with the Getting Started guide if you're new to FlowRight."
  },
  "articles/migration-guide.html": {
    "href": "articles/migration-guide.html",
    "title": "Migration Guide: From Exceptions to FlowRight Result Pattern | FlowRight - Result Pattern Library for .NET",
    "summary": "Migration Guide: From Exceptions to FlowRight Result Pattern This guide helps teams migrate from exception-based error handling to the FlowRight Result pattern, providing practical strategies, code examples, and migration approaches for real-world scenarios. Table of Contents Why Migrate from Exceptions? Core Concepts Migration Strategies Common Patterns HTTP Integration Validation Migration Performance Benefits Team Adoption Migration Checklist Why Migrate from Exceptions? Problems with Exception-Based Error Handling // ❌ Traditional exception-based approach public User GetUser(int userId) { if (userId <= 0) throw new ArgumentException(\"Invalid user ID\"); User user = _repository.GetById(userId); if (user == null) throw new UserNotFoundException($\"User {userId} not found\"); if (!user.IsActive) throw new InvalidOperationException(\"User is inactive\"); return user; } // Problems: // 1. Hidden control flow - exceptions don't appear in method signatures // 2. Performance overhead from stack unwinding // 3. Difficult to compose operations // 4. Hard to distinguish between different failure types // 5. Easy to forget to handle specific exceptions Benefits of the Result Pattern // ✅ FlowRight Result pattern approach public Result<User> GetUser(int userId) { if (userId <= 0) return Result.Failure<User>(\"Invalid user ID\"); User user = _repository.GetById(userId); if (user == null) return Result.NotFound<User>($\"User {userId}\"); if (!user.IsActive) return Result.Failure<User>(\"User is inactive\", resultFailureType: ResultFailureType.Error); return Result.Success(user); } // Benefits: // 1. Explicit error handling in method signatures // 2. Zero-allocation success paths // 3. Easy composition with other Result operations // 4. Clear categorization of failure types // 5. Compile-time safety for error handling Core Concepts Result Types FlowRight provides several result types for different scenarios: // Non-generic Result for operations that don't return values Result operationResult = Result.Success(); Result errorResult = Result.Failure(\"Operation failed\"); // Generic Result<T> for operations that return values Result<User> userResult = Result.Success(user); Result<User> notFoundResult = Result.NotFound<User>(\"User with ID 123\"); // Specialized failure types Result validationResult = Result.ValidationFailure(errors); Result securityResult = Result.Failure(securityException); Result serverErrorResult = Result.ServerError(\"Database unavailable\"); Pattern Matching Replace try-catch blocks with pattern matching: // ❌ Exception-based try { User user = GetUser(userId); ProcessUser(user); } catch (UserNotFoundException) { ShowError(\"User not found\"); } catch (InvalidOperationException ex) { ShowError($\"Operation error: {ex.Message}\"); } // ✅ Result pattern Result<User> userResult = GetUser(userId); userResult.Match( onSuccess: user => ProcessUser(user), onFailure: error => ShowError(error) ); // ✅ Granular failure handling userResult.Match( onSuccess: user => ProcessUser(user), onError: error => ShowError($\"Operation error: {error}\"), onSecurityException: error => ShowSecurityError(error), onValidationException: errors => ShowValidationErrors(errors), onOperationCanceledException: error => ShowCancellationMessage(error) ); Migration Strategies Strategy 1: Greenfield Development Start all new code with Result pattern: // New service methods public class UserService { public Result<User> CreateUser(CreateUserRequest request) { return new ValidationBuilder<User>() .RuleFor(x => x.Email, request.Email) .NotEmpty() .EmailAddress() .RuleFor(x => x.Age, request.Age) .GreaterThan(0) .LessThan(120) .Build(() => new User(request.Email, request.Age)); } public async Task<Result<User>> GetUserAsync(int userId) { try { User user = await _repository.GetByIdAsync(userId); return user != null ? Result.Success(user) : Result.NotFound<User>($\"User {userId}\"); } catch (SqlException ex) when (ex.Number == -2) // Timeout { return Result.ServerError<User>(\"Database timeout\"); } catch (Exception ex) { _logger.LogError(ex, \"Error retrieving user {UserId}\", userId); return Result.ServerError<User>(\"An error occurred retrieving the user\"); } } } Strategy 2: Gradual Migration Migrate existing code incrementally using adapter patterns: // Step 1: Create Result-returning wrapper methods public class UserServiceAdapter { private readonly LegacyUserService _legacyService; public Result<User> GetUserSafe(int userId) { try { User user = _legacyService.GetUser(userId); // Still throws exceptions return Result.Success(user); } catch (ArgumentException ex) { return Result.Failure<User>(ex.Message); } catch (UserNotFoundException) { return Result.NotFound<User>($\"User {userId}\"); } catch (SecurityException ex) { return Result.Failure<User>(ex); } catch (OperationCanceledException ex) { return Result.Failure<User>(ex); } catch (Exception ex) { _logger.LogError(ex, \"Unexpected error getting user {UserId}\", userId); return Result.ServerError<User>(\"An unexpected error occurred\"); } } } // Step 2: Gradually replace calls to use the safe wrapper // Old code: try { var user = _userService.GetUser(id); } catch (Exception ex) { /* handle */ } // New code: _userServiceAdapter.GetUserSafe(id).Match( onSuccess: user => /* handle success */, onFailure: error => /* handle failure */ ); // Step 3: Eventually refactor the original service public Result<User> GetUser(int userId) { // Direct Result implementation without exceptions } Strategy 3: Boundary-Based Migration Keep existing internal code but convert at system boundaries: // Internal code still uses exceptions internal class UserRepository { public User GetById(int id) // Still throws { // Existing implementation } } // But convert to Results at service boundaries public class UserApiController : ControllerBase { [HttpGet(\"{id}\")] public async Task<ActionResult<User>> GetUser(int id) { Result<User> result = await GetUserResult(id); return result.Match( onSuccess: user => Ok(user), onError: error => BadRequest(error), onSecurityException: error => Forbid(), onValidationException: errors => BadRequest(errors), onOperationCanceledException: error => StatusCode(408) ); } private async Task<Result<User>> GetUserResult(int id) { try { User user = await _userRepository.GetByIdAsync(id); return Result.Success(user); } catch (UserNotFoundException) { return Result.NotFound<User>($\"User {id}\"); } // ... other exception handling } } Common Patterns 1. Input Validation Before (Exceptions): public void UpdateUser(int userId, string email, int age) { if (userId <= 0) throw new ArgumentException(\"Invalid user ID\"); if (string.IsNullOrEmpty(email)) throw new ArgumentException(\"Email is required\"); if (!IsValidEmail(email)) throw new ArgumentException(\"Invalid email format\"); if (age < 0 || age > 120) throw new ArgumentException(\"Age must be between 0 and 120\"); // Continue with update } After (Result Pattern): public Result UpdateUser(int userId, string email, int age) { ValidationBuilder<object> validator = new(); return validator .RuleFor(x => userId, userId, \"UserId\") .GreaterThan(0) .RuleFor(x => email, email, \"Email\") .NotEmpty() .EmailAddress() .RuleFor(x => age, age, \"Age\") .InclusiveBetween(0, 120) .Build(() => PerformUpdate(userId, email, age)); } private object PerformUpdate(int userId, string email, int age) { // Update logic here return new object(); // ValidationBuilder requires a return value } 2. Repository Pattern Before (Exceptions): public class UserRepository { public User GetById(int id) { User user = _context.Users.FirstOrDefault(u => u.Id == id); if (user == null) throw new EntityNotFoundException($\"User with ID {id} not found\"); return user; } public void Save(User user) { try { _context.Users.Update(user); _context.SaveChanges(); } catch (DbUpdateException ex) { throw new DataAccessException(\"Failed to save user\", ex); } } } After (Result Pattern): public class UserRepository { public Result<User> GetById(int id) { try { User user = _context.Users.FirstOrDefault(u => u.Id == id); return user != null ? Result.Success(user) : Result.NotFound<User>($\"User with ID {id}\"); } catch (SqlException ex) when (ex.Number == -2) // Timeout { return Result.ServerError<User>(\"Database timeout occurred\"); } catch (Exception ex) { _logger.LogError(ex, \"Error retrieving user {UserId}\", id); return Result.ServerError<User>(\"Database error occurred\"); } } public Result Save(User user) { try { _context.Users.Update(user); _context.SaveChanges(); return Result.Success(); } catch (DbUpdateConcurrencyException) { return Result.Failure(\"The user was modified by another user. Please refresh and try again.\"); } catch (DbUpdateException ex) { _logger.LogError(ex, \"Failed to save user {UserId}\", user.Id); return Result.ServerError(\"Failed to save user\"); } } } 3. Business Logic Before (Exceptions): public class OrderService { public Order ProcessOrder(OrderRequest request) { User user = _userService.GetUser(request.UserId); // Throws Product product = _productService.GetProduct(request.ProductId); // Throws if (product.Stock < request.Quantity) throw new InsufficientStockException($\"Only {product.Stock} items available\"); if (user.Balance < product.Price * request.Quantity) throw new InsufficientFundsException(\"Insufficient funds\"); Order order = new Order(user, product, request.Quantity); _orderRepository.Save(order); // Throws return order; } } After (Result Pattern): public class OrderService { public Result<Order> ProcessOrder(OrderRequest request) { Result<User> userResult = _userService.GetUser(request.UserId); if (userResult.IsFailure) return Result.Failure<Order>($\"User validation failed: {userResult.Error}\"); Result<Product> productResult = _productService.GetProduct(request.ProductId); if (productResult.IsFailure) return Result.Failure<Order>($\"Product validation failed: {productResult.Error}\"); User user = userResult.Value; Product product = productResult.Value; if (product.Stock < request.Quantity) return Result.Failure<Order>($\"Insufficient stock. Only {product.Stock} items available\"); decimal totalCost = product.Price * request.Quantity; if (user.Balance < totalCost) return Result.Failure<Order>(\"Insufficient funds for this order\"); Order order = new Order(user, product, request.Quantity); Result saveResult = _orderRepository.Save(order); return saveResult.IsSuccess ? Result.Success(order) : Result.Failure<Order>($\"Failed to save order: {saveResult.Error}\"); } } // Alternative: Using Result.Combine for cleaner composition public Result<Order> ProcessOrderAlternative(OrderRequest request) { Result<User> userResult = _userService.GetUser(request.UserId); Result<Product> productResult = _productService.GetProduct(request.ProductId); // Combine the results - if either fails, we get all failure information Result combinedValidation = Result.Combine(userResult, productResult); if (combinedValidation.IsFailure) return Result.Failure<Order>(combinedValidation.Error); // Continue with business logic validation and order creation return ValidateAndCreateOrder(userResult.Value, productResult.Value, request); } 4. Chaining Operations Before (Exceptions): public string ProcessUserData(int userId) { User user = GetUser(userId); // Throws string processedData = ProcessData(user.Data); // Throws string finalResult = FormatResult(processedData); // Throws SaveResult(finalResult); // Throws return finalResult; } After (Result Pattern): // Using explicit chaining public Result<string> ProcessUserData(int userId) { Result<User> userResult = GetUser(userId); if (userResult.IsFailure) return Result.Failure<string>(userResult.Error); Result<string> processedResult = ProcessData(userResult.Value.Data); if (processedResult.IsFailure) return Result.Failure<string>(processedResult.Error); Result<string> formattedResult = FormatResult(processedResult.Value); if (formattedResult.IsFailure) return Result.Failure<string>(formattedResult.Error); Result saveResult = SaveResult(formattedResult.Value); return saveResult.IsSuccess ? formattedResult : Result.Failure<string>(saveResult.Error); } // Using functional composition with extension methods public Result<string> ProcessUserDataFunctional(int userId) { return GetUser(userId) .Bind(user => ProcessData(user.Data)) .Bind(processed => FormatResult(processed)) .Bind(formatted => SaveResult(formatted) .Match( onSuccess: () => Result.Success(formatted), onFailure: error => Result.Failure<string>(error) )); } // Extension method for functional chaining (you can add this to your codebase) public static Result<TResult> Bind<T, TResult>(this Result<T> result, Func<T, Result<TResult>> func) { return result.Match( onSuccess: value => func(value), onFailure: error => Result.Failure<TResult>(error) ); } HTTP Integration FlowRight provides seamless HTTP integration for API scenarios. Client-Side HTTP Calls Before (Exceptions): public class ApiClient { public async Task<User> GetUserAsync(int userId) { HttpResponseMessage response = await _httpClient.GetAsync($\"/api/users/{userId}\"); if (!response.IsSuccessStatusCode) { if (response.StatusCode == HttpStatusCode.NotFound) throw new UserNotFoundException($\"User {userId} not found\"); if (response.StatusCode == HttpStatusCode.Unauthorized) throw new UnauthorizedAccessException(\"Not authorized\"); throw new HttpRequestException($\"HTTP {response.StatusCode}: {response.ReasonPhrase}\"); } string json = await response.Content.ReadAsStringAsync(); User user = JsonSerializer.Deserialize<User>(json) ?? throw new InvalidDataException(\"Failed to deserialize user\"); return user; } } After (Result Pattern): public class ApiClient { public async Task<Result<User>> GetUserAsync(int userId) { try { HttpResponseMessage response = await _httpClient.GetAsync($\"/api/users/{userId}\"); return await response.ToResultFromJsonAsync<User>(); } catch (HttpRequestException ex) { return Result.ServerError<User>($\"HTTP request failed: {ex.Message}\"); } catch (TaskCanceledException ex) { return Result.Failure<User>(new OperationCanceledException(\"Request timed out\", ex)); } } // Usage public async Task HandleUserRequest(int userId) { Result<User> userResult = await GetUserAsync(userId); userResult.Match( onSuccess: user => DisplayUser(user), onError: error => ShowError($\"Error: {error}\"), onSecurityException: _ => RedirectToLogin(), onValidationException: errors => ShowValidationErrors(errors), onOperationCanceledException: _ => ShowTimeoutMessage() ); } } Server-Side API Controllers Before (Exceptions): [ApiController] [Route(\"api/[controller]\")] public class UsersController : ControllerBase { [HttpGet(\"{id}\")] public ActionResult<User> GetUser(int id) { try { User user = _userService.GetUser(id); return Ok(user); } catch (UserNotFoundException) { return NotFound(); } catch (UnauthorizedAccessException) { return Forbid(); } catch (ArgumentException ex) { return BadRequest(ex.Message); } catch (Exception ex) { _logger.LogError(ex, \"Error retrieving user {UserId}\", id); return StatusCode(500, \"An error occurred\"); } } [HttpPost] public ActionResult<User> CreateUser(CreateUserRequest request) { try { User user = _userService.CreateUser(request); return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user); } catch (ValidationException ex) { return BadRequest(ex.ValidationErrors); } catch (DuplicateEmailException) { return Conflict(\"Email already exists\"); } catch (Exception ex) { _logger.LogError(ex, \"Error creating user\"); return StatusCode(500, \"An error occurred\"); } } } After (Result Pattern): [ApiController] [Route(\"api/[controller]\")] public class UsersController : ControllerBase { [HttpGet(\"{id}\")] public async Task<ActionResult<User>> GetUser(int id) { Result<User> result = await _userService.GetUserAsync(id); return result.Match( onSuccess: user => Ok(user), onError: error => BadRequest(error), onSecurityException: _ => Forbid(), onValidationException: errors => BadRequest(errors), onOperationCanceledException: _ => StatusCode(408, \"Request timeout\") ); } [HttpPost] public async Task<ActionResult<User>> CreateUser(CreateUserRequest request) { Result<User> result = await _userService.CreateUserAsync(request); return result.Match( onSuccess: user => CreatedAtAction(nameof(GetUser), new { id = user.Id }, user), onError: error => BadRequest(error), onSecurityException: _ => Forbid(), onValidationException: errors => BadRequest(errors), onOperationCanceledException: _ => StatusCode(408, \"Request timeout\") ); } // Alternative: Extension method for cleaner controller actions [HttpGet(\"{id}/alternative\")] public async Task<ActionResult<User>> GetUserAlternative(int id) { Result<User> result = await _userService.GetUserAsync(id); return result.ToActionResult(); } } // Extension method to convert Results to ActionResults public static class ResultExtensions { public static ActionResult<T> ToActionResult<T>(this Result<T> result) { return result.Match( onSuccess: value => new OkObjectResult(value), onError: error => new BadRequestObjectResult(error), onSecurityException: _ => new ForbidResult(), onValidationException: errors => new BadRequestObjectResult(errors), onOperationCanceledException: _ => new StatusCodeResult(408) ); } public static ActionResult ToActionResult(this Result result) { return result.Match( onSuccess: () => new OkResult(), onError: error => new BadRequestObjectResult(error), onSecurityException: _ => new ForbidResult(), onValidationException: errors => new BadRequestObjectResult(errors), onOperationCanceledException: _ => new StatusCodeResult(408) ); } } Validation Migration From Data Annotations Before (Data Annotations + Exceptions): public class CreateUserRequest { [Required(ErrorMessage = \"Name is required\")] [StringLength(50, ErrorMessage = \"Name cannot exceed 50 characters\")] public string Name { get; set; } [Required(ErrorMessage = \"Email is required\")] [EmailAddress(ErrorMessage = \"Invalid email format\")] public string Email { get; set; } [Range(18, 120, ErrorMessage = \"Age must be between 18 and 120\")] public int Age { get; set; } } public User CreateUser(CreateUserRequest request) { ValidationContext context = new(request); List<ValidationResult> results = []; if (!Validator.TryValidateObject(request, context, results, true)) { Dictionary<string, List<string>> errors = results .GroupBy(r => r.MemberNames.First()) .ToDictionary(g => g.Key, g => g.Select(r => r.ErrorMessage).ToList()); throw new ValidationException(errors); } return new User(request.Name, request.Email, request.Age); } After (FlowRight Validation): public class CreateUserRequest { public string Name { get; set; } = string.Empty; public string Email { get; set; } = string.Empty; public int Age { get; set; } } public Result<User> CreateUser(CreateUserRequest request) { return new ValidationBuilder<User>() .RuleFor(x => x.Name, request.Name) .NotEmpty() .MaxLength(50) .RuleFor(x => x.Email, request.Email) .NotEmpty() .EmailAddress() .RuleFor(x => x.Age, request.Age) .InclusiveBetween(18, 120) .Build(() => new User(request.Name, request.Email, request.Age)); } From FluentValidation Before (FluentValidation + Exceptions): public class CreateUserRequestValidator : AbstractValidator<CreateUserRequest> { public CreateUserRequestValidator() { RuleFor(x => x.Name) .NotEmpty() .MaximumLength(50); RuleFor(x => x.Email) .NotEmpty() .EmailAddress(); RuleFor(x => x.Age) .InclusiveBetween(18, 120); } } public User CreateUser(CreateUserRequest request) { CreateUserRequestValidator validator = new(); ValidationResult result = validator.Validate(request); if (!result.IsValid) { throw new ValidationException(result.Errors); } return new User(request.Name, request.Email, request.Age); } After (FlowRight Validation): // No separate validator class needed public Result<User> CreateUser(CreateUserRequest request) { return new ValidationBuilder<User>() .RuleFor(x => x.Name, request.Name) .NotEmpty() .MaxLength(50) .RuleFor(x => x.Email, request.Email) .NotEmpty() .EmailAddress() .RuleFor(x => x.Age, request.Age) .InclusiveBetween(18, 120) .Build(() => new User(request.Name, request.Email, request.Age)); } // Or if you prefer a separate validator pattern: public class UserValidator { public static Result<User> ValidateAndCreate(CreateUserRequest request) { return new ValidationBuilder<User>() .RuleFor(x => x.Name, request.Name) .NotEmpty() .MaxLength(50) .RuleFor(x => x.Email, request.Email) .NotEmpty() .EmailAddress() .Must(email => IsUniqueEmail(email), \"Email already exists\") .RuleFor(x => x.Age, request.Age) .InclusiveBetween(18, 120) .Build(() => new User(request.Name, request.Email, request.Age)); } private static bool IsUniqueEmail(string email) { // Check database for uniqueness return true; } } Performance Benefits Exception Performance Costs // ❌ Expensive exception throwing [Benchmark] public string ProcessWithExceptions() { try { return ProcessData(\"invalid-data\"); // Throws frequently } catch (ArgumentException) { return \"Invalid data\"; } } // Results: // Method | Mean | Error | StdDev | Allocated // -------------------- |--------:|--------:|--------:|----------: // ProcessWithExceptions| 2.543 μs| 0.051 μs| 0.048 μs| 552 B Result Pattern Performance // ✅ Fast Result pattern [Benchmark] public string ProcessWithResults() { Result<string> result = ProcessDataSafe(\"invalid-data\"); return result.Match( onSuccess: data => data, onFailure: _ => \"Invalid data\" ); } // Results: // Method | Mean | Error | StdDev | Allocated // ------------------- |--------:|--------:|--------:|----------: // ProcessWithResults | 0.012 μs| 0.001 μs| 0.001 μs| 0 B Memory Allocation Comparison // Exception stack trace allocation public class ExceptionPerformanceTest { [Benchmark] public bool ValidateWithExceptions(string input) { try { ValidateInput(input); return true; } catch (ArgumentException) { return false; } } [Benchmark] public bool ValidateWithResults(string input) { Result result = ValidateInputSafe(input); return result.IsSuccess; } private void ValidateInput(string input) { if (string.IsNullOrEmpty(input)) throw new ArgumentException(\"Input cannot be null or empty\"); } private Result ValidateInputSafe(string input) { return string.IsNullOrEmpty(input) ? Result.Failure(\"Input cannot be null or empty\") : Result.Success(); } } // Benchmark Results: // | Method | Mean | Error | StdDev | Gen 0 | Allocated | // |---------------------- |----------:|---------:|---------:|-------:|----------:| // | ValidateWithExceptions| 1,234.5 ns| 24.67 ns| 23.08 ns| 0.0763 | 320 B | // | ValidateWithResults | 1.2 ns| 0.03 ns| 0.02 ns| - | 0 B | Team Adoption Phase 1: Education and Setup (Weeks 1-2) Team Training Present this migration guide Code examples and hands-on practice Establish coding standards Development Environment # Install FlowRight packages dotnet add package FlowRight.Core dotnet add package FlowRight.Validation dotnet add package FlowRight.Http Code Guidelines // ✅ Good: Result methods are explicit about failure possibilities public Result<User> GetUser(int id); // ❌ Avoid: Mixed patterns in the same service public User GetUserUnsafe(int id); // throws public Result<User> GetUserSafe(int id); Phase 2: New Feature Development (Weeks 3-6) New Code Standards All new services use Result pattern All new API endpoints return Results All new validation uses ValidationBuilder Code Review Checklist [ ] No new exception-throwing methods [ ] Results handled with Match/Switch [ ] Validation uses ValidationBuilder [ ] HTTP calls use ToResultAsync extensions Example Standards Document // Service layer standard public interface IUserService { Task<Result<User>> GetUserAsync(int id); Task<Result<User>> CreateUserAsync(CreateUserRequest request); Task<Result> UpdateUserAsync(int id, UpdateUserRequest request); Task<Result> DeleteUserAsync(int id); } // Controller standard [ApiController] public abstract class BaseController : ControllerBase { protected ActionResult<T> ToActionResult<T>(Result<T> result) { return result.Match( onSuccess: value => Ok(value), onError: error => BadRequest(error), onSecurityException: _ => Forbid(), onValidationException: errors => BadRequest(errors), onOperationCanceledException: _ => StatusCode(408) ); } } Phase 3: Legacy Code Migration (Weeks 7-12) Identify High-Impact Areas Frequently called methods Methods with complex exception handling API boundaries Migration Priority // Priority 1: Public API surfaces [ApiController] public class UsersController : ControllerBase { // Migrate these first } // Priority 2: Service layer interfaces public interface IUserService { // Migrate method signatures } // Priority 3: Internal implementations // Can be migrated gradually Backward Compatibility // Maintain both interfaces during transition public class UserService : IUserService, ILegacyUserService { // New Result-based methods public Result<User> GetUser(int id) => GetUserLegacy(id).ToResult(); // Legacy methods (mark as obsolete) [Obsolete(\"Use GetUser(int) instead\")] public User GetUserLegacy(int id) { Result<User> result = GetUser(id); return result.Match( onSuccess: user => user, onFailure: error => throw new InvalidOperationException(error) ); } } Phase 4: Complete Migration (Weeks 13+) Remove Legacy Code Remove obsolete methods Update all call sites Remove exception-based error handling Performance Optimization Measure before/after performance Optimize hot paths Monitor memory allocation Documentation and Training Update team documentation Create architecture decision records Train new team members Migration Checklist Pre-Migration Assessment [ ] Codebase Analysis [ ] Identify all exception-throwing methods [ ] Map exception types to Result failure types [ ] Identify validation logic locations [ ] Document API surface areas [ ] Team Readiness [ ] Team trained on Result pattern [ ] Coding standards established [ ] Development environment setup [ ] CI/CD pipeline updated Migration Execution [ ] Phase 1: New Development [ ] All new services use Result pattern [ ] New API endpoints return Results [ ] New validation uses ValidationBuilder [ ] Code review process updated [ ] Phase 2: API Boundaries [ ] HTTP client calls converted [ ] API controller actions converted [ ] Service interfaces updated [ ] Database operations converted [ ] Phase 3: Internal Logic [ ] Business logic methods converted [ ] Repository methods converted [ ] Utility methods converted [ ] Legacy adapters removed Post-Migration Validation [ ] Testing [ ] All unit tests updated [ ] Integration tests passing [ ] Performance benchmarks improved [ ] Error handling coverage complete [ ] Quality Assurance [ ] No exceptions used for control flow [ ] All Results properly handled [ ] Error messages user-friendly [ ] Logging appropriately implemented [ ] Performance [ ] Benchmark comparisons documented [ ] Memory allocation reduced [ ] Response times improved [ ] Error path performance optimized Success Metrics Track these metrics to measure migration success: // Example metrics tracking public class MigrationMetrics { public int ExceptionThrowingMethods { get; set; } public int ResultReturningMethods { get; set; } public int UnhandledExceptions { get; set; } public int MigratedApiEndpoints { get; set; } public double AverageResponseTime { get; set; } public long MemoryAllocation { get; set; } } // Target metrics: // - 0 exception-throwing methods for control flow // - 100% Result pattern adoption for new code // - 50%+ reduction in unhandled exceptions // - 20%+ improvement in response times // - 30%+ reduction in memory allocation Conclusion Migrating from exceptions to the FlowRight Result pattern provides: Explicit Error Handling - All failure scenarios are visible in method signatures Better Performance - Zero-allocation success paths and no stack unwinding overhead Improved Composability - Easy to chain operations and handle complex scenarios Enhanced Maintainability - Clear separation of success and failure flows Type Safety - Compile-time guarantees about error handling The migration can be done gradually, starting with new development and progressively converting existing code. Focus on high-impact areas first, maintain backward compatibility during transition, and measure success with concrete metrics. Remember: The Result pattern isn't about eliminating all exceptions, but about using exceptions only for truly exceptional circumstances while handling expected failure scenarios explicitly and efficiently."
  },
  "index.html": {
    "href": "index.html",
    "title": "FlowRight API Documentation | FlowRight - Result Pattern Library for .NET",
    "summary": "FlowRight API Documentation Welcome to the FlowRight API documentation. FlowRight is a production-grade Result pattern library for .NET that provides explicit error handling without exceptions. What is FlowRight? FlowRight transforms traditional exception-based error handling into explicit, type-safe result patterns. Instead of throwing exceptions for business logic errors, FlowRight returns Result<T> objects that explicitly represent success or failure states. Key Features Zero Exception Policy: Never throw exceptions for control flow Immutable Results: Thread-safe, immutable result types Rich Validation: Fluent validation builders with comprehensive rules HTTP Integration: Seamless conversion between HTTP responses and Results JSON Serialization: Full support for System.Text.Json Performance: Minimal allocations and high-performance operations Getting Started Choose your area of interest: \uD83D\uDCDA Articles Comprehensive guides, tutorials, and best practices for using FlowRight effectively. \uD83D\uDD0D API Reference Complete API documentation for all FlowRight libraries. Libraries FlowRight.Core The foundational Result pattern implementation with core types like Result<T>, Success<T>, and Failure. FlowRight.Validation Fluent validation builders that integrate seamlessly with the Result pattern. FlowRight.Http HTTP response to Result pattern conversion utilities for web applications. Quick Example using FlowRight.Core; using FlowRight.Validation; // Create a validation builder ValidationBuilder<User> validator = new ValidationBuilder<User>() .RuleFor(u => u.Email) .NotEmpty() .Email() .RuleFor(u => u.Age) .GreaterThan(0) .LessThan(150); // Validate and get a Result Result<User> result = validator.Validate(user, nameof(user)); // Handle the result return result.Match( success: user => Ok(user), failure: errors => BadRequest(errors) ); Contributing FlowRight is open source. Visit our GitHub repository to contribute."
  }
}