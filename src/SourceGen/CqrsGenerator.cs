using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace FlowRight.Cqrs.Http.SourceGen;

/// <summary>
/// Source generator that creates strongly-typed HTTP clients and ExecuteAsync extensions 
/// for classes implementing ICommand or IQuery interfaces.
/// </summary>
[Generator]
public class CqrsGenerator : IIncrementalGenerator
{
    /// <inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        //if (!System.Diagnostics.Debugger.IsAttached)
        //{
        //    System.Diagnostics.Debugger.Launch();
        //}
#endif

        IncrementalValuesProvider<INamedTypeSymbol> baseTypedSymbols = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is BaseTypeDeclarationSyntax { BaseList.Types.Count: > 0 },
                transform: static (context, _) => GetSemanticTargetForGeneration(context))
            .Where(static m => m is not null)!;

        context.RegisterSourceOutput(baseTypedSymbols.Collect(),
            static (context, namedTypedSymbols) => Execute(context, namedTypedSymbols));
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> namedTypedSymbols)
    {
        if (namedTypedSymbols.Length > 0)
        {
            IGrouping<string, INamedTypeSymbol>[] groupedByNamespace = [.. namedTypedSymbols.GroupBy(x => x.ContainingNamespace?.ToDisplayString() ?? "Global")];

            foreach (IGrouping<string, INamedTypeSymbol> namespaceGroup in groupedByNamespace)
            {
                ImmutableArray<INamedTypeSymbol> symbolsInNamespace = namespaceGroup.ToImmutableArray();
                string namespaceName = namespaceGroup.Key;
                string className = $"{namespaceName.Split('.').Last()}HttpClient";
                string httpClientCode = GenerateHttpClientCode(namespaceName, className, symbolsInNamespace);
                context.AddSource($"{className}.g.cs", SourceText.From(httpClientCode, Encoding.UTF8));
            }

            foreach (INamedTypeSymbol namedTypedSymbol in namedTypedSymbols)
            {
                string cqrsCode = GenerateCqrsCode(namedTypedSymbol);
                context.AddSource($"{namedTypedSymbol.Name}_Generated.g.cs", SourceText.From(cqrsCode, Encoding.UTF8));
            }
        }

        string httpClientRegistrationCode = GenerateHttpClientRegistrationCode(namedTypedSymbols);
        context.AddSource("FlowRightCqrsServiceCollectionExtensions.g.cs", SourceText.From(httpClientRegistrationCode, Encoding.UTF8));
    }

    private static string GenerateHttpClientRegistrationCode(ImmutableArray<INamedTypeSymbol> namedTypeSymbols)
    {
        IGrouping<string, INamedTypeSymbol>[] groupedByNamespace = namedTypeSymbols.GroupBy(x => x.ContainingNamespace?.ToDisplayString() ?? "Global").ToArray();

        StringBuilder sourceBuilder = new();
        sourceBuilder.AppendLine("// <auto-generated />");
        sourceBuilder.AppendLine("#nullable enable");
        sourceBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection;");

        foreach (IGrouping<string, INamedTypeSymbol> namespaceGroup in groupedByNamespace)
        {
            sourceBuilder.AppendLine($"using {namespaceGroup.Key};");
        }

        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("namespace FlowRight.Cqrs.Http;");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("/// <summary>");
        sourceBuilder.AppendLine("/// Extension methods for configuring FlowRight CQRS HTTP services.");
        sourceBuilder.AppendLine("/// </summary>");
        sourceBuilder.AppendLine("public static class FlowRightCqrsServiceCollectionExtensions");
        sourceBuilder.AppendLine("{");
        sourceBuilder.AppendLine("    /// <summary>");
        sourceBuilder.AppendLine("    /// Adds FlowRight CQRS HTTP client services to the specified service collection.");
        sourceBuilder.AppendLine("    /// </summary>");
        sourceBuilder.AppendLine("    /// <param name=\"services\">The service collection to add services to.</param>");
        sourceBuilder.AppendLine("    /// <param name=\"baseAddress\">The base address for the API endpoints.</param>");
        sourceBuilder.AppendLine("    /// <returns>The service collection for chaining.</returns>");
        sourceBuilder.AppendLine("    /// <exception cref=\"ArgumentNullException\">Thrown when <paramref name=\"baseAddress\"/> is null.</exception>");
        sourceBuilder.AppendLine("    public static IServiceCollection AddFlowRightCqrs(this IServiceCollection services, Uri baseAddress)");
        sourceBuilder.AppendLine("    {");
        sourceBuilder.AppendLine("        ArgumentNullException.ThrowIfNull(baseAddress);");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("        // Register core services");
        sourceBuilder.AppendLine("        services.AddHttpClient()");
        sourceBuilder.AppendLine("            .AddSingleton<IServiceResolver, ServiceResolver>()");
        sourceBuilder.AppendLine("            .AddSingleton(new System.Text.Json.JsonSerializerOptions");
        sourceBuilder.AppendLine("            {");
        sourceBuilder.AppendLine("                PropertyNameCaseInsensitive = true,");
        sourceBuilder.AppendLine("                WriteIndented = false,");
        sourceBuilder.AppendLine("                DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull");
        sourceBuilder.AppendLine("            });");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("        // Register generated HTTP clients");

        foreach (IGrouping<string, INamedTypeSymbol> namespaceGroup in groupedByNamespace)
        {
            string clientName = $"{namespaceGroup.Key.Split('.').Last()}HttpClient";
            sourceBuilder.AppendLine($"        services.AddHttpClient<{clientName}>(client => client.BaseAddress = baseAddress);");
        }

        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("        return services;");
        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine("}");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("/// <summary>");
        sourceBuilder.AppendLine("/// Extension methods for configuring FlowRight CQRS HTTP services with service provider.");
        sourceBuilder.AppendLine("/// </summary>");
        sourceBuilder.AppendLine("public static class FlowRightCqrsServiceProviderExtensions");
        sourceBuilder.AppendLine("{");
        sourceBuilder.AppendLine("    /// <summary>");
        sourceBuilder.AppendLine("    /// Configures the FlowRight CQRS HTTP services using the provided service provider.");
        sourceBuilder.AppendLine("    /// This method must be called after the service provider is built to initialize the Config.ServiceResolver.");
        sourceBuilder.AppendLine("    /// </summary>");
        sourceBuilder.AppendLine("    /// <param name=\"serviceProvider\">The service provider containing the registered services.</param>");
        sourceBuilder.AppendLine("    /// <returns>The service provider for chaining.</returns>");
        sourceBuilder.AppendLine("    /// <exception cref=\"ArgumentNullException\">Thrown when <paramref name=\"serviceProvider\"/> is null.</exception>");
        sourceBuilder.AppendLine("    public static IServiceProvider UseFlowRightCqrs(this IServiceProvider serviceProvider)");
        sourceBuilder.AppendLine("    {");
        sourceBuilder.AppendLine("        ArgumentNullException.ThrowIfNull(serviceProvider);");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("        // Initialize the global Config.ServiceResolver for generated code to use");
        sourceBuilder.AppendLine("        Config.ServiceResolver = serviceProvider.GetRequiredService<IServiceResolver>();");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("        return serviceProvider;");
        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine("}");

        return sourceBuilder.ToString();
    }

    private static string GenerateHttpClientCode(string namespaceName, string className, ImmutableArray<INamedTypeSymbol> symbolsInNamespace)
    {
        StringBuilder sourceBuilder = new();
        sourceBuilder.AppendLine("// <auto-generated />");
        sourceBuilder.AppendLine("#nullable enable");
        sourceBuilder.AppendLine("using FlowRight.Core.Results;");
        sourceBuilder.AppendLine("using FlowRight.Cqrs.Http;");
        sourceBuilder.AppendLine("using FlowRight.Http;");
        sourceBuilder.AppendLine("using FlowRight.Http.Extensions;");
        sourceBuilder.AppendLine("using System.Net.Http.Headers;");
        sourceBuilder.AppendLine("using System.Net.Mime;");
        sourceBuilder.AppendLine("using System.Text.Json;");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine($"namespace {namespaceName};");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("/// <summary>");
        sourceBuilder.AppendLine($"/// Generated HTTP client for CQRS operations in the {namespaceName} namespace.");
        sourceBuilder.AppendLine("/// </summary>");
        sourceBuilder.AppendLine($"public sealed class {className}(HttpClient httpClient, JsonSerializerOptions options)");
        sourceBuilder.AppendLine("{");
        sourceBuilder.AppendLine("    private readonly HttpClient _httpClient = httpClient;");
        sourceBuilder.AppendLine("    private readonly JsonSerializerOptions _options = options;");

        foreach (INamedTypeSymbol namedTypeSymbol in symbolsInNamespace)
        {
            AddGenerateHttpClientCqrsMethodCode(sourceBuilder, namedTypeSymbol);
        }

        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("    private async Task<HttpResponseMessage> PostAsync(IRequest request, MemoryStream memoryStream, CancellationToken cancellationToken)");
        sourceBuilder.AppendLine("    {");
        sourceBuilder.AppendLine("        memoryStream.Seek(0, SeekOrigin.Begin);");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("        using HttpRequestMessage requestMessage = new(HttpMethod.Post, request.GetApiEndpoint());");
        sourceBuilder.AppendLine("        using StreamContent requestContent = new(memoryStream);");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("        requestMessage.Content = requestContent;");
        sourceBuilder.AppendLine("        requestMessage.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(MediaTypeNames.Application.Json));");
        sourceBuilder.AppendLine("        requestContent.Headers.ContentType = new MediaTypeHeaderValue(MediaTypeNames.Application.Json);");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("        return await _httpClient.SendAsync(requestMessage, HttpCompletionOption.ResponseHeadersRead, cancellationToken)");
        sourceBuilder.AppendLine("            .ConfigureAwait(false);");
        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine("}");

        return sourceBuilder.ToString();
    }

    private static void AddGenerateHttpClientCqrsMethodCode(StringBuilder sourceBuilder, INamedTypeSymbol namedTypeSymbol)
    {
        string methodName = GenerateCqrsMethodName(namedTypeSymbol);
        string returnType = string.Empty;
        bool isGeneric = false;
        bool isCommand = false;

        foreach (INamedTypeSymbol iface in namedTypeSymbol.AllInterfaces)
        {
            if (iface.Name is "ICommand" or "IQuery")
            {
                isCommand = iface.Name is "ICommand";

                if (iface.IsGenericType && iface.TypeArguments.Length > 0)
                {
                    isGeneric = true;
                    returnType = iface.TypeArguments[0]
                        .ToDisplayString()
                        .Replace("?", string.Empty);
                }
                break;
            }
        }

        string variableName = isCommand ? "command" : "query";
        string resultType = isGeneric ? $"Result<{returnType}>" : "Result";

        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("    /// <summary>");
        sourceBuilder.AppendLine($"    /// Executes the {namedTypeSymbol.Name} {(isCommand ? "command" : "query")} via HTTP.");
        sourceBuilder.AppendLine("    /// </summary>");
        sourceBuilder.AppendLine($"    /// <param name=\"{variableName}\">The {(isCommand ? "command" : "query")} to execute.</param>");
        sourceBuilder.AppendLine("    /// <param name=\"cancellationToken\">The cancellation token.</param>");
        sourceBuilder.AppendLine($"    /// <returns>A Result containing the {(isCommand ? "command" : "query")} result.</returns>");
        sourceBuilder.AppendLine($"    public async Task<{resultType}> {methodName}Async({namedTypeSymbol.ToDisplayString()} {variableName}, CancellationToken cancellationToken = default)");
        sourceBuilder.AppendLine("    {");

        if (isCommand)
        {
            sourceBuilder.AppendLine("        using MemoryStream memoryStream = new();");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"        await JsonSerializer.SerializeAsync(memoryStream, {variableName}, _options, cancellationToken)");
            sourceBuilder.AppendLine("            .ConfigureAwait(false);");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"        using HttpResponseMessage responseMessage = await PostAsync({variableName}, memoryStream, cancellationToken)");
            sourceBuilder.AppendLine("            .ConfigureAwait(false);");
            sourceBuilder.AppendLine();

            if (isGeneric)
            {
                sourceBuilder.AppendLine($"        return await responseMessage.ToResultFromJsonAsync<{returnType}>(_options, cancellationToken)");
            }
            else
            {
                sourceBuilder.AppendLine("        return await responseMessage.ToResultAsync(cancellationToken)");
            }
            sourceBuilder.AppendLine("            .ConfigureAwait(false);");
        }
        else
        {
            sourceBuilder.AppendLine($"        using HttpResponseMessage responseMessage = await _httpClient.GetAsync(new Uri(_httpClient.BaseAddress!, {variableName}.GetApiEndpoint()), HttpCompletionOption.ResponseHeadersRead, cancellationToken)");
            sourceBuilder.AppendLine("            .ConfigureAwait(false);");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"        return await responseMessage.ToResultFromJsonAsync<{returnType}>(_options, cancellationToken)");
            sourceBuilder.AppendLine("            .ConfigureAwait(false);");
        }

        sourceBuilder.AppendLine("    }");
    }

    private static string GenerateCqrsCode(INamedTypeSymbol namedTypedSymbol)
    {
        bool isGeneric = false;
        string namespaceName = namedTypedSymbol.ContainingNamespace.ToDisplayString();
        string baseTypeName = GenerateCqrsMethodName(namedTypedSymbol);
        string baseType = namedTypedSymbol.IsRecord ? "record" : "class";
        string clientName = $"{namespaceName.Split('.').Last()}HttpClient";
        string returnType = string.Empty;
        string sealedModifier = namedTypedSymbol.IsSealed ? "sealed " : string.Empty;
        string accessibilityModifier = namedTypedSymbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            _ => throw new NotSupportedException($"Unsupported accessibility: {namedTypedSymbol.DeclaredAccessibility}")
        };

        foreach (INamedTypeSymbol iface in namedTypedSymbol.AllInterfaces)
        {
            if (iface.Name is "ICommand" or "IQuery")
            {
                if (iface.IsGenericType && iface.TypeArguments.Length > 0)
                {
                    isGeneric = true;
                    returnType = iface.TypeArguments[0]
                        .ToDisplayString()
                        .Replace("?", string.Empty);
                }
                break;
            }
        }

        string resultType = isGeneric ? $"Result<{returnType}>" : "Result";

        StringBuilder sourceBuilder = new();
        sourceBuilder.AppendLine("// <auto-generated />");
        if (isGeneric)
        {
            sourceBuilder.AppendLine("#nullable enable");
        }
        sourceBuilder.AppendLine("using FlowRight.Core.Results;");
        sourceBuilder.AppendLine("using FlowRight.Cqrs.Http;");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine($"namespace {namespaceName};");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("/// <summary>");
        sourceBuilder.AppendLine($"/// Generated ExecuteAsync extension for {namedTypedSymbol.Name}.");
        sourceBuilder.AppendLine("/// </summary>");
        sourceBuilder.AppendLine($"{accessibilityModifier} {sealedModifier}partial {baseType} {namedTypedSymbol.Name}");
        sourceBuilder.AppendLine("{");
        sourceBuilder.AppendLine("    /// <summary>");
        sourceBuilder.AppendLine($"    /// Executes this {(namedTypedSymbol.Name.Contains("Command") ? "command" : "query")} via HTTP.");
        sourceBuilder.AppendLine("    /// </summary>");
        sourceBuilder.AppendLine("    /// <param name=\"cancellationToken\">The cancellation token.</param>");
        sourceBuilder.AppendLine("    /// <returns>A Result containing the execution result.</returns>");
        sourceBuilder.AppendLine($"    public async Task<{resultType}> ExecuteAsync(CancellationToken cancellationToken = default)");
        sourceBuilder.AppendLine("    {");
        sourceBuilder.AppendLine($"        {clientName} client = Config.ServiceResolver.GetRequiredService<{clientName}>();");
        sourceBuilder.AppendLine($"        return await client.{baseTypeName}Async(this, cancellationToken);");
        sourceBuilder.AppendLine("    }");
        sourceBuilder.AppendLine("}");

        return sourceBuilder.ToString();
    }

    private static string GenerateCqrsMethodName(INamedTypeSymbol namedTypedSymbol) =>
        namedTypedSymbol.Name
            .Replace("Command", string.Empty)
            .Replace("Query", string.Empty)
            .Replace("Async", string.Empty);

    private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        BaseTypeDeclarationSyntax baseTypeDeclarationSyntax = (BaseTypeDeclarationSyntax)context.Node;
        SemanticModel semanticModel = context.SemanticModel;

        if (semanticModel.GetDeclaredSymbol(baseTypeDeclarationSyntax) is not INamedTypeSymbol baseTypeSymbol || baseTypeSymbol.IsAbstract)
        {
            return null;
        }

        bool implementsInterface = baseTypeSymbol.AllInterfaces.Any(i =>
            i.ToDisplayString().StartsWith("FlowRight.Cqrs.Http.IRequest"));

        return implementsInterface ? baseTypeSymbol : null;
    }
}